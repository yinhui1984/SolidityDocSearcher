<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Solidity 0.8.17 文档</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/a4_railroad_diagram.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/toggle.css" type="text/css" />
    <link rel="canonical" href="https://docs.soliditylang.org/zh/v0.8.17/index.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #65afff" >
            <a href="#">
            <img src="_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                v0.8.17
              </div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
    
              <p class="caption" role="heading"><span class="caption-text">基础知识</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-introduction-to-smart-contracts">智能合约概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-installing-solidity">安装 Solidity 编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-solidity-by-example">Solidity 合约示例</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">语言描述</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-layout-of-source-files">Solidity 源文件结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-structure-of-a-contract">合约结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-types">类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-units-and-global-variables">单位和全局变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-control-structures">表达式和控制结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-contracts">合约</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-assembly">内联汇编</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cheatsheet">速查表</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-grammar">语法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">编译器</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-using-the-compiler">使用编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-analysing-compilation-output">分析编译器的输出结果</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-ir-breaking-changes">基于 Solidity 中间表征的 Codegen 变化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">内部说明</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internals/layout_in_storage">存储中的状态变量储存结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internals/layout_in_memory">内存中的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internals/layout_in_calldata">调用数据的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internals/variable_cleanup">清理变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internals/source_mappings">源代码映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internals/optimizer">优化器</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-metadata">合约的元数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-abi-spec">合约ABI规范</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">补充材料</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-050-breaking-changes">Solidity v0.5.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-060-breaking-changes">Solidity 0.6.0 版本突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-070-breaking-changes">Solidity v0.7.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-080-breaking-changes">Solidity v0.8.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-natspec-format">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-security-considerations">安全考虑</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-smtchecker">SMT检查器和形式化验证</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-resources">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-path-resolution">导入路径解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-yul">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-style-guide">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-common-patterns">通用模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-bugs">已知bug列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-contributing">贡献方式</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-brand-guide">Solidity 品牌指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-language-influences">语言的影响因素</a></li>
</ul>

    <ul>
        <li>
            <a href="genindex.html">Keyword Index</a>
        </li>
    </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #65afff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Solidity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Solidity 0.8.17 文档</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/solidity-docs/zh-chinese/blob/v0.8.17/docs/index" class="fa fa-github"> 在 GitHub 上编辑</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="solidity">
<h1>Solidity<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h1>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>You are reading a community translation of the Solidity documentation. The Solidity team
can give no guarantees on the quality and accuracy of the translations provided.
The English reference version is and will remain the only officially supported version
by the Solidity team and will always be the most accurate and most up-to-date one.
When in doubt, please always refer to the <a class="reference external" href="https://docs.soliditylang.org/en/latest/">English (original) documentation</a>.</p>
</div>
<p>Solidity是一门为实现智能合约而创建的面向对象的高级编程语言。 智能合约是管理以太坊中账户行为的程序。</p>
<p>Solidity 是一种面向以太坊虚拟机 (EVM) 的 <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages">带花括号的语言</a>。
它受 C++，Python 和 JavaScript 的影响。您可以在  <a class="reference internal" href="index.html#document-language-influences"><span class="doc">语言的影响因素</span></a> 部分中找到更多有关 Solidity 受哪些语言启发的细节。</p>
<p>Solidity 是静态类型语言，支持继承，库和复杂的用户自定义的类型以及其他特性。</p>
<p>下面您将会看到，使用 Solidity，您可以创建用于投票、众筹、秘密竞价（盲拍）以及多重签名钱包等用途的合约。</p>
<p>当开发智能合约时，您应该使用最新版本的Solidity。除某些特殊情况之外，只有最新版本才会收到
<a class="reference external" href="https://github.com/ethereum/solidity/security/policy#supported-versions">安全修复</a>。
此外，重大的变化以及新功能会定期引入。
目前，我们使用 0.y.z 版本号 <a class="reference external" href="https://semver.org/#spec-item-4">来表明这种快速的变化</a>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Solidity最近发布了0.8.x版本，该版本引入了许多重大更新。 清务必阅读 <a class="reference internal" href="index.html#document-080-breaking-changes"><span class="doc">完整列表</span></a>。</p>
</div>
<p>始终欢迎改进 Solidity 或此文档的想法,
请阅读我们的 <a class="reference internal" href="index.html#document-contributing"><span class="doc">贡献者指南</span></a> 以了解更多细节。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>您可以通过点击左下角的版本号弹出的菜单来选择首选的下载格式来下载该文档的 PDF，HTML 或 Epub 格式。</p>
</div>
<section id="id4">
<h2>入门指南<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h2>
<p><strong>1. 了解智能合约基础知识</strong></p>
<p>如果您是智能合约概念的新手，我们建议您从深入了解 &quot;智能合约介绍&quot; 部分开始，其中包括：</p>
<ul class="simple">
<li><p>用 Solidity 编写的 <a class="reference internal" href="index.html#simple-smart-contract"><span class="std std-ref">一个简单的智能合约例子</span></a>。</p></li>
<li><p><a class="reference internal" href="index.html#blockchain-basics"><span class="std std-ref">区块链基础知识</span></a>.</p></li>
<li><p><a class="reference internal" href="index.html#the-ethereum-virtual-machine"><span class="std std-ref">以太坊虚拟机</span></a>.</p></li>
</ul>
<p><strong>2. 了解 Solidity</strong></p>
<p>一旦您熟悉了基础知识，我们建议您阅读 <a class="reference internal" href="index.html#document-solidity-by-example"><span class="doc">&quot;Solidity 示例&quot;</span></a>
和 “语言描述” 部分，以了解该语言的核心概念。</p>
<p><strong>3.安装 Solidity 编译器</strong></p>
<p>有多种方法可以安装 Solidity 编译器，
只需选择您喜欢的选项，并按照 <a class="reference internal" href="index.html#installing-solidity"><span class="std std-ref">安装页面</span></a> 上提供的步骤操作即可。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>您可以通过 <a class="reference external" href="https://remix.ethereum.org">Remix IDE</a> 在浏览器中直接尝试代码示例。
Remix 是一个基于网络浏览器的IDE，允许您编写，部署和管理Solidity智能合约，
无需在本地安装 Solidity。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>由于人类编写的软件可能会存在 bug，
因此在编写智能合约时应遵循软件开发的最佳实践。
这包括代码审查，测试，审计和正确性证明。
智能合约用户有时对代码的信心甚至超过了作者，
区块链和智能合约也存在独特的问题，
因此在开始编写生产代码之前，请确保您已阅读
<span class="xref std std-ref">安全考虑</span> 部分。</p>
</div>
<p><strong>4. 了解更多</strong></p>
<p>如果您想更深入了解如何在以太坊上构建去中心化应用，
<a class="reference external" href="https://ethereum.org/en/developers/">以太坊开发者资源</a> 可以为您提供有关以太坊的更多文档，
以及各种教程、工具和开发框架。</p>
<p>如果您有任何问题，可以在 <a class="reference external" href="https://ethereum.stackexchange.com/">以太坊 StackExchange</a> 上寻找答案，
或者在我们的 <a class="reference external" href="https://gitter.im/ethereum/solidity/">Gitter 频道</a>。</p>
</section>
<section id="translations">
<span id="id6"></span><h2>翻译<a class="headerlink" href="#translations" title="此标题的永久链接"></a></h2>
<p>社区贡献者帮助将本文档翻译成多种语言。
请注意，这些翻译的完整度和及时性各不相同。
因此英文版才是参考的标准。</p>
<p>您可以通过点击左下角的语言切换器来切换语言。
在弹出的菜单中，选择您需要的语言即可切换。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.soliditylang.org/fr/latest/">法语</a></p></li>
<li><p><a class="reference external" href="https://github.com/solidity-docs/id-indonesian">印度尼西亚语</a></p></li>
<li><p><a class="reference external" href="https://github.com/solidity-docs/fa-persian">波斯语</a></p></li>
<li><p><a class="reference external" href="https://github.com/solidity-docs/ja-japanese">日语</a></p></li>
<li><p><a class="reference external" href="https://github.com/solidity-docs/ko-korean">韩语</a></p></li>
<li><p><a class="reference external" href="https://github.com/solidity-docs/zh-cn-chinese/">简体中文</a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>我们最近建立了一个新的 GitHub 组织和翻译流程，以帮助简化社区的翻译工作。
有关如何开始新的翻译语言或为社区翻译作出贡献的信息，
请参阅 <a class="reference external" href="https://github.com/solidity-docs/translation-guide">翻译指南</a>。</p>
</div>
</section>
</section>
<section id="id14">
<h1>目录<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h1>
<p><a class="reference internal" href="genindex.html"><span class="std std-ref">关键字索引</span></a>, <a class="reference internal" href="search.html"><span class="std std-ref">搜索页面</span></a></p>
<div class="toctree-wrapper compound">
<span id="document-introduction-to-smart-contracts"></span><section id="id1">
<h2>智能合约概述<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<section id="simple-smart-contract">
<span id="id2"></span><h3>简单的智能合约<a class="headerlink" href="#simple-smart-contract" title="此标题的永久链接"></a></h3>
<p>让我们从一个基本的例子开始，这个例子设置了一个变量的值，并将其暴露给其他合约来访问。
如果您现在不理解这些东西也没关系，我们稍后会讨论更多细节。</p>
<section id="id3">
<h4>存储合约示例<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZVN0b3JhZ2UgewogICAgdWludCBzdG9yZWREYXRhOwoKICAgIGZ1bmN0aW9uIHNldCh1aW50IHgpIHB1YmxpYyB7CiAgICAgICAgc3RvcmVkRGF0YSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBzdG9yZWREYXRhOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleStorage</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">storedData</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">set</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>storedData<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">get</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>storedData<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>第一行告诉您，源代码是根据GPL3.0版本授权的。
在发布源代码是默认的情况下，机器可读的许可证说明是很重要的。</p>
<p>下一行指定源代码是为Solidity 0.4.16版本编写的，或该语言的较新版本，直到但不包括0.9.0版本。
这是为了确保合约不能被新的（有重大改变的）编译器版本编译，在那里它可能会有不同的表现。
<a class="reference internal" href="index.html#pragma"><span class="std std-ref">Pragmas</span></a> 是编译器关于如何处理源代码的常用指令
（例如， <a class="reference external" href="https://en.wikipedia.org/wiki/Pragma_once">pragma once</a> ）。</p>
<p>Solidity意义上的合约是代码（其 <em>函数</em>）和数据（其 <em>状态</em>）的集合，
驻留在以太坊区块链的一个特定地址。
这一行 <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">storedData;</span></code> 声明了一个名为 <code class="docutils literal notranslate"><span class="pre">storedData</span></code> 的状态变量，
类型为 <code class="docutils literal notranslate"><span class="pre">uint</span></code> （ <em>u</em>nsigned <em>int</em>eger，共 <em>256</em> 位）。
您可以把它看作是数据库中的一个槽，您可以通过调用管理数据库的代码函数来查询和改变它。
在这个例子中，合约定义了可以用来修改或检索变量值的函数 <code class="docutils literal notranslate"><span class="pre">set</span></code> 和 <code class="docutils literal notranslate"><span class="pre">get</span></code>。</p>
<p>要访问当前合约的一个成员（如状态变量），通常不需要添加 <code class="docutils literal notranslate"><span class="pre">this.</span></code> 前缀，
只需要通过它的名字直接访问它。
与其他一些语言不同的是，省略它不仅仅是一个风格问题，
它导致了一种完全不同的访问成员的方式，但后面会有更多关于这个问题。</p>
<p>该合约能完成的事情并不多（由于以太坊构建的基础架构的原因），
它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，
且没有可行的办法阻止您发布这个数字。
当然，任何人都可以再次调用 <code class="docutils literal notranslate"><span class="pre">set</span></code> ，传入不同的值，覆盖您的数字，
但是这个数字仍会被存储在区块链的历史记录中。
随后，我们会看到怎样施加访问限制，以确保只有您才能改变这个数字。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>小心使用Unicode文本，因为有些字符虽然长得相像（甚至一样），
但其字符码是不同的，其编码后的字符数组也会不一样。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。
UTF-8编码的数据可以用字符串变量的形式存储。</p>
</div>
</section>
<section id="subcurrency">
<span id="index-0"></span><h4>子货币（Subcurrency）例子<a class="headerlink" href="#subcurrency" title="此标题的永久链接"></a></h4>
<p>下面的合约实现了一个最简单的加密货币。
这里，币确实可以无中生有地产生，但是只有创建合约的人才能做到（实现一个不同的发行计划也不难）。
而且，任何人都可以给其他人转币，不需要注册用户名和密码，所需要的只是以太坊密钥对。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IENvaW4gewogICAgLy8g5YWz6ZSu5a2XICJwdWJsaWMiIOS9v+WPmOmHj+WPr+S7peS7juWFtuS7luWQiOe6puS4reiuv+mXruOAggogICAgYWRkcmVzcyBwdWJsaWMgbWludGVyOwogICAgbWFwcGluZyAoYWRkcmVzcyA9PiB1aW50KSBwdWJsaWMgYmFsYW5jZXM7CgogICAgLy8g5LqL5Lu25YWB6K645a6i5oi356uv5a+55oKo5aOw5piO55qE54m55a6a5ZCI57qm5Y+Y5YyW5YGa5Ye65Y+N5bqUCiAgICBldmVudCBTZW50KGFkZHJlc3MgZnJvbSwgYWRkcmVzcyB0bywgdWludCBhbW91bnQpOwoKICAgIC8vIOaehOmAoOWHveaVsOS7o+eggeWPquacieWcqOWQiOe6puWIm+W7uuaXtui/kOihjAogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgbWludGVyID0gbXNnLnNlbmRlcjsKICAgIH0KCiAgICAvLyDlkJHkuIDkuKrlnLDlnYDlj5HpgIHkuIDlrprmlbDph4/nmoTmlrDliJvlu7rnmoTku6PluIEKICAgIC8vIOS9huWPquiDveeUseWQiOe6puWIm+W7uuiAheiwg+eUqAogICAgZnVuY3Rpb24gbWludChhZGRyZXNzIHJlY2VpdmVyLCB1aW50IGFtb3VudCkgcHVibGljIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gbWludGVyKTsKICAgICAgICBiYWxhbmNlc1tyZWNlaXZlcl0gKz0gYW1vdW50OwogICAgfQoKICAgIC8vIOmUmeivr+exu+Wei+WPmOmHj+WFgeiuuOaCqOaPkOS+m+WFs+S6juaTjeS9nOWksei0peWOn+WboOeahOS/oeaBr+OAggogICAgLy8g5a6D5Lus5Lya6L+U5Zue57uZ5Ye95pWw55qE6LCD55So6ICF44CCCiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQgcmVxdWVzdGVkLCB1aW50IGF2YWlsYWJsZSk7CgogICAgLy8g5LuO5Lu75L2V6LCD55So6ICF6YKj6YeM5Y+R6YCB5LiA5a6a5pWw6YeP55qE5Luj5biB5Yiw5LiA5Liq5Zyw5Z2ACiAgICBmdW5jdGlvbiBzZW5kKGFkZHJlc3MgcmVjZWl2ZXIsIHVpbnQgYW1vdW50KSBwdWJsaWMgewogICAgICAgIGlmIChhbW91bnQgPiBiYWxhbmNlc1ttc2cuc2VuZGVyXSkKICAgICAgICAgICAgcmV2ZXJ0IEluc3VmZmljaWVudEJhbGFuY2UoewogICAgICAgICAgICAgICAgcmVxdWVzdGVkOiBhbW91bnQsCiAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGJhbGFuY2VzW21zZy5zZW5kZXJdCiAgICAgICAgICAgIH0pOwoKICAgICAgICBiYWxhbmNlc1ttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXNbcmVjZWl2ZXJdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFNlbnQobXNnLnNlbmRlciwgcmVjZWl2ZXIsIGFtb3VudCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Coin</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 关键字 &quot;public&quot; 使变量可以从其他合约中访问。</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">minter</span><span class="p">;</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>balances<span class="p">;</span>

<span class="w">    </span><span class="c1">// 事件允许客户端对您声明的特定合约变化做出反应</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Sent</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">from</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 构造函数代码只有在合约创建时运行</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>minter<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 向一个地址发送一定数量的新创建的代币</span>
<span class="w">    </span><span class="c1">// 但只能由合约创建者调用</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">mint</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">receiver</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>minter<span class="p">);</span>
<span class="w">        </span>balances<span class="p">[</span>receiver<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 错误类型变量允许您提供关于操作失败原因的信息。</span>
<span class="w">    </span><span class="c1">// 它们会返回给函数的调用者。</span>
<span class="w">    </span>error<span class="w"> </span>InsufficientBalance<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">requested</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">available</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 从任何调用者那里发送一定数量的代币到一个地址</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">send</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">receiver</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>amount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">])</span>
<span class="w">            </span>revert<span class="w"> </span>InsufficientBalance<span class="p">({</span>
<span class="w">                </span>requested<span class="o">:</span><span class="w"> </span>amount<span class="p">,</span>
<span class="w">                </span>available<span class="o">:</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span>
<span class="w">            </span><span class="p">});</span>

<span class="w">        </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>balances<span class="p">[</span>receiver<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>emit<span class="w"> </span>Sent<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>receiver<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个合约引入了一些新的概念，让我们逐一解读。</p>
<p><code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">public</span> <span class="pre">minter;</span></code> 这一行声明了一个可以被公开访问的 <a class="reference internal" href="index.html#address"><span class="std std-ref">address</span></a> 类型的状态变量。
<code class="docutils literal notranslate"><span class="pre">address</span></code> 类型是一个160位的值，且不允许任何算数操作。
这种类型适合存储合约地址或 <a class="reference internal" href="#accounts"><span class="std std-ref">外部账户</span></a> 的密钥对。</p>
<p>关键字 <code class="docutils literal notranslate"><span class="pre">public</span></code> 自动生成一个函数，允许您在这个合约之外访问这个状态变量的当前值。
如果没有这个关键字，其他的合约没有办法访问这个变量。
由编译器生成的函数的代码大致如下所示（暂时忽略 <code class="docutils literal notranslate"><span class="pre">external</span></code> 和 <code class="docutils literal notranslate"><span class="pre">view</span></code>）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gbWludGVyKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzKSB7IHJldHVybiBtaW50ZXI7IH0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">minter</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>minter<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>您可以自己添加一个类似上述的函数，但您会有同名的一个函数和一个变量。
您不需要这样做，编译器会帮您解决这个问题。</p>
<p id="index-1">下一行， <code class="docutils literal notranslate"><span class="pre">mapping</span> <span class="pre">(address</span> <span class="pre">=&gt;</span> <span class="pre">uint)</span> <span class="pre">public</span> <span class="pre">balances;</span></code> 也创建了一个公共状态变量，
但它是一个更复杂的数据类型。
<a class="reference internal" href="index.html#mapping-types"><span class="std std-ref">映射</span></a> 类型将地址映射到 <a class="reference internal" href="index.html#integers"><span class="std std-ref">无符号整数</span></a>。</p>
<p>映射可以被看作是 <a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>，
它实际上是被初始化的，因此每一个可能的键从一开始就存在，并被映射到一个值，其字节表示为全零的值。
然而，它既不可能获得一个映射的所有键的列表，也不可能获得所有值的列表。
因此，要么记住您添加到映射中的内容，要么在不需要的情况下使用它。
甚至更好的是，保留一个列表，或者使用一个更合适的数据类型。</p>
<p>而由 <code class="docutils literal notranslate"><span class="pre">public</span></code> 关键字创建的 <a class="reference internal" href="index.html#getter-functions"><span class="std std-ref">getter 函数</span></a> 则是更复杂一些的情况，
它大致如下所示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gYmFsYW5jZXMoYWRkcmVzcyBhY2NvdW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgIHJldHVybiBiYWxhbmNlc1thY2NvdW50XTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">balances</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">account</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>balances<span class="p">[</span>account<span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您可以用这个函数来查询单个账户的余额。</p>
<p id="index-2">这一行 <code class="docutils literal notranslate"><span class="pre">event</span> <span class="pre">Sent(address</span> <span class="pre">from,</span> <span class="pre">address</span> <span class="pre">to,</span> <span class="pre">uint</span> <span class="pre">amount);</span></code> 声明了一个 <a class="reference internal" href="index.html#events"><span class="std std-ref">&quot;事件&quot;</span></a>，
它是在函数 <code class="docutils literal notranslate"><span class="pre">send</span></code> 的最后一行发出的。以太坊客户端，如网络应用，可以监听区块链上发出的这些事件，而不需要太多的成本。
一旦发出，监听器就会收到参数 <code class="docutils literal notranslate"><span class="pre">from</span></code>， <code class="docutils literal notranslate"><span class="pre">to</span></code> 和 <code class="docutils literal notranslate"><span class="pre">amount</span></code>，这使得跟踪交易成为可能。</p>
<p>为了监听这个事件，您可以使用以下方法 JavaScript代码，
使用 <a class="reference external" href="https://github.com/ethereum/web3.js/">web3.js</a> 来创建 <code class="docutils literal notranslate"><span class="pre">Coin</span></code> 合约对象，
然后在任何用户界面调用上面自动生成的 <code class="docutils literal notranslate"><span class="pre">balances</span></code> 函数：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">Coin</span><span class="p">.</span><span class="nx">Sent</span><span class="p">().</span><span class="nx">watch</span><span class="p">({},</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Coin transfer: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">amount</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot; coins were sent from &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="kr">from</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot; to &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">to</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Balances now:\n&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;Sender: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">Coin</span><span class="p">.</span><span class="nx">balances</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="kr">from</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="s2">&quot;Receiver: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">Coin</span><span class="p">.</span><span class="nx">balances</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">to</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
<p id="index-3"><a class="reference internal" href="index.html#constructor"><span class="std std-ref">constructor</span></a> 是一个特殊的函数，只在创建合约的过程中执行，事后不能再被调用。
在这种情况下，它永久地存储了创建合约的人的地址。
<code class="docutils literal notranslate"><span class="pre">msg</span></code> 变量（与 <code class="docutils literal notranslate"><span class="pre">tx</span></code> 和 <code class="docutils literal notranslate"><span class="pre">block</span></code> 一起）是一个 <a class="reference internal" href="index.html#special-variables-functions"><span class="std std-ref">特殊全局变量</span></a>，
其中包含允许访问区块链的属性。 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 总是当前（外部）函数调用的地址。</p>
<p>最后，真正被用户或其他合约所调用的，以完成本合约功能的方法是 <code class="docutils literal notranslate"><span class="pre">mint</span></code> 和 <code class="docutils literal notranslate"><span class="pre">send</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">mint</span></code> 函数发送一定数量的新创建的代币到另一个地址。
<a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">require</span></a> 函数调用定义了一些条件，如果不满足这些条件就会恢复所有的变化。
在这个例子中， <code class="docutils literal notranslate"><span class="pre">require(msg.sender</span> <span class="pre">==</span> <span class="pre">minter);</span></code> 确保只有合约的创建者可以调用 <code class="docutils literal notranslate"><span class="pre">mint</span></code>。
一般来说，创建者可以随心所欲地铸造代币，但在某些时候，这将导致一种叫做 &quot;溢出&quot; 的现象。
请注意，由于默认的 <a class="reference internal" href="index.html#unchecked"><span class="std std-ref">检查过的算术</span></a>，如果表达式 <code class="docutils literal notranslate"><span class="pre">balances[receiver]</span> <span class="pre">+=</span> <span class="pre">amount;</span></code> 溢出，
即当任意精度算术中的 <code class="docutils literal notranslate"><span class="pre">balances[receiver]</span> <span class="pre">+</span> <span class="pre">amount</span></code> 大于 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 的最大值（ <code class="docutils literal notranslate"><span class="pre">2**256</span> <span class="pre">-</span> <span class="pre">1</span></code>）时，
交易将被恢复。对于函数 <code class="docutils literal notranslate"><span class="pre">send</span></code> 中的语句 <code class="docutils literal notranslate"><span class="pre">balances[receiver]</span> <span class="pre">+=</span> <span class="pre">amount;</span></code> 也是如此。</p>
<p><a class="reference internal" href="index.html#errors"><span class="std std-ref">错误（Errors）</span></a> 允许您向调用者提供更多关于一个条件或操作失败原因的信息。
错误与 <a class="reference internal" href="index.html#revert-statement"><span class="std std-ref">恢复状态</span></a> 一起使用。 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 语句无条件地中止和恢复所有的变化，
类似于 <code class="docutils literal notranslate"><span class="pre">require</span></code> 函数，但它也允许您提供错误的名称和额外的数据，
这些数据将提供给调用者（并最终提供给前端应用程序或区块资源管理器），以便更容易调试失败或做出反应。</p>
<p>任何人（已经拥有一些这样的代币）都可以使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 函数来发送代币给其他任何人。
如果发送者没有足够的代币可以发送， 那么 <code class="docutils literal notranslate"><span class="pre">if</span></code> 条件就会为真。
因此， <code class="docutils literal notranslate"><span class="pre">revert</span></code> 将导致操作失败，同时使用 <code class="docutils literal notranslate"><span class="pre">InsufficientBalance</span></code> 错误向发送者提供错误细节。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您用这个合约向一个地址发送代币，当您在区块链浏览器上查看该地址时，
您不会看到任何东西，因为您发送代币的记录和变化的余额只存储在这个特定的代币合约的数据存储中。
通过使用事件，您可以创建一个 &quot;区块链浏览器&quot;，跟踪您的新币的交易和余额，
但您必须检查币合约地址，而不是币主的地址。</p>
</div>
</section>
</section>
<section id="blockchain-basics">
<span id="id5"></span><h3>区块链基础<a class="headerlink" href="#blockchain-basics" title="此标题的永久链接"></a></h3>
<p>对于程序员来说，区块链这个概念并不难理解，这是因为大多数难懂的东西
（挖矿, <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">哈希</a> ，
<a class="reference external" href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">椭圆曲线密码学</a>，
<a class="reference external" href="https://en.wikipedia.org/wiki/Peer-to-peer">点对点网络（P2P）</a> 等）
都只是用于提供特定的功能和承诺。
您只需接受这些既有的特性功能，不必关心底层技术，
比如，难道您必须知道亚马逊的 AWS 内部原理，您才能使用它吗？</p>
<section id="index-4">
<span id="id8"></span><h4>交易/事务<a class="headerlink" href="#index-4" title="此标题的永久链接"></a></h4>
<p>区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。
如果您想改变数据库中的某些东西，您必须创建一个被所有其他人所接受的事务。
事务一词意味着您想做的（假设您想要同时更改两个值），要么一点没做，要么全部完成。
此外，当您的事务被应用到数据库时，其他事务不能修改数据库。</p>
<p>举个例子，设想一张表，列出电子货币中所有账户的余额。
如果请求从一个账户转移到另一个账户，
数据库的事务特性确保了如果从一个账户扣除金额，它总被添加到另一个账户。
如果由于某些原因，无法添加金额到目标账户时，源账户也不会发生任何变化。</p>
<p>此外，交易总是由发送人（创建者）签名。
这样，就可非常简单地为数据库的特定修改增加访问保护机制。
在电子货币的例子中，一个简单的检查可以确保只有持有账户密钥的人才能从中转账。</p>
</section>
<section id="index-5">
<span id="id9"></span><h4>区块<a class="headerlink" href="#index-5" title="此标题的永久链接"></a></h4>
<p>要克服的一个主要障碍是（用比特币的术语）所谓的 “双花攻击 (double-spend attack)”：
如果网络中存在两个交易，都想清空一个账户，会发生什么？
只有其中一个交易是有效的，通常是最先被接受的那个。
问题是，在点对点的网络中，&quot;第一&quot; 不是一个客观的术语。</p>
<p>对此，抽象的答案是，您不必在意。一个全球公认的交易顺序将为您选择，
解决这样的冲突。这些交易将被捆绑成所谓的 &quot;区块&quot;，
然后它们将在所有参与节点中执行和分发。
如果两个交易相互矛盾，最终排在第二位的那个交易将被拒绝，不会成为区块的一部分。</p>
<p>这些块按时间形成了一个线性序列，这正是“区块链”这个词的来源。
区块以一定的时间间隔添加到链上 — 对于以太坊，这间隔大约是17秒。</p>
<p>作为 “顺序选择机制”（也就是所谓的“挖矿”）的一部分，
可能有时会发生块（blocks）被回滚的情况，但仅在链的“末端”。
末端增加的块越多，其发生回滚的概率越小。
因此您的交易被回滚甚至从区块链中抹除，这是可能的，
但等待的时间越长，这种情况发生的概率就越小。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>交易不保证被包括在下一个区块或任何特定的未来区块中，
因为这不是由交易的提交者决定的，而是由矿工来决定交易被包括在哪个区块中。</p>
<p>如果您想安排您的合约的未来调用，您可以使用智能合约自动化工具或oracle服务。</p>
</div>
<span class="target" id="the-ethereum-virtual-machine"></span></section>
</section>
<section id="index-6">
<span id="id10"></span><h3>以太坊虚拟机<a class="headerlink" href="#index-6" title="此标题的永久链接"></a></h3>
<section id="id11">
<h4>概述<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>以太坊虚拟机或EVM是以太坊智能合约的运行环境。
它不仅是沙盒封装的，而且实际上是完全隔离的，
这意味着在EVM内运行的代码不能访问网络，文件系统或其他进程。
甚至智能合约之间的访问也是受限的。</p>
</section>
<section id="accounts">
<span id="index-7"></span><span id="id12"></span><h4>账户<a class="headerlink" href="#accounts" title="此标题的永久链接"></a></h4>
<p>在以太坊有两种共享同一地址空间的账户：
<strong>外部账户</strong>，由公钥-私钥对（也就是人）控制；
<strong>合约账户</strong>，由与账户一起存储的代码控制。</p>
<p>外部账户的地址是由公钥确定的，
而合约的地址是在合约创建时确定的
（它是由创建者地址和从该地址发出的交易数量得出的，即所谓的 &quot;nonce&quot;）。</p>
<p>无论账户是否存储代码，这两种类型都被EVM平等对待。</p>
<p>每个账户都有一个持久的键值存储，将256位的字映射到256位的字，称为 <strong>存储</strong>。</p>
<p>此外，每个账户有一个以太 <strong>余额</strong> （ balance ）（单位是“Wei”， <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">ether</span></code> 是 <code class="docutils literal notranslate"><span class="pre">10**18</span> <span class="pre">wei</span></code>），
余额会因为发送包含以太币的交易而改变。</p>
</section>
<section id="index-8">
<span id="id13"></span><h4>交易<a class="headerlink" href="#index-8" title="此标题的永久链接"></a></h4>
<p>交易可以看作是从一个帐户发送到另一个帐户的消息
（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。
它能包含一个二进制数据（被称为“合约负载”）和以太。</p>
<p>如果目标账户含有代码，此代码会被执行，并以合约负载（二进制数据） 作为入参。</p>
<p>如果目标账户没有设置（交易没有接收者或接收者被设置为 <code class="docutils literal notranslate"><span class="pre">null</span></code>），
交易会创建一个 <strong>新合约</strong>。
正如已经提到的，该合约的地址不是零地址，
而是从发送者和其发送的交易数量（“nonce”）中得出的地址。
这种合约创建交易的有效负载被认为是EVM字节码并被执行。
该执行的输出数据被永久地存储为合约的代码。
这意味着，为创建一个合约，您不需要发送实际的合约代码，而是发送能够产生合约代码的代码。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在合约创建的过程中，它的代码还是空的。
所以直到构造函数执行结束，您都不应该在其中调用合约自己函数。</p>
</div>
</section>
<section id="gas">
<span id="index-9"></span><h4>Gas<a class="headerlink" href="#gas" title="此标题的永久链接"></a></h4>
<p>一经创建，每笔交易都会被收取一定数量的 <strong>gas</strong>，
这些 gas 必须由交易的发起人 （ <code class="docutils literal notranslate"><span class="pre">tx.origin</span></code>）支付。
在 EVM 执行交易时，gas 根据特定规则逐渐耗尽。
如果 gas 在某一点被用完（即它会为负），
将触发一个 gas 耗尽异常，
这将结束执行并撤销当前调用栈中对状态所做的所有修改。</p>
<p>此机制激励了对 EVM 执行时间的经济利用，
并为 EVM 执行器（即矿工/持币者）的工作提供补偿。
由于每个区块都有最大 gas 量，因此还限制了验证块所需的工作量。</p>
<p><strong>gas price</strong> 是交易发起人设定的值，
他必须提前向 EVM 执行器支付 <code class="docutils literal notranslate"><span class="pre">gas_price</span> <span class="pre">*</span> <span class="pre">gas</span></code>。
如果执行后还剩下一些 gas，则退还给交易发起人。
如果发生撤销更改的异常，已经使用的 gas 不会退还。</p>
<p>由于 EVM 执行器可以选择包含一笔交易，
因此交易发送者无法通过设置低 gas 价格滥用系统。</p>
</section>
<section id="index-10">
<span id="id14"></span><h4>存储，内存和栈<a class="headerlink" href="#index-10" title="此标题的永久链接"></a></h4>
<p>以太坊虚拟机有三个存储数据的区域：存储器，内存和堆栈。</p>
<p>每个账户都有一个称为 <strong>存储</strong> 的数据区，在函数调用和交易之间是持久的。
存储是一个键值存储，将256位的字映射到256位的字。
在合约中枚举存储是不可能的，读取的成本相对较高，初始化和修改存储的成本更高。
由于这种成本，您应该把您存储在持久性存储中的内容减少到合约运行所需的程度。
在合约之外存储像派生计算，缓存和聚合的数据。合约既不能读也不能写到除其自身以外的任何存储。</p>
<p>第二个数据区被称为 <strong>内存</strong>，合约在每次消息调用时都会获得一个新清除的实例。
内存是线性的，可以在字节级寻址，但读的宽度限制在256位，
而写的宽度可以是8位或256位。当访问（无论是读还是写）一个先前未触及的内存字（即一个字内的任何偏移）时，
内存被扩展一个字（256位）。在扩展的时候，必须支付gas成本。
内存越大，成本就越高（它以平方级别扩展）。</p>
<p>EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 <strong>栈（stack）</strong> 的区域执行。
栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：
允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。
所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，
运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。
但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p>
</section>
<section id="index-11">
<span id="id15"></span><h4>指令集<a class="headerlink" href="#index-11" title="此标题的永久链接"></a></h4>
<p>EVM的指令集应尽量保持最小，以避免不正确或不一致的实现，这可能导致共识问题。
所有的指令都是在基本的数据类型上操作的，256位的字或内存的片断（或其他字节数组）。
具备常用的算术，位，逻辑和比较操作。也可以做到有条件和无条件跳转。
此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p>
<p>关于完整的列表，请参见 <a class="reference internal" href="index.html#opcodes"><span class="std std-ref">操作码列表</span></a>，它是内联汇编文档的一部分。</p>
</section>
<section id="index-12">
<span id="id16"></span><h4>消息调用<a class="headerlink" href="#index-12" title="此标题的永久链接"></a></h4>
<p>合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户。
消息调用和交易非常类似，它们都有一个源，目标，数据，以太币，gas和返回数据。
事实上每个交易都由一个顶层消息调用组成，这个消息调用又可创建更多的消息调用。</p>
<p>合约可以决定它剩余的 <strong>gas</strong> 有多少应该随内部消息调用一起发送，有多少它想保留。
如果在内部调用中发生了out-of-gas的异常（或任何其他异常），这将由一个被压入栈顶的错误值来表示。
在这种情况下，只有与调用一起发送的gas被用完。
在Solidity中，在这种情况下，发起调用的合约默认会引起一个手动异常，
所以异常会在调用栈上 &quot;冒泡出来&quot;。</p>
<p>如前文所述，被调用的合约（可以与调用者是同一个合约）将收到一个新清空的内存实例，
并可以访问调用的有效负载-由被称为 <strong>calldata</strong> 的独立区域所提供的数据。
在它执行完毕后，它可以返回数据，这些数据将被存储在调用者内存中由调用者预先分配的位置。
所有这样的调用都是完全同步的。</p>
<p>调用被 <strong>限制</strong> 在1024的深度，这意味着对于更复杂的操作，循环应优先于递归调用。
此外，在一个消息调用中，只有63/64的gas可以被转发，这导致在实践中，深度限制略低于1000。</p>
</section>
<section id="index-13">
<span id="id17"></span><h4>委托调用和库<a class="headerlink" href="#index-13" title="此标题的永久链接"></a></h4>
<p>存在一种特殊的消息调用，被称为 <strong>委托调用（delegatecall）</strong>，
除了目标地址的代码是在调用合约的上下文（即地址）中执行，
<code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 的值不会更改之外，其他与消息调用相同。</p>
<p>这意味着合约可以在运行时动态地从不同的地址加载代码。
存储，当前地址和余额仍然指的是调用合约，只是代码取自被调用的地址。</p>
<p>这使得在Solidity中实现 “库” 的功能成为可能：
可重复使用的库代码，可以放在一个合约的存储上，例如，用来实现复杂的数据结构的库。</p>
</section>
<section id="index-14">
<span id="id18"></span><h4>日志<a class="headerlink" href="#index-14" title="此标题的永久链接"></a></h4>
<p>有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。
这个特性被称为 <strong>日志（logs）</strong> ，Solidity用它来实现 <a class="reference internal" href="index.html#events"><span class="std std-ref">事件</span></a>。
合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。
因为部分日志数据被存储在 <a class="reference external" href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器（bloom filter）</a> 中，
我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。</p>
</section>
<section id="index-15">
<span id="id19"></span><h4>创建<a class="headerlink" href="#index-15" title="此标题的永久链接"></a></h4>
<p>合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）。
创建合约的调用 <strong>create calls</strong> 和普通消息调用的唯一区别在于，负载会被执行，
执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址。</p>
</section>
<section id="index-16">
<span id="id20"></span><h4>停用和自毁<a class="headerlink" href="#index-16" title="此标题的永久链接"></a></h4>
<p>从区块链上删除代码的唯一方法是当该地址的合约执行 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 操作。
存储在该地址的剩余以太币被发送到一个指定的目标，然后存储和代码被从状态中删除。
删除合约在理论上听起来是个好主意，但它有潜在的危险性，
因为如果有人向被删除的合约发送以太币，以太币就会永远丢失。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>即使一个合约被 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 删除，它仍然是区块链历史的一部分，
可能被大多数以太坊节点保留。
因此，使用 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 与从硬盘上删除数据不一样。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>尽管一个合约的代码中没有显式地调用 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> ，
它仍然有可能通过 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 或  <code class="docutils literal notranslate"><span class="pre">callcode</span></code> 执行自毁操作。</p>
</div>
<p>如果您想停用您的合约，您可以通过改变一些内部状态来 <strong>停用</strong> 它们，
从而使再次调用所有的功能都会被恢复。这样就无法使用合约了，因为它立即返回以太。</p>
</section>
<section id="precompiledcontracts">
<span id="index-17"></span><span id="id21"></span><h4>预编译合约<a class="headerlink" href="#precompiledcontracts" title="此标题的永久链接"></a></h4>
<p>有一小群合约地址是特殊的。 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和（包括） <code class="docutils literal notranslate"><span class="pre">8</span></code> 之间的地址范围包含 “预编译合约“，
可以像其他合约一样被调用，但它们的行为（和它们的gas消耗）
不是由存储在该地址的EVM代码定义的（它们不包含代码），
而是由EVM执行环境本身实现。</p>
<p>不同的EVM兼容链可能使用不同的预编译合约集。
未来也有可能在以太坊主链上添加新的预编译合约，
但您可以合理地预期它们总是在 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">0xffff</span></code> （包括）之间。</p>
</section>
</section>
</section>
<span id="document-installing-solidity"></span><section id="solidity">
<span id="installing-solidity"></span><span id="index-0"></span><h2>安装 Solidity 编译器<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h2>
<section id="id1">
<h3>版本<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h3>
<p>Solidity 的版本遵循 <a class="reference external" href="https://semver.org">语义化版本原则</a>。此外，
主版本（例如：0.x.y）的补丁级版本的发布不会包含重大更改。这意味着用 0.x.y 版本
编译的代码可望用 0.x.z 版本编译，其中 z &gt; y。</p>
<p>除了发行版本外，我们还提供 <strong>每日开发构建版本 （nightly development builds）</strong> ，
目的是使开发人员能够轻松地试用即将推出的功能并提供早期反馈。然而，请注意，
虽然每日开发构建版本通常是很稳定的，但它们包含了来自开发分支的前沿代码，
并不保证总是有效的。尽管我们尽了最大努力，
它们仍可能含有未记录的或重大的修改，这些修改不会成为实际发布版本的一部分。
它们也不会用于生产。</p>
<p>当开发智能合约时，您应该使用最新版本的 Solidity。这是因为重大的改变，
以及新的特性和错误修复是定期引入的。
我们目前使用 0.x 版本号 <a class="reference external" href="https://semver.org/#spec-item-4">来表示这种快速的变化的</a>。</p>
</section>
<section id="remix">
<h3>Remix<a class="headerlink" href="#remix" title="此标题的永久链接"></a></h3>
<p><em>我们推荐使用 Remix 来开发简单合约和快速学习 Solidity。</em></p>
<p><a class="reference external" href="https://remix.ethereum.org/">Remix 可以在线使用</a>，而无需安装任何东西。
如果您想离线使用，可按 <a class="reference external" href="https://github.com/ethereum/remix-live/tree/gh-pages">https://github.com/ethereum/remix-live/tree/gh-pages</a>
的页面说明下载 <code class="docutils literal notranslate"><span class="pre">.zip</span></code> 文件来使用。 Remix 也是一个方便的选择，
可以在不安装多个 Solidity 版本的情况下测试每日开发构建版本。</p>
<p>本页的进一步选项详细说明了在您的计算机上安装 Solidity 命令行编译器。
如果您刚好要处理大型合约，或者需要更多的编译选项，
那么您应该选择使用一个命令行编译器。</p>
</section>
<section id="npm-node-js">
<span id="solcjs"></span><h3>npm / Node.js<a class="headerlink" href="#npm-node-js" title="此标题的永久链接"></a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">npm</span></code> 可以便捷地安装 <code class="docutils literal notranslate"><span class="pre">solcjs</span></code> ，它一个 Solidity 编译器。
但该 <cite>solcjs</cite> 程序的功能比本页下面描述的访问编译器的方法要少。
在 <a class="reference internal" href="index.html#commandline-compiler"><span class="std std-ref">使用命令行编译器</span></a> 一章中，我们假定您使用的是全功能的编译器: <code class="docutils literal notranslate"><span class="pre">solc</span></code>。
<code class="docutils literal notranslate"><span class="pre">solcjs</span></code> 的用法在它自己的 <a class="reference external" href="https://github.com/ethereum/solc-js">代码仓库</a> 中记录。</p>
<p>注意: <cite>solc-js</cite> 项目是通过使用 Emscripten 从 C++ 版的 <cite>solc</cite> 衍生出来的，
这意味着两者使用相同的编译器源代码。
因此， <cite>solc-js</cite> 可以直接用于JavaScript项目（如 Remix） 具体介绍请参考 <cite>solc-js</cite> 代码库。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>npm<span class="w"> </span>install<span class="w"> </span>-g<span class="w"> </span>solc
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在命令行中，可执行文件被命名为 <code class="docutils literal notranslate"><span class="pre">solcjs</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">solcjs</span></code> 的命令行选项与 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 和一些工具（如 <code class="docutils literal notranslate"><span class="pre">geth</span></code>）是不兼容的，
因此不要期望 <code class="docutils literal notranslate"><span class="pre">solcjs</span></code> 能像 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 一样工作。</p>
</div>
</section>
<section id="docker">
<h3>Docker<a class="headerlink" href="#docker" title="此标题的永久链接"></a></h3>
<p>Solidity构建的Docker镜像可以使用从 <code class="docutils literal notranslate"><span class="pre">ethereum</span></code> 组织获得的 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 镜像。
使用 <code class="docutils literal notranslate"><span class="pre">stable</span></code> 标签获取最新发布的版本，使用 <code class="docutils literal notranslate"><span class="pre">nightly</span></code> 标签获取开发分支中潜在的不稳定变更的版本。</p>
<p>Docker镜像会运行编译器可执行文件，所以您可以把所有的编译器参数传给它。
例如，下面的命令提取了稳定版的 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 镜像（如果您还没有），
并在一个新的容器中运行它，同时传递 <code class="docutils literal notranslate"><span class="pre">--help</span></code> 参数。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>ethereum/solc:stable<span class="w"> </span>--help
</pre></div>
</div>
<p>您也可以在标签中指定发行的版本，例如，0.5.4版本。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>ethereum/solc:0.5.4<span class="w"> </span>--help
</pre></div>
</div>
<p>要使用 Docker 镜像来编译主机上的 Solidity 文件，请安装一个本地文件夹
用于输入和输出，并指定要编译的合约。例如：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>-v<span class="w"> </span>/local/path:/sources<span class="w"> </span>ethereum/solc:stable<span class="w"> </span>-o<span class="w"> </span>/sources/output<span class="w"> </span>--abi<span class="w"> </span>--bin<span class="w"> </span>/sources/Contract.sol
</pre></div>
</div>
<p>您也可以使用标准的JSON接口（当使用工具化的编译器时建议使用这种方式）。
当使用这个接口时，不需要装载任何目录，只要输入的 JSON 是自成一体的
（即它没有引用任何外部文件，而这些文件必须要被
<a class="reference internal" href="index.html#initial-vfs-content-standard-json-with-import-callback"><span class="std std-ref">由导入回调</span></a>)。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>ethereum/solc:stable<span class="w"> </span>--standard-json<span class="w"> </span>&lt;<span class="w"> </span>input.json<span class="w"> </span>&gt;<span class="w"> </span>output.json
</pre></div>
</div>
</section>
<section id="linux">
<h3>Linux 包<a class="headerlink" href="#linux" title="此标题的永久链接"></a></h3>
<p>Solidity 的二进制安装包可在 <a class="reference external" href="https://github.com/ethereum/solidity/releases">solidity/releases</a> 找到。</p>
<p>对于 Ubuntu ，我们也提供 PPAs 。通过以下命令，可获取最新的稳定版本：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>add-apt-repository<span class="w"> </span>ppa:ethereum/ethereum
sudo<span class="w"> </span>apt-get<span class="w"> </span>update
sudo<span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>solc
</pre></div>
</div>
<p>您也可以使用以下命令安装每日开发构建版本：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>add-apt-repository<span class="w"> </span>ppa:ethereum/ethereum
sudo<span class="w"> </span>add-apt-repository<span class="w"> </span>ppa:ethereum/ethereum-dev
sudo<span class="w"> </span>apt-get<span class="w"> </span>update
sudo<span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>solc
</pre></div>
</div>
<p>此外，一些 Linux 发行版提供了他们自己的软件包。这些软件包不是由我们直接维护的，
而通常由各自的软件包维护者保持最新。</p>
<p>例如，Arch Linux 也有最新开发版本的软件包。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pacman<span class="w"> </span>-S<span class="w"> </span>solidity
</pre></div>
</div>
<p>还有一个 <a class="reference external" href="https://snapcraft.io/solc">snap包</a>，然而，它 <strong>目前没有维护</strong> 。
它可以安装在所有 <a class="reference external" href="https://snapcraft.io/docs/core/install">支持的Linux发行版</a> 。通过以下命令，
安装最新的稳定版本的 solc：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>snap<span class="w"> </span>install<span class="w"> </span>solc
</pre></div>
</div>
<p>如果您想测试 develop 分支下的最新变更，请使用以下方式：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>snap<span class="w"> </span>install<span class="w"> </span>solc<span class="w"> </span>--edge
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">solc</span></code> snap 使用严格的限制。这对 snap 包来说是最安全的模式
但它也有一些限制，比如只能访问 <code class="docutils literal notranslate"><span class="pre">/home</span></code> 和 <code class="docutils literal notranslate"><span class="pre">/media</span></code> 目录下的文件。
欲了解更多信息，请访问 <a class="reference external" href="https://snapcraft.io/blog/demystifying-snap-confinement">Demystifying Snap Confinement</a>。</p>
</div>
</section>
<section id="macos-packages">
<h3>macOS Packages<a class="headerlink" href="#macos-packages" title="此标题的永久链接"></a></h3>
<p>我们通过 Homebrew 作为从源头建立的版本, 发布 Solidity 编译器，。目前不支持预构建。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>brew<span class="w"> </span>update
brew<span class="w"> </span>upgrade
brew<span class="w"> </span>tap<span class="w"> </span>ethereum/ethereum
brew<span class="w"> </span>install<span class="w"> </span>solidity
</pre></div>
</div>
<p>要安装最新的 0.4.x/0.5.x 版本的 Solidity，您也可以分别使用 <code class="docutils literal notranslate"><span class="pre">brew</span> <span class="pre">install</span> <span class="pre">solidity&#64;4</span></code>
和 <code class="docutils literal notranslate"><span class="pre">brew</span> <span class="pre">install</span> <span class="pre">solidity&#64;5</span></code>。</p>
<p>如果您需要特定版本的 Solidity，您可以直接从 Github 上安装一个 Homebrew 列表。</p>
<p>参见
<a class="reference external" href="https://github.com/ethereum/homebrew-ethereum/commits/master/solidity.rb">solidity.rb 在 Github 上的提交情况</a>.</p>
<p>复制您想要的版本的提交哈希值，然后在您的机器上检出该分支。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ethereum/homebrew-ethereum.git
<span class="nb">cd</span><span class="w"> </span>homebrew-ethereum
git<span class="w"> </span>checkout<span class="w"> </span>&lt;your-hash-goes-here&gt;
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">brew</span></code> 安装:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>brew<span class="w"> </span>unlink<span class="w"> </span>solidity
<span class="c1"># 例如，安装 0.4.8</span>
brew<span class="w"> </span>install<span class="w"> </span>solidity.rb
</pre></div>
</div>
</section>
<section id="id7">
<h3>静态二进制文件<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<p>我们在 <a class="reference external" href="https://github.com/ethereum/solc-bin/">solc-bin</a> 上维护了一个包含过去和现在编译器版本的静态构建的资源库，用于所有支持的平台。
您也可以找到每日开发构建版本。</p>
<p>该资源库不仅是一个快速且简单的方法，让终端用户获得可以开箱即用的二进制文件，
而且它对第三方工具也很友好：</p>
<ul class="simple">
<li><p>这些内容被镜像到 <a class="reference external" href="https://binaries.soliditylang.org">https://binaries.soliditylang.org</a>，在那里可以很容易地通过 HTTPS 下载，
没有任何认证、速率或需要使用git的限制。</p></li>
<li><p>提供的内容具有正确的 <cite>Content-Type</cite> 请求头和宽松的 CORS 配置，
因此它可以被运行在浏览器中的工具直接加载。</p></li>
<li><p>二进制文件不需要安装或解包（与必要的 DLLs 捆绑在一起的旧版 Windows 除外）。</p></li>
<li><p>我们努力争取高水平的向后兼容性。文件一旦被添加，在没有提供旧位置的链接/重定向的情况下，不会被删除或移动。
它们也不会被修改，而且应始终与原始校验相匹配。唯一的例外是破损或无法使用的文件，
如果保持原样，有可能造成更大的伤害。</p></li>
<li><p>文件是通过 HTTP 和 HTTPS 提供的。只要您以安全的方式获得文件列表
（通过 git、HTTPS、IPFS 或者只是在本地的缓存），并在下载后验证二进制文件的哈希值，
您就不必通过HTTPS获得二进制文件。</p></li>
</ul>
<p>在大多数情况下，同样的二进制文件可以在 <a class="reference external" href="https://github.com/ethereum/solidity/releases">Github 上的 Solidity 发布页</a> 中找到。
不同的是，我们一般不更新Github已发布的旧版本。这意味着如果命名规则改变，我们不会重新命名，
也不会为发布时不支持的平台添加构建。这只发生在 <code class="docutils literal notranslate"><span class="pre">solc-bin</span></code> 资源库里。</p>
<p><code class="docutils literal notranslate"><span class="pre">solc-bin</span></code> 资源库包含几个顶级目录，每个目录代表一个平台。
每个目录都包含一个 <code class="docutils literal notranslate"><span class="pre">list.json</span></code> 文件，列出可用的二进制文件。
例如，在 <code class="docutils literal notranslate"><span class="pre">emscripten-wasm32/list.json</span></code> 中您会发现以下关于 0.7.4 版本的信息。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.7.4&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;build&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;commit.3f05b770&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;longVersion&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.7.4+commit.3f05b770&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;keccak256&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;sha256&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;urls&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="s2">&quot;bzzr://16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;dweb:/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS&quot;</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这意味着：</p>
<ul class="simple">
<li><p>您可以在同一目录下找到二进制文件，名称为
<a class="reference external" href="https://github.com/ethereum/solc-bin/blob/gh-pages/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js">solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js</a>.
注意，该文件可能是一个软链接，如果您没有使用 git 下载，或者您的文件系统不支持软链接，您需要自己解决。</p></li>
<li><p>该二进制文件也被镜像在 <a class="reference external" href="https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js">https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js</a>.
在这种情况下，不需要 git，软链接的解决方式是显而易见的，要么提供一个文件的副本，要么返回一个 HTTP 重定向。</p></li>
<li><p>该文件也可在 IPFS上 找到，地址是 <a class="reference external" href="https://gateway.ipfs.io/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS">QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS</a>.</p></li>
<li><p>该文件将来可能会存储在 Swarm 上，
地址是 <a class="reference external" href="https://swarm-gateways.net/bzz:/16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1/">16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1</a>.</p></li>
<li><p>您可以通过比较其keccak256哈希值来验证二进制文件的完整性
<code class="docutils literal notranslate"><span class="pre">0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3</span></code>。哈希值可以在命令行上
使用 <a class="reference external" href="https://github.com/maandree/sha3sum">sha3sum</a> 提供的 <code class="docutils literal notranslate"><span class="pre">keccak256sum</span></code> 工具
或在 JavaScript 中使用 <cite>ethereumjs-util 的 keccak256() 函数。</cite></p></li>
<li><p>您也可以通过比较二进制文件的sha256哈希值来验证它的完整性
<code class="docutils literal notranslate"><span class="pre">0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2</span></code>。</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>由于高度的向后兼容性要求，版本库包含一些遗留元素，但您在编写新工具时应避免使用它们：</p>
<ul class="simple">
<li><p>如果您想获得最佳的性能，请使用 <code class="docutils literal notranslate"><span class="pre">emscripten-wasm32/</span></code> （有回退功能的 <code class="docutils literal notranslate"><span class="pre">emscripten-asmjs/</span></code>）而不是 <code class="docutils literal notranslate"><span class="pre">bin/</span></code>。
在 0.6.1 版本之前，我们只提供 asm.js 二进制文件。从 0.6.2 开始，我们改用 <a class="reference external" href="https://emscripten.org/docs/compiling/WebAssembly.html">WebAssembly builds</a>，性能好得多。
我们已经为wasm重建了旧版本，但原来的asm.js文件仍然在 <code class="docutils literal notranslate"><span class="pre">bin/</span></code> 下。
新的文件必须放在一个单独的目录中，以避免名称冲突。</p></li>
<li><p>如果您想确定下载的是 wasm 还是 asm.js 二进制文件，请使用 <code class="docutils literal notranslate"><span class="pre">emscripten-asmjs/</span></code> 和 <code class="docutils literal notranslate"><span class="pre">emscripten-wasm32/</span></code>
而不是 <code class="docutils literal notranslate"><span class="pre">bin/</span></code> 和 <code class="docutils literal notranslate"><span class="pre">wasm/</span></code> 目录。</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">list.json</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">list.js</span></code> 和 <code class="docutils literal notranslate"><span class="pre">list.txt</span></code>。JSON列表格式包含了旧列表的所有信息。</p></li>
<li><p>使用 <a class="reference external" href="https://binaries.soliditylang.org">https://binaries.soliditylang.org</a>，而不是 <a class="reference external" href="https://solc-bin.ethereum.org">https://solc-bin.ethereum.org</a>。
为了使事情简单化，我们把几乎所有与编译器有关的东西都移到了新的域名 <code class="docutils literal notranslate"><span class="pre">soliditylang.org</span></code> 下，
这也适用于 <code class="docutils literal notranslate"><span class="pre">solc-bin</span></code>。虽然推荐使用新的域名，但旧的域名仍然被完全支持，并保证指向同一位置。</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>二进制文件也可以在 <a class="reference external" href="https://ethereum.github.io/solc-bin/">https://ethereum.github.io/solc-bin/</a> 找到，
但这个页面在 0.7.2 版本发布后就停止了更新，不会收到任何平台的新版本或每日开发构建版本，
也不提供新的目录结构，包括非 emscripten 的构建。</p>
<p>如果您正在使用它，请切换到 <a class="reference external" href="https://binaries.soliditylang.org">https://binaries.soliditylang.org</a>，它是一个直接的替代。
这使我们能够以透明的方式对底层主机进行更改，并尽量减少干扰。
与我们无法控制的 <code class="docutils literal notranslate"><span class="pre">ethereum.github.io</span></code> 域名不同，
<code class="docutils literal notranslate"><span class="pre">binaries.soliditylang.org</span></code> 可以保证长期运行并保持相同的URL结构。</p>
</div>
</section>
<section id="building-from-source">
<span id="id8"></span><h3>从源代码编译<a class="headerlink" href="#building-from-source" title="此标题的永久链接"></a></h3>
<section id="id9">
<h4>先决条件 - 所有操作系统<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>以下是 Solidity 构建的所有依赖性：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>软件</p></th>
<th class="head"><p>备注</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://cmake.org/download/">CMake</a> (3.13以上版本)</p></td>
<td><p>跨平台构建文件生成器。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://www.boost.org">Boost</a> (Windows系统
3.13以上版本, 其他系统1.65+ )</p></td>
<td><p>C++ 库。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://git-scm.com/download">Git</a></p></td>
<td><p>用于获取源代码的命令行工具。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://github.com/Z3Prover/z3">z3</a> (4.8以上版本, 可选)</p></td>
<td><p>与SMT检查器一起使用。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://cvc4.cs.stanford.edu/web/">cvc4</a> (可选)</p></td>
<td><p>与SMT检查器一起使用。</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>0.5.10 之前的 Solidity 版本可能无法与 Boost 1.70 以上版本正确链接。
一个可能的解决方法是，在运行 cmake 命令配置 Solidity 之前，暂时重命名 <code class="docutils literal notranslate"><span class="pre">&lt;Boost</span> <span class="pre">install</span> <span class="pre">path&gt;/lib/cmake/Boost-1.70.0</span></code>。</p>
<p>从 0.5.10 开始，针对 Boost 1.70 以上版本的链接应该无需人工干预。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>默认的构建配置需要一个特定的 Z3 版本（在代码最后更新时的最新版本）。
Z3 版本之间的变化常常导致返回的结果略有不同（但仍然有效）。
我们的SMT测试没有考虑到这些差异，很可能会在不同的版本中失败，而不是为其编写的版本。
这并不意味着使用不同版本的构建是有问题的。如果将 <code class="docutils literal notranslate"><span class="pre">-DSTRICT_Z3_VERSION=OFF</span></code> 选项传递给CMake，
您可以使用任何满足上表要求的版本进行构建。
然而，如果您这样做，请记得在 <code class="docutils literal notranslate"><span class="pre">scripts/tests.sh</span></code> 中传递 <code class="docutils literal notranslate"><span class="pre">--no-smt</span></code> 选项以跳过SMT测试。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>默认情况下，编译是以 <em>语义模式</em> 进行的，这将启用额外的警告，并告诉编译器将所有警告视为错误。
这迫使开发人员在警告出现时进行修复，因此它们不会累积到“以后再修复”。
如果您只对创建发布版本感兴趣，不打算修改源代码来处理这些警告，
您可以向CMake传递 <code class="docutils literal notranslate"><span class="pre">-DPEDANTIC=OFF</span></code> 选项来禁用这种模式。
一般情况下不建议这样做，但在使用我们没有测试过的工具链或试图用较新的工具构建旧版本时，
可能需要这样做。
如果您遇到这种警告，请考虑 <a class="reference external" href="https://github.com/ethereum/solidity/issues/new">报告它们</a>。</p>
</div>
<section id="id11">
<h5>最小编译器版本<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h5>
<p>以下C++编译器及其最小版本可构建 Solidity 代码库：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://gcc.gnu.org">GCC</a>, 8以上版本</p></li>
<li><p><a class="reference external" href="https://clang.llvm.org/">Clang</a>, 7以上版本</p></li>
<li><p><a class="reference external" href="https://visualstudio.microsoft.com/vs/">MSVC</a>, 2019以上版本</p></li>
</ul>
</section>
</section>
<section id="macos">
<h4>先决条件 - macOS<a class="headerlink" href="#macos" title="此标题的永久链接"></a></h4>
<p>对于 macOS 的构建，确保最新版本的 <a class="reference external" href="https://developer.apple.com/xcode/download/">Xcode 已安装</a>。
这包含了 <a class="reference external" href="https://en.wikipedia.org/wiki/Clang">Clang C++ 编译器</a>，
<a class="reference external" href="https://en.wikipedia.org/wiki/Clang">Xcode IDE</a> 和其他苹果公司的开发工具，
这些工具是在 OS X 上构建 C++ 应用程序所必须的。
如果您是第一次安装 Xcode，或者刚刚安装了一个新的版本，那么您在使用命令行构建前，需同意使用协议：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>xcodebuild<span class="w"> </span>-license<span class="w"> </span>accept
</pre></div>
</div>
<p>我们的 OS X 构建脚本使用 <a class="reference external" href="https://brew.sh">the Homebrew</a>
软件包管理器来安装外部依赖。
如果您想从头开始的话，以下是如何 <a class="reference external" href="https://docs.brew.sh/FAQ#how-do-i-uninstall-homebrew">卸载Homebrew</a>。</p>
</section>
<section id="windows">
<h4>先决条件 - Windows<a class="headerlink" href="#windows" title="此标题的永久链接"></a></h4>
<p>您需要为 Solidity 的 Windows 版本安装以下依赖软件包:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 59%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Software</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019">Visual Studio 2019 Build Tools</a></p></td>
<td><p>C++ 编译器。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://www.visualstudio.com/vs/">Visual Studio 2019</a>  (可选)</p></td>
<td><p>C++ 编译器和开发环境。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://www.boost.org">Boost</a> (1.77版本以上)</p></td>
<td><p>C++ 库文件。</p></td>
</tr>
</tbody>
</table>
<p>如果您已经有一个 IDE 并且只需要编译器和库文件。您可以安装 Visual Studio 2019 构建工具。</p>
<p>Visual Studio 2019 同时提供IDE和必要的编译器和库。
所以，如果您没有一个 IDE，并且想要开发 Solidity，
那么 Visual Studio 2019 将是一个可以使您轻松获得一切设置的选择。</p>
<p>以下是应在 Visual Studio 2019 构建工具或 Visual Studio 2019 中安装的组件列表：</p>
<ul class="simple">
<li><p>Visual Studio C++ core features</p></li>
<li><p>VC++ 2019 v141 toolset (x86,x64)</p></li>
<li><p>Windows Universal CRT SDK</p></li>
<li><p>Windows 8.1 SDK</p></li>
<li><p>C++/CLI support</p></li>
</ul>
<p>我们有一个辅助脚本，您可以用它来安装所有需要的外部依赖：</p>
<div class="highlight-bat notranslate"><div class="highlight"><pre><span></span>scripts\install_deps.ps1
</pre></div>
</div>
<p>这将安装 <code class="docutils literal notranslate"><span class="pre">boost</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cmake</span></code> 到 <code class="docutils literal notranslate"><span class="pre">deps</span></code> 子目录。</p>
</section>
<section id="id12">
<h4>克隆代码库<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<p>执行以下命令，克隆源代码：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>--recursive<span class="w"> </span>https://github.com/ethereum/solidity.git
<span class="nb">cd</span><span class="w"> </span>solidity
</pre></div>
</div>
<p>如果您想帮助开发 Solidity，
您可以分叉 Solidity，然后将您个人的分叉库作为第二远程源添加。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>remote<span class="w"> </span>add<span class="w"> </span>personal<span class="w"> </span>git@github.com:<span class="o">[</span>username<span class="o">]</span>/solidity.git
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这种方法将导致一个预发布的构建，例如，在这种编译器产生的每个字节码中设置一个标志。
如果您想重新构建一个已发布的 Solidity 编译器，那么请使用 github 发布页上的源压缩包：</p>
<p><a class="reference external" href="https://github.com/ethereum/solidity/releases/download/v0.X.Y/solidity_0.X.Y.tar.gz">https://github.com/ethereum/solidity/releases/download/v0.X.Y/solidity_0.X.Y.tar.gz</a></p>
<p>(而不是由 github 提供的 &quot;源代码&quot;)。</p>
</div>
</section>
<section id="id13">
<h4>命令行构建<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h4>
<p><strong>请确保在构建前安装外部依赖项（见上文）。</strong></p>
<p>Solidity 项目使用 CMake 来配置构建。
您可能想安装 <a class="reference external" href="https://ccache.dev/">ccache</a> 以加快重复构建的速度。CMake 会自动使用它。
在 Linux、macOS 和其他 Unix 系统上构建 Solidity 方式都差不多：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>..<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make
</pre></div>
</div>
<p>或者在 Linux 和 macOS 上有更简单的方式，您可以运行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#注意：这将在 usr/local/bin 安装 solc 和 soltest 的二进制文件。</span>
./scripts/build.sh
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>BSD 构建应该也可以工作，但是 Solidity 团队没有测试过。</p>
</div>
<p>对于 Windows 执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>-G<span class="w"> </span><span class="s2">&quot;Visual Studio 16 2019&quot;</span><span class="w"> </span>..
</pre></div>
</div>
<p>如果您想使用由 <code class="docutils literal notranslate"><span class="pre">scripts\install_deps.ps1</span></code> 安装的 boost 版本，
您需要额外传递 <code class="docutils literal notranslate"><span class="pre">-DBoost_DIR=&quot;deps\boost\lib\cmake\Boost-*&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded</span></code>
作为参数给 <code class="docutils literal notranslate"><span class="pre">cmake</span></code> 调用。</p>
<p>这将会导致在构建目录中创建 <strong>solidity.sln</strong> 文件。
双击该文件，Visual Studio 就会启动。
我们建议创建 <strong>Release</strong> 配置，但其他的配置也可以。</p>
<p>或者，您可以在命令行上为 Windows 构建，像这样：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>--build<span class="w"> </span>.<span class="w"> </span>--config<span class="w"> </span>Release
</pre></div>
</div>
</section>
</section>
<section id="id14">
<h3>CMake 选项<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h3>
<p>如果您对CMake的可选项感兴趣，可以运行 <code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">...</span> <span class="pre">-LH</span></code>。</p>
<section id="smt">
<span id="smt-solvers-build"></span><h4>SMT 解算器<a class="headerlink" href="#smt" title="此标题的永久链接"></a></h4>
<p>Solidity 可以针对 SMT 解算器进行构建，如果它们在系统中被发现，
将默认为是这样做的。每个解算器都可以通过 <cite>cmake</cite> 选项禁用。</p>
<p><em>注意：在某些情况下，这也可以是构建失败后，可能的变通方法。</em></p>
<p>在构建文件夹内，您可以禁用它们，因为它们是默认启用的:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 只禁用Z3 SMT解算器。</span>
cmake<span class="w"> </span>..<span class="w"> </span>-DUSE_Z3<span class="o">=</span>OFF

<span class="c1"># 只禁用CVC4 SMT解算器。</span>
cmake<span class="w"> </span>..<span class="w"> </span>-DUSE_CVC4<span class="o">=</span>OFF

<span class="c1"># 同时禁用Z3和CVC4</span>
cmake<span class="w"> </span>..<span class="w"> </span>-DUSE_CVC4<span class="o">=</span>OFF<span class="w"> </span>-DUSE_Z3<span class="o">=</span>OFF
</pre></div>
</div>
</section>
</section>
<section id="id15">
<h3>版本号字符串详解<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h3>
<p>Solidity 版本名包含四部分：</p>
<ul class="simple">
<li><p>版本号</p></li>
<li><p>预发布版本标签，通常为 <code class="docutils literal notranslate"><span class="pre">develop.YYYY.MM.DD</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">nightly.YYYY.MM.DD</span></code></p></li>
<li><p>以 <code class="docutils literal notranslate"><span class="pre">commit.GITHASH</span></code> 格式展示的提交号</p></li>
<li><p>由若干条平台、编译器详细信息构成的平台标识</p></li>
</ul>
<p>如果有本地修改，提交将会有后缀 <code class="docutils literal notranslate"><span class="pre">.mod</span></code>。</p>
<p>这些部分按照 Semver 的要求来组合， 其中 Solidity 预发布版标签等价于 Semver 预发布版标签，
而 Solidity 提交号和平台标识则组成Semver的构建元数据。</p>
<p>发布版样例: <code class="docutils literal notranslate"><span class="pre">0.4.8+commit.60cc1668.Emscripten.clang</span></code>。</p>
<p>预发布版样例: <code class="docutils literal notranslate"><span class="pre">0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang</span></code>。</p>
</section>
<section id="id16">
<h3>关于版本管理的重要信息<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h3>
<p>在版本发布之后，补丁版本号会增加，因为我们假定接下来只有补丁级别的变更。
当变更被合并后，版本应该根据 Semver 和变更的重要程度来提升。
最后，发行版本总是与当前每日开发构建版本本的版本号一致，但没有 <code class="docutils literal notranslate"><span class="pre">prerelease</span></code> 指示符。</p>
<p>示例:</p>
<ol class="arabic simple">
<li><p>0.4.0 版本发布。</p></li>
<li><p>从现在开始，每晚构建一个 0.4.1 版本。</p></li>
<li><p>引入非重大变更 —— 不改变版本号。</p></li>
<li><p>引入重大变更 —— 版本号提升到 0.5.0。</p></li>
<li><p>0.5.0 版本发布。</p></li>
</ol>
<p>该方式与 <a class="reference internal" href="index.html#version-pragma"><span class="std std-ref">version pragma</span></a> 一起运行良好。</p>
</section>
</section>
<span id="document-solidity-by-example"></span><section id="solidity">
<h2>Solidity 合约示例<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h2>
<section id="voting">
<span id="index-0"></span><span id="id1"></span><h3>投票合约<a class="headerlink" href="#voting" title="此标题的永久链接"></a></h3>
<p>下面的合约相当复杂，但展示了Solidity的很多特性。
它实现了一个投票合约。当然，
电子投票的主要问题是如何将投票权分配给正确的人以及如何防止人为操纵。
我们不会在这里解决所有的问题，但至少我们会展示如何进行委托投票，
与此同时，使计票是 <strong>自动且完全透明的。</strong></p>
<p>我们的想法是为每张选票创建一份合约，
为每个选项提供一个简称。
然后，作为合约的创造者——即主席，
将给予每个地址单独的投票权。</p>
<p>地址后面的人可以选择自己投票，或者委托给他们信任的人来投票。</p>
<p>在投票时间结束时， <code class="docutils literal notranslate"><span class="pre">winningProposal()</span></code> 将返回拥有最大票数的提案。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLy8gQHRpdGxlIOWnlOaJmOaKleelqApjb250cmFjdCBCYWxsb3QgewogICAgLy8g6L+Z5aOw5piO5LqG5LiA5Liq5paw55qE5aSN5p2C57G75Z6L77yM55So5LqO56iN5ZCO5Y+Y6YeP44CCCiAgICAvLyDlroPnlKjmnaXooajnpLrkuIDkuKrpgInmsJHjgIIKICAgIHN0cnVjdCBWb3RlciB7CiAgICAgICAgdWludCB3ZWlnaHQ7IC8vIOiuoeelqOeahOadg+mHjQogICAgICAgIGJvb2wgdm90ZWQ7ICAvLyDoi6XkuLrnnJ/vvIzku6Pooajor6Xkurrlt7LmipXnpagKICAgICAgICBhZGRyZXNzIGRlbGVnYXRlOyAvLyDooqvlp5TmiZjkuroKICAgICAgICB1aW50IHZvdGU7ICAgLy8g5oqV56Wo5o+Q5qGI55qE57Si5byVCiAgICB9CgogICAgLy8g5o+Q5qGI55qE57G75Z6LCiAgICBzdHJ1Y3QgUHJvcG9zYWwgewogICAgICAgIGJ5dGVzMzIgbmFtZTsgICAvLyDnroDnp7DvvIjmnIDplb8zMuS4quWtl+iKgu+8iQogICAgICAgIHVpbnQgdm90ZUNvdW50OyAvLyDlvpfnpajmlbAKICAgIH0KCiAgICBhZGRyZXNzIHB1YmxpYyBjaGFpcnBlcnNvbjsKICAgIC8vIOi/meWjsOaYjuS6huS4gOS4queKtuaAgeWPmOmHj++8jOS4uuavj+S4quWPr+iDveeahOWcsOWdgOWtmOWCqOS4gOS4qiBgVm90ZXJg44CCCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gVm90ZXIpIHB1YmxpYyB2b3RlcnM7CgogICAgLy8g5LiA5LiqIGBQcm9wb3NhbGAg57uT5p6E57G75Z6L55qE5Yqo5oCB5pWw57uE44CCCiAgICBQcm9wb3NhbFtdIHB1YmxpYyBwcm9wb3NhbHM7CgogICAgLy8vIOS4uiBgcHJvcG9zYWxOYW1lc2Ag5Lit55qE5q+P5Liq5o+Q5qGI77yM5Yib5bu65LiA5Liq5paw55qE77yI5oqV56Wo77yJ6KGo5YazCiAgICBjb25zdHJ1Y3RvcihieXRlczMyW10gbWVtb3J5IHByb3Bvc2FsTmFtZXMpIHsKICAgICAgICBjaGFpcnBlcnNvbiA9IG1zZy5zZW5kZXI7CiAgICAgICAgdm90ZXJzW2NoYWlycGVyc29uXS53ZWlnaHQgPSAxOwoKICAgICAgICAvLyDlr7nkuo7mj5DkvpvnmoTmr4/kuKrmj5DmoYjlkI3np7DvvIwKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgUHJvcG9zYWwg5a+56LGh5bm25oqK5a6D5re75Yqg5Yiw5pWw57uE55qE5pyr5bC+44CCCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgcHJvcG9zYWxOYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAvLyBgUHJvcG9zYWwoey4uLn0pYCDliJvlu7rkuIDkuKrkuLTml7YgUHJvcG9zYWwg5a+56LGhCiAgICAgICAgICAgIC8vIGBwcm9wb3NhbHMucHVzaCguLi4pYCDlsIblhbbmt7vliqDliLAgYHByb3Bvc2Fsc2Ag55qE5pyr5bC+CiAgICAgICAgICAgIHByb3Bvc2Fscy5wdXNoKFByb3Bvc2FsKHsKICAgICAgICAgICAgICAgIG5hbWU6IHByb3Bvc2FsTmFtZXNbaV0sCiAgICAgICAgICAgICAgICB2b3RlQ291bnQ6IDAKICAgICAgICAgICAgfSkpOwogICAgICAgIH0KICAgIH0KCiAgICAvLyDnu5nkuoggYHZvdGVyYCDlnKjov5nlvKDpgInnpajkuIrmipXnpajnmoTmnYPliKnjgIIKICAgIC8vIOWPquaciSBgY2hhaXJwZXJzb25gIOWPr+S7peiwg+eUqOivpeWHveaVsOOAggogICAgZnVuY3Rpb24gZ2l2ZVJpZ2h0VG9Wb3RlKGFkZHJlc3Mgdm90ZXIpIGV4dGVybmFsIHsKICAgICAgICAvLyDoi6UgYHJlcXVpcmVgIOeahOesrOS4gOS4quWPguaVsOeahOiuoeeul+e7k+aenOS4uiBgZmFsc2Vg77yMCiAgICAgICAgLy8g5YiZ57uI5q2i5omn6KGM77yM5pKk6ZSA5omA5pyJ5a+554q25oCB5ZKM5Lul5aSq5biB5L2Z6aKd55qE5pS55Yqo44CCCiAgICAgICAgLy8g5Zyo5pen54mI55qEIEVWTSDkuK3ov5nmm77nu4/kvJrmtojogJfmiYDmnIkgZ2Fz77yM5L2G546w5Zyo5LiN5Lya5LqG44CCCiAgICAgICAgLy8g5L2/55SoIGByZXF1aXJlYCDmnaXmo4Dmn6Xlh73mlbDmmK/lkKbooqvmraPnoa7lnLDosIPnlKjvvIzpgJrluLjmmK/kuKrlpb3kuLvmhI/jgIIKICAgICAgICAvLyDmgqjkuZ/lj6/ku6XlnKggYHJlcXVpcmVgIOeahOesrOS6jOS4quWPguaVsOS4reaPkOS+m+S4gOS4quWvuemUmeivr+aDheWGteeahOino+mHiuOAggogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gY2hhaXJwZXJzb24sCiAgICAgICAgICAgICJPbmx5IGNoYWlycGVyc29uIGNhbiBnaXZlIHJpZ2h0IHRvIHZvdGUuIgogICAgICAgICk7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIXZvdGVyc1t2b3Rlcl0udm90ZWQsCiAgICAgICAgICAgICJUaGUgdm90ZXIgYWxyZWFkeSB2b3RlZC4iCiAgICAgICAgKTsKICAgICAgICByZXF1aXJlKHZvdGVyc1t2b3Rlcl0ud2VpZ2h0ID09IDApOwogICAgICAgIHZvdGVyc1t2b3Rlcl0ud2VpZ2h0ID0gMTsKICAgIH0KCiAgICAvLy8g5oqK5oKo55qE5oqV56Wo5aeU5omY57uZ5oqV56Wo6ICFIGB0b2DjgIIKICAgIGZ1bmN0aW9uIGRlbGVnYXRlKGFkZHJlc3MgdG8pIGV4dGVybmFsIHsKICAgICAgICAvLyDmjIflrprlvJXnlKgKICAgICAgICBWb3RlciBzdG9yYWdlIHNlbmRlciA9IHZvdGVyc1ttc2cuc2VuZGVyXTsKICAgICAgICByZXF1aXJlKHNlbmRlci53ZWlnaHQgIT0gMCwgIllvdSBoYXZlIG5vIHJpZ2h0IHRvIHZvdGUiKTsKICAgICAgICByZXF1aXJlKCFzZW5kZXIudm90ZWQsICJZb3UgYWxyZWFkeSB2b3RlZC4iKTsKCiAgICAgICAgcmVxdWlyZSh0byAhPSBtc2cuc2VuZGVyLCAiU2VsZi1kZWxlZ2F0aW9uIGlzIGRpc2FsbG93ZWQuIik7CgogICAgICAgIC8vIOWnlOaJmOaYr+WPr+S7peS8oOmAkueahO+8jOWPquimgeiiq+WnlOaJmOiAhSBgdG9gIOS5n+iuvue9ruS6huWnlOaJmOOAggogICAgICAgIC8vIOS4gOiIrOadpeivtO+8jOi/meagt+eahOW+queOr+WnlOaJmOaYr+mdnuW4uOWNsemZqeeahO+8jOWboOS4uuWmguaenOS8oOmAkueahOmTvuadoeWkqumVv++8jAogICAgICAgIC8vIOWPr+iDvemcgOimgea2iOiAl+eahGdhc+WwseS8mui2hei/h+S4gOS4quWMuuWdl+S4reeahOWPr+eUqOaVsOmHj+OAggogICAgICAgIC8vIOi/meenjeaDheWGteS4i++8jOWnlOaJmOS4jeS8muiiq+aJp+ihjOOAggogICAgICAgIC8vIOS9huWcqOWFtuS7luaDheWGteS4i++8jOWmguaenOW9ouaIkOmXreeOr++8jOWImeS8muWvvOiHtOWQiOe6puWujOWFqOiiqyAi5Y2h5L2PIuOAggogICAgICAgIHdoaWxlICh2b3RlcnNbdG9dLmRlbGVnYXRlICE9IGFkZHJlc3MoMCkpIHsKICAgICAgICAgICAgdG8gPSB2b3RlcnNbdG9dLmRlbGVnYXRlOwoKICAgICAgICAgICAgLy8g5LiN5YWB6K646Zet546v5aeU5omYCiAgICAgICAgICAgIHJlcXVpcmUodG8gIT0gbXNnLnNlbmRlciwgIkZvdW5kIGxvb3AgaW4gZGVsZWdhdGlvbi4iKTsKICAgICAgICB9CgogICAgICAgIFZvdGVyIHN0b3JhZ2UgZGVsZWdhdGVfID0gdm90ZXJzW3RvXTsKCiAgICAgICAgLy8g5oqV56Wo6ICF5LiN6IO95bCG5oqV56Wo5p2D5aeU5omY57uZ5LiN6IO95oqV56Wo55qE6LSm5oi344CCCiAgICAgICAgcmVxdWlyZShkZWxlZ2F0ZV8ud2VpZ2h0ID49IDEpOwoKICAgICAgICAvLyDnlLHkuo4gYHNlbmRlcmAg5piv5LiA5Liq5byV55So77yMCiAgICAgICAgLy8g5Zug5q2k6L+Z5Lya5L+u5pS5IGB2b3RlcnNbbXNnLnNlbmRlcl1g44CCCiAgICAgICAgc2VuZGVyLnZvdGVkID0gdHJ1ZTsKICAgICAgICBzZW5kZXIuZGVsZWdhdGUgPSB0bzsKCiAgICAgICAgaWYgKGRlbGVnYXRlXy52b3RlZCkgewogICAgICAgICAgICAvLyDoi6Xooqvlp5TmiZjogIXlt7Lnu4/mipXov4fnpajkuobvvIznm7TmjqXlop7liqDlvpfnpajmlbDjgIIKICAgICAgICAgICAgcHJvcG9zYWxzW2RlbGVnYXRlXy52b3RlXS52b3RlQ291bnQgKz0gc2VuZGVyLndlaWdodDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyDoi6Xooqvlp5TmiZjogIXov5jmsqHmipXnpajvvIzlop7liqDlp5TmiZjogIXnmoTmnYPph43jgIIKICAgICAgICAgICAgZGVsZWdhdGVfLndlaWdodCArPSBzZW5kZXIud2VpZ2h0OwogICAgICAgIH0KICAgIH0KCiAgICAvLy8g5oqK5oKo55qE56WoKOWMheaLrOWnlOaJmOe7meaCqOeahOelqCnvvIwKICAgIC8vLyDmipXnu5nmj5DmoYggYHByb3Bvc2Fsc1twcm9wb3NhbF0ubmFtZWDjgIIKICAgIGZ1bmN0aW9uIHZvdGUodWludCBwcm9wb3NhbCkgZXh0ZXJuYWwgewogICAgICAgIFZvdGVyIHN0b3JhZ2Ugc2VuZGVyID0gdm90ZXJzW21zZy5zZW5kZXJdOwogICAgICAgIHJlcXVpcmUoc2VuZGVyLndlaWdodCAhPSAwLCAiSGFzIG5vIHJpZ2h0IHRvIHZvdGUiKTsKICAgICAgICByZXF1aXJlKCFzZW5kZXIudm90ZWQsICJBbHJlYWR5IHZvdGVkLiIpOwogICAgICAgIHNlbmRlci52b3RlZCA9IHRydWU7CiAgICAgICAgc2VuZGVyLnZvdGUgPSBwcm9wb3NhbDsKCiAgICAgICAgLy8g5aaC5p6cIGBwcm9wb3NhbGAg6LaF6L+H5LqG5pWw57uE55qE6IyD5Zu077yMCiAgICAgICAgLy8g5YiZ5Lya6Ieq5Yqo5oqb5Ye65byC5bi477yM5bm25oGi5aSN5omA5pyJ55qE5pS55Yqo44CCCiAgICAgICAgcHJvcG9zYWxzW3Byb3Bvc2FsXS52b3RlQ291bnQgKz0gc2VuZGVyLndlaWdodDsKICAgIH0KCiAgICAvLy8gQGRldiDnu5PlkIjkuYvliY3miYDmnInmipXnpajnmoTmg4XlhrXkuIvvvIzorqHnrpflh7rojrfog5znmoTmj5DmoYjjgIIKICAgIGZ1bmN0aW9uIHdpbm5pbmdQcm9wb3NhbCgpIHB1YmxpYyB2aWV3CiAgICAgICAgICAgIHJldHVybnMgKHVpbnQgd2lubmluZ1Byb3Bvc2FsXykKICAgIHsKICAgICAgICB1aW50IHdpbm5pbmdWb3RlQ291bnQgPSAwOwogICAgICAgIGZvciAodWludCBwID0gMDsgcCA8IHByb3Bvc2Fscy5sZW5ndGg7IHArKykgewogICAgICAgICAgICBpZiAocHJvcG9zYWxzW3BdLnZvdGVDb3VudCA+IHdpbm5pbmdWb3RlQ291bnQpIHsKICAgICAgICAgICAgICAgIHdpbm5pbmdWb3RlQ291bnQgPSBwcm9wb3NhbHNbcF0udm90ZUNvdW50OwogICAgICAgICAgICAgICAgd2lubmluZ1Byb3Bvc2FsXyA9IHA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CgogICAgLy8g6LCD55SoIGB3aW5uaW5nUHJvcG9zYWwoKWAg5Ye95pWw5Lul6I635Y+W5o+Q5qGI5pWw57uE5Lit6I636IOc6ICF55qE57Si5byV77yMCiAgICAvLyDlubbku6XmraTov5Tlm57ojrfog5zogIXnmoTlkI3np7DjgIIKICAgIGZ1bmN0aW9uIHdpbm5lck5hbWUoKSBleHRlcm5hbCB2aWV3CiAgICAgICAgICAgIHJldHVybnMgKGJ5dGVzMzIgd2lubmVyTmFtZV8pCiAgICB7CiAgICAgICAgd2lubmVyTmFtZV8gPSBwcm9wb3NhbHNbd2lubmluZ1Byb3Bvc2FsKCldLm5hbWU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="c1">/// @title 委托投票</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Ballot</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 这声明了一个新的复杂类型，用于稍后变量。</span>
<span class="w">    </span><span class="c1">// 它用来表示一个选民。</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Voter</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">weight</span><span class="p">;</span><span class="w"> </span><span class="c1">// 计票的权重</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nv">voted</span><span class="p">;</span><span class="w">  </span><span class="c1">// 若为真，代表该人已投票</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">delegate</span><span class="p">;</span><span class="w"> </span><span class="c1">// 被委托人</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">vote</span><span class="p">;</span><span class="w">   </span><span class="c1">// 投票提案的索引</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 提案的类型</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Proposal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">;</span><span class="w">   </span><span class="c1">// 简称（最长32个字节）</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">voteCount</span><span class="p">;</span><span class="w"> </span><span class="c1">// 得票数</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">chairperson</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Voter<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>voters<span class="p">;</span>

<span class="w">    </span><span class="c1">// 一个 `Proposal` 结构类型的动态数组。</span>
<span class="w">    </span>Proposal<span class="p">[]</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>proposals<span class="p">;</span>

<span class="w">    </span><span class="c1">/// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>proposalNames<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>chairperson<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">        </span>voters<span class="p">[</span>chairperson<span class="p">].</span>weight<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 对于提供的每个提案名称，</span>
<span class="w">        </span><span class="c1">// 创建一个新的 Proposal 对象并把它添加到数组的末尾。</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>proposalNames<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// `Proposal({...})` 创建一个临时 Proposal 对象</span>
<span class="w">            </span><span class="c1">// `proposals.push(...)` 将其添加到 `proposals` 的末尾</span>
<span class="w">            </span>proposals<span class="p">.</span>push<span class="p">(</span>Proposal<span class="p">({</span>
<span class="w">                </span>name<span class="o">:</span><span class="w"> </span>proposalNames<span class="p">[</span>i<span class="p">],</span>
<span class="w">                </span>voteCount<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">0</span>
<span class="w">            </span><span class="p">}));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 给予 `voter` 在这张选票上投票的权利。</span>
<span class="w">    </span><span class="c1">// 只有 `chairperson` 可以调用该函数。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">giveRightToVote</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">voter</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 若 `require` 的第一个参数的计算结果为 `false`，</span>
<span class="w">        </span><span class="c1">// 则终止执行，撤销所有对状态和以太币余额的改动。</span>
<span class="w">        </span><span class="c1">// 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。</span>
<span class="w">        </span><span class="c1">// 使用 `require` 来检查函数是否被正确地调用，通常是个好主意。</span>
<span class="w">        </span><span class="c1">// 您也可以在 `require` 的第二个参数中提供一个对错误情况的解释。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>chairperson<span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;Only chairperson can give right to vote.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span><span class="o">!</span>voters<span class="p">[</span>voter<span class="p">].</span>voted<span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;The voter already voted.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>voters<span class="p">[</span>voter<span class="p">].</span>weight<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">);</span>
<span class="w">        </span>voters<span class="p">[</span>voter<span class="p">].</span>weight<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 把您的投票委托给投票者 `to`。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">delegate</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 指定引用</span>
<span class="w">        </span>Voter<span class="w"> </span>storage<span class="w"> </span>sender<span class="w"> </span><span class="o">=</span><span class="w"> </span>voters<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>sender<span class="p">.</span>weight<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;You have no right to vote&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="o">!</span>sender<span class="p">.</span>voted<span class="p">,</span><span class="w"> </span><span class="s2">&quot;You already voted.&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="kt">require</span><span class="p">(</span>to<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Self-delegation is disallowed.&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 委托是可以传递的，只要被委托者 `to` 也设置了委托。</span>
<span class="w">        </span><span class="c1">// 一般来说，这样的循环委托是非常危险的，因为如果传递的链条太长，</span>
<span class="w">        </span><span class="c1">// 可能需要消耗的gas就会超过一个区块中的可用数量。</span>
<span class="w">        </span><span class="c1">// 这种情况下，委托不会被执行。</span>
<span class="w">        </span><span class="c1">// 但在其他情况下，如果形成闭环，则会导致合约完全被 &quot;卡住&quot;。</span>
<span class="w">        </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>voters<span class="p">[</span>to<span class="p">].</span>delegate<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>to<span class="w"> </span><span class="o">=</span><span class="w"> </span>voters<span class="p">[</span>to<span class="p">].</span>delegate<span class="p">;</span>

<span class="w">            </span><span class="c1">// 不允许闭环委托</span>
<span class="w">            </span><span class="kt">require</span><span class="p">(</span>to<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Found loop in delegation.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span>Voter<span class="w"> </span>storage<span class="w"> </span>delegate_<span class="w"> </span><span class="o">=</span><span class="w"> </span>voters<span class="p">[</span>to<span class="p">];</span>

<span class="w">        </span><span class="c1">// 投票者不能将投票权委托给不能投票的账户。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>delegate_<span class="p">.</span>weight<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 由于 `sender` 是一个引用，</span>
<span class="w">        </span><span class="c1">// 因此这会修改 `voters[msg.sender]`。</span>
<span class="w">        </span>sender<span class="p">.</span>voted<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span>sender<span class="p">.</span>delegate<span class="w"> </span><span class="o">=</span><span class="w"> </span>to<span class="p">;</span>

<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>delegate_<span class="p">.</span>voted<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 若被委托者已经投过票了，直接增加得票数。</span>
<span class="w">            </span>proposals<span class="p">[</span>delegate_<span class="p">.</span>vote<span class="p">].</span>voteCount<span class="w"> </span><span class="o">+=</span><span class="w"> </span>sender<span class="p">.</span>weight<span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kt">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 若被委托者还没投票，增加委托者的权重。</span>
<span class="w">            </span>delegate_<span class="p">.</span>weight<span class="w"> </span><span class="o">+=</span><span class="w"> </span>sender<span class="p">.</span>weight<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 把您的票(包括委托给您的票)，</span>
<span class="w">    </span><span class="c1">/// 投给提案 `proposals[proposal].name`。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">vote</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">proposal</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>Voter<span class="w"> </span>storage<span class="w"> </span>sender<span class="w"> </span><span class="o">=</span><span class="w"> </span>voters<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>sender<span class="p">.</span>weight<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Has no right to vote&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="o">!</span>sender<span class="p">.</span>voted<span class="p">,</span><span class="w"> </span><span class="s2">&quot;Already voted.&quot;</span><span class="p">);</span>
<span class="w">        </span>sender<span class="p">.</span>voted<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span>sender<span class="p">.</span>vote<span class="w"> </span><span class="o">=</span><span class="w"> </span>proposal<span class="p">;</span>

<span class="w">        </span><span class="c1">// 如果 `proposal` 超过了数组的范围，</span>
<span class="w">        </span><span class="c1">// 则会自动抛出异常，并恢复所有的改动。</span>
<span class="w">        </span>proposals<span class="p">[</span>proposal<span class="p">].</span>voteCount<span class="w"> </span><span class="o">+=</span><span class="w"> </span>sender<span class="p">.</span>weight<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @dev 结合之前所有投票的情况下，计算出获胜的提案。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">winningProposal</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view
<span class="w">            </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">winningProposal_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">winningVoteCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>p<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>proposals<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>p<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>proposals<span class="p">[</span>p<span class="p">].</span>voteCount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>winningVoteCount<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span>winningVoteCount<span class="w"> </span><span class="o">=</span><span class="w"> </span>proposals<span class="p">[</span>p<span class="p">].</span>voteCount<span class="p">;</span>
<span class="w">                </span>winningProposal_<span class="w"> </span><span class="o">=</span><span class="w"> </span>p<span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 调用 `winningProposal()` 函数以获取提案数组中获胜者的索引，</span>
<span class="w">    </span><span class="c1">// 并以此返回获胜者的名称。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">winnerName</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>view
<span class="w">            </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">winnerName_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>winnerName_<span class="w"> </span><span class="o">=</span><span class="w"> </span>proposals<span class="p">[</span>winningProposal<span class="p">()].</span>name<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="id2">
<h4>可能的优化<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h4>
<p>当前，为了把投票权分配给所有参与者，需要执行很多交易。
此外，如果两个或更多的提案有相同的票数， <code class="docutils literal notranslate"><span class="pre">winningProposal()</span></code> 无法登记平局。
您能想出一个办法来解决这些问题吗？</p>
</section>
</section>
<section id="index-1">
<span id="id3"></span><h3>盲拍（秘密竞价）<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>在本节中，我们将展示如何轻松地在以太坊上创建一个盲拍的合约。
我们将从一个公开拍卖开始，每个人都可以看到出价，
然后将此合约扩展到盲拍合约， 在竞标期结束之前无法看到实际出价。</p>
<section id="simple-auction">
<span id="id4"></span><h4>简单的公开拍卖<a class="headerlink" href="#simple-auction" title="此标题的永久链接"></a></h4>
<p>下面这个简单的拍卖合约的总体思路是，每个人都可以在竞标期间发送他们的竞标。
竞标已经包括发送资金/以太币，以便将竞标者与他们的竞标绑定。
如果最高出价被提高，之前的最高出价者就会拿回他们的钱。
竞价期结束后，受益人需要手动调用合约，才能收到他们的钱 - 合约不能自己激活接收。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICAvLyDmi43ljZbnmoTlj4LmlbDjgIIKICAgIC8vIOaXtumXtOaYryB1bml4IOeahOe7neWvueaXtumXtOaIs++8iOiHqjE5NzAtMDEtMDHku6XmnaXnmoTnp5LmlbDvvIkKICAgIC8vIOaIluS7peenkuS4uuWNleS9jeeahOaXtumXtOauteOAggogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGF1Y3Rpb25FbmRUaW1lOwoKICAgIC8vIOaLjeWNlueahOW9k+WJjeeKtuaAgeOAggogICAgYWRkcmVzcyBwdWJsaWMgaGlnaGVzdEJpZGRlcjsKICAgIHVpbnQgcHVibGljIGhpZ2hlc3RCaWQ7CgogICAgLy8g5YWB6K645Y+W5Zue5Lul5YmN55qE56ue5qCH44CCCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgcGVuZGluZ1JldHVybnM7CgogICAgLy8g5ouN5Y2W57uT5p2f5ZCO6K6+5Li6IGB0cnVlYO+8jOWwhuemgeatouaJgOacieeahOWPmOabtAogICAgLy8g6buY6K6k5Yid5aeL5YyW5Li6IGBmYWxzZWDjgIIKICAgIGJvb2wgZW5kZWQ7CgogICAgLy8g5Y+Y5YyW5pe25bCG5Lya5Y+R5Ye655qE5LqL5Lu244CCCiAgICBldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBdWN0aW9uRW5kZWQoYWRkcmVzcyB3aW5uZXIsIHVpbnQgYW1vdW50KTsKCiAgICAvLyDmj4/ov7DlpLHotKXnmoTplJnor6/kv6Hmga/jgIIKCiAgICAvLyDkuInmlpznur/nmoTms6jph4rmmK/miYDosJPnmoQgbmF0c3BlYyDms6jph4rjgIIKICAgIC8vIOW9k+eUqOaIt+iiq+imgeaxguehruiupOS4gOS4quS6pOaYk+aIluaYvuekuuS4gOS4qumUmeivr+aXtu+8jOWug+S7rOWwhuiiq+aYvuekuuOAggoKICAgIC8vLyDnq57mi43lt7Lnu4/nu5PmnZ/jgIIKICAgIGVycm9yIEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKICAgIC8vLyDlt7Lnu4/mnInkuIDkuKrmm7Tpq5jnmoTmiJbnm7jnrYnnmoTlh7rku7fjgIIKICAgIGVycm9yIEJpZE5vdEhpZ2hFbm91Z2godWludCBoaWdoZXN0QmlkKTsKICAgIC8vLyDnq57mi43ov5jmsqHmnInnu5PmnZ/jgIIKICAgIGVycm9yIEF1Y3Rpb25Ob3RZZXRFbmRlZCgpOwogICAgLy8vIOWHveaVsCBhdWN0aW9uRW5kIOW3sue7j+iiq+iwg+eUqOOAggogICAgZXJyb3IgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKCiAgICAvLy8g5Lul5Y+X55uK6ICF5Zyw5Z2AIGBiZW5lZmljaWFyeUFkZHJlc3NgIOWIm+W7uuS4gOS4queugOWNleeahOaLjeWNlu+8jAogICAgLy8vIOaLjeWNluaXtumVv+S4uiBgX2JpZGRpbmdUaW1lYOOAggogICAgY29uc3RydWN0b3IoCiAgICAgICAgdWludCBiaWRkaW5nVGltZSwKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnlBZGRyZXNzCiAgICApIHsKICAgICAgICBiZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5QWRkcmVzczsKICAgICAgICBhdWN0aW9uRW5kVGltZSA9IGJsb2NrLnRpbWVzdGFtcCArIGJpZGRpbmdUaW1lOwogICAgfQoKICAgIC8vLyDlr7nmi43ljZbov5vooYzlh7rku7fvvIzlhbfkvZPnmoTlh7rku7fpmo/kuqTmmJPkuIDotbflj5HpgIHjgIIKICAgIC8vLyDlpoLmnpzmsqHmnInlnKjmi43ljZbkuK3og5zlh7rvvIzliJnov5Tov5jlh7rku7fjgIIKICAgIGZ1bmN0aW9uIGJpZCgpIGV4dGVybmFsIHBheWFibGUgewogICAgICAgIC8vIOWPguaVsOS4jeaYr+W/heimgeeahOOAguWboOS4uuaJgOacieeahOS/oeaBr+W3sue7j+WMheWQq+WcqOS6huS6pOaYk+S4reOAggogICAgICAgIC8vIOWFs+mUruWtlyBgcGF5YWJsZWAg5piv5Ye95pWw6IO95aSf5o6l5pS25Lul5aSq5biB55qE5b+F6KaB5p2h5Lu244CCCgogICAgICAgIC8vIOWmguaenOaLjeWNluW3sue7k+adn++8jOaSpOmUgOWHveaVsOeahOiwg+eUqOOAggogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPiBhdWN0aW9uRW5kVGltZSkKICAgICAgICAgICAgcmV2ZXJ0IEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKCiAgICAgICAgLy8g5aaC5p6c5Ye65Lu35LiN6auY77yM5bCx5oqK6ZKx6YCB5Zue5Y67CiAgICAgICAgLy/vvIhyZXZlcnTor63lj6XlsIbmgaLlpI3ov5nkuKrlh73mlbDmiafooYzkuK3nmoTmiYDmnInlj5jljJbvvIwKICAgICAgICAvLyDljIXmi6zlroPlt7Lnu4/mlLbliLDpkrHvvInjgIIKICAgICAgICBpZiAobXNnLnZhbHVlIDw9IGhpZ2hlc3RCaWQpCiAgICAgICAgICAgIHJldmVydCBCaWROb3RIaWdoRW5vdWdoKGhpZ2hlc3RCaWQpOwoKICAgICAgICBpZiAoaGlnaGVzdEJpZCAhPSAwKSB7CiAgICAgICAgICAgIC8vIOeugOWNleWcsOS9v+eUqCBoaWdoZXN0QmlkZGVyLnNlbmQoaGlnaGVzdEJpZCkKICAgICAgICAgICAgLy8g6L+U6L+Y5Ye65Lu35pe277yM5piv5pyJ5a6J5YWo6aOO6Zmp55qE77yMCiAgICAgICAgICAgIC8vIOWboOS4uuWug+WPr+iDveaJp+ihjOS4gOS4quS4jeWPl+S/oeS7u+eahOWQiOe6puOAggogICAgICAgICAgICAvLyDorqnmjqXmlLbmlrnoh6rlt7Hlj5bpkrHmgLvmmK/mr5TovoPlronlhajnmoTjgIIKICAgICAgICAgICAgcGVuZGluZ1JldHVybnNbaGlnaGVzdEJpZGRlcl0gKz0gaGlnaGVzdEJpZDsKICAgICAgICB9CiAgICAgICAgaGlnaGVzdEJpZGRlciA9IG1zZy5zZW5kZXI7CiAgICAgICAgaGlnaGVzdEJpZCA9IG1zZy52YWx1ZTsKICAgICAgICBlbWl0IEhpZ2hlc3RCaWRJbmNyZWFzZWQobXNnLnNlbmRlciwgbXNnLnZhbHVlKTsKICAgIH0KCiAgICAvLy8g5pKk5Zue5Ye65Lu36L+H6auY55qE56ue5qCH44CCCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpIHsKICAgICAgICB1aW50IGFtb3VudCA9IHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdOwogICAgICAgIGlmIChhbW91bnQgPiAwKSB7CiAgICAgICAgICAgIC8vIOWwhuWFtuiuvue9ruS4ujDmmK/lvojph43opoHnmoTvvIwKICAgICAgICAgICAgLy8g5Zug5Li65o6l5pS26ICF5Y+v5Lul5ZyoIGBzZW5kYCDov5Tlm57kuYvliY3lho3mrKHosIPnlKjov5nkuKrlh73mlbAKICAgICAgICAgICAgLy8g5L2c5Li65o6l5pS26LCD55So55qE5LiA6YOo5YiG44CCCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdID0gMDsKCiAgICAgICAgICAgIC8vIG1zZy5zZW5kZXIg5LiN5bGe5LqOIGBhZGRyZXNzIHBheWFibGVgIOexu+Wei++8jAogICAgICAgICAgICAvLyDlv4Xpobvkvb/nlKggYHBheWFibGUobXNnLnNlbmRlcilgIOaYjuehrui9rOaNou+8jAogICAgICAgICAgICAvLyDku6Xkvr/kvb/nlKjmiJDlkZjlh73mlbAgYHNlbmQoKWDjgIIKICAgICAgICAgICAgaWYgKCFwYXlhYmxlKG1zZy5zZW5kZXIpLnNlbmQoYW1vdW50KSkgewogICAgICAgICAgICAgICAgLy8g6L+Z6YeM5LiN6ZyA5oqb5Ye65byC5bi477yM5Y+q6ZyA6YeN572u5pyq5LuY5qy+CiAgICAgICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IGFtb3VudDsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICAvLy8g57uT5p2f5ouN5Y2W77yM5bm25oqK5pyA6auY55qE5Ye65Lu35Y+R6YCB57uZ5Y+X55uK5Lq644CCCiAgICBmdW5jdGlvbiBhdWN0aW9uRW5kKCkgZXh0ZXJuYWwgewogICAgICAgIC8vIOWvueS6juWPr+S4juWFtuS7luWQiOe6puS6pOS6kueahOWHveaVsO+8iOaEj+WRs+edgOWug+S8muiwg+eUqOWFtuS7luWHveaVsOaIluWPkemAgeS7peWkquW4ge+8ie+8jAogICAgICAgIC8vIOS4gOS4quWlveeahOaMh+WvvOaWuemSiOaYr+WwhuWFtue7k+aehOWIhuS4uuS4ieS4qumYtuaute+8mgogICAgICAgIC8vIDEuIOajgOafpeadoeS7tgogICAgICAgIC8vIDIuIOaJp+ihjOWKqOS9nCAo5Y+v6IO95Lya5pS55Y+Y5p2h5Lu2KQogICAgICAgIC8vIDMuIOS4juWFtuS7luWQiOe6puS6pOS6kgogICAgICAgIC8vIOWmguaenOi/meS6m+mYtuauteebuOa3t+WQiO+8jOWFtuS7lueahOWQiOe6puWPr+iDveS8muWbnuiwg+W9k+WJjeWQiOe6puW5tuS/ruaUueeKtuaAge+8jAogICAgICAgIC8vIOaIluiAheWvvOiHtOafkOS6m+aViOaenO+8iOavlOWmguaUr+S7mOS7peWkquW4ge+8ieWkmuasoeeUn+aViOOAggogICAgICAgIC8vIOWmguaenOWQiOe6puWGheiwg+eUqOeahOWHveaVsOWMheWQq+S6huS4juWklumDqOWQiOe6pueahOS6pOS6ku+8jAogICAgICAgIC8vIOWImeWug+S5n+S8muiiq+iupOS4uuaYr+S4juWklumDqOWQiOe6puacieS6pOS6kueahOOAggoKICAgICAgICAvLyAxLiDmnaHku7YKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wIDwgYXVjdGlvbkVuZFRpbWUpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uTm90WWV0RW5kZWQoKTsKICAgICAgICBpZiAoZW5kZWQpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwoKICAgICAgICAvLyAyLiDlvbHlk40KICAgICAgICBlbmRlZCA9IHRydWU7CiAgICAgICAgZW1pdCBBdWN0aW9uRW5kZWQoaGlnaGVzdEJpZGRlciwgaGlnaGVzdEJpZCk7CgogICAgICAgIC8vIDMuIOS6pOS6kgogICAgICAgIGJlbmVmaWNpYXJ5LnRyYW5zZmVyKGhpZ2hlc3RCaWQpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleAuction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 拍卖的参数。</span>
<span class="w">    </span><span class="c1">// 时间是 unix 的绝对时间戳（自1970-01-01以来的秒数）</span>
<span class="w">    </span><span class="c1">// 或以秒为单位的时间段。</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>beneficiary<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">auctionEndTime</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 拍卖的当前状态。</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">highestBidder</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">highestBid</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 允许取回以前的竞标。</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pendingReturns<span class="p">;</span>

<span class="w">    </span><span class="c1">// 拍卖结束后设为 `true`，将禁止所有的变更</span>
<span class="w">    </span><span class="c1">// 默认初始化为 `false`。</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nv">ended</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 变化时将会发出的事件。</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">HighestBidIncreased</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">bidder</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">AuctionEnded</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">winner</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 描述失败的错误信息。</span>

<span class="w">    </span><span class="c1">// 三斜线的注释是所谓的 natspec 注释。</span>
<span class="w">    </span><span class="c1">// 当用户被要求确认一个交易或显示一个错误时，它们将被显示。</span>

<span class="w">    </span><span class="c1">/// 竞拍已经结束。</span>
<span class="w">    </span>error<span class="w"> </span>AuctionAlreadyEnded<span class="p">();</span>
<span class="w">    </span><span class="c1">/// 已经有一个更高的或相等的出价。</span>
<span class="w">    </span>error<span class="w"> </span>BidNotHighEnough<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">highestBid</span><span class="p">);</span>
<span class="w">    </span><span class="c1">/// 竞拍还没有结束。</span>
<span class="w">    </span>error<span class="w"> </span>AuctionNotYetEnded<span class="p">();</span>
<span class="w">    </span><span class="c1">/// 函数 auctionEnd 已经被调用。</span>
<span class="w">    </span>error<span class="w"> </span>AuctionEndAlreadyCalled<span class="p">();</span>

<span class="w">    </span><span class="c1">/// 以受益者地址 `beneficiaryAddress` 创建一个简单的拍卖，</span>
<span class="w">    </span><span class="c1">/// 拍卖时长为 `_biddingTime`。</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">biddingTime</span><span class="p">,</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>beneficiaryAddress
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>beneficiary<span class="w"> </span><span class="o">=</span><span class="w"> </span>beneficiaryAddress<span class="p">;</span>
<span class="w">        </span>auctionEndTime<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>biddingTime<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 对拍卖进行出价，具体的出价随交易一起发送。</span>
<span class="w">    </span><span class="c1">/// 如果没有在拍卖中胜出，则返还出价。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">bid</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 参数不是必要的。因为所有的信息已经包含在了交易中。</span>
<span class="w">        </span><span class="c1">// 关键字 `payable` 是函数能够接收以太币的必要条件。</span>

<span class="w">        </span><span class="c1">// 如果拍卖已结束，撤销函数的调用。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>auctionEndTime<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>AuctionAlreadyEnded<span class="p">();</span>

<span class="w">        </span><span class="c1">// 如果出价不高，就把钱送回去</span>
<span class="w">        </span><span class="c1">//（revert语句将恢复这个函数执行中的所有变化，</span>
<span class="w">        </span><span class="c1">// 包括它已经收到钱）。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>highestBid<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>BidNotHighEnough<span class="p">(</span>highestBid<span class="p">);</span>

<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>highestBid<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 简单地使用 highestBidder.send(highestBid)</span>
<span class="w">            </span><span class="c1">// 返还出价时，是有安全风险的，</span>
<span class="w">            </span><span class="c1">// 因为它可能执行一个不受信任的合约。</span>
<span class="w">            </span><span class="c1">// 让接收方自己取钱总是比较安全的。</span>
<span class="w">            </span>pendingReturns<span class="p">[</span>highestBidder<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>highestBid<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span>highestBidder<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">        </span>highestBid<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">        </span>emit<span class="w"> </span>HighestBidIncreased<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 撤回出价过高的竞标。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pendingReturns<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>amount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 将其设置为0是很重要的，</span>
<span class="w">            </span><span class="c1">// 因为接收者可以在 `send` 返回之前再次调用这个函数</span>
<span class="w">            </span><span class="c1">// 作为接收调用的一部分。</span>
<span class="w">            </span>pendingReturns<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// msg.sender 不属于 `address payable` 类型，</span>
<span class="w">            </span><span class="c1">// 必须使用 `payable(msg.sender)` 明确转换，</span>
<span class="w">            </span><span class="c1">// 以便使用成员函数 `send()`。</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>send<span class="p">(</span>amount<span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 这里不需抛出异常，只需重置未付款</span>
<span class="w">                </span>pendingReturns<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">                </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 结束拍卖，并把最高的出价发送给受益人。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">auctionEnd</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币），</span>
<span class="w">        </span><span class="c1">// 一个好的指导方针是将其结构分为三个阶段：</span>
<span class="w">        </span><span class="c1">// 1. 检查条件</span>
<span class="w">        </span><span class="c1">// 2. 执行动作 (可能会改变条件)</span>
<span class="w">        </span><span class="c1">// 3. 与其他合约交互</span>
<span class="w">        </span><span class="c1">// 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态，</span>
<span class="w">        </span><span class="c1">// 或者导致某些效果（比如支付以太币）多次生效。</span>
<span class="w">        </span><span class="c1">// 如果合约内调用的函数包含了与外部合约的交互，</span>
<span class="w">        </span><span class="c1">// 则它也会被认为是与外部合约有交互的。</span>

<span class="w">        </span><span class="c1">// 1. 条件</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>auctionEndTime<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>AuctionNotYetEnded<span class="p">();</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>ended<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>AuctionEndAlreadyCalled<span class="p">();</span>

<span class="w">        </span><span class="c1">// 2. 影响</span>
<span class="w">        </span>ended<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span>emit<span class="w"> </span>AuctionEnded<span class="p">(</span>highestBidder<span class="p">,</span><span class="w"> </span>highestBid<span class="p">);</span>

<span class="w">        </span><span class="c1">// 3. 交互</span>
<span class="w">        </span>beneficiary<span class="p">.</span>transfer<span class="p">(</span>highestBid<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id5">
<h4>盲拍（秘密竞拍）<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<p>之前的公开拍卖接下来将被扩展为盲目拍卖。
盲拍的好处是，在竞价期即将结束时没有时间压力。
在一个透明的计算平台上创建一个盲拍可能听起来是一个矛盾，但加密技术可以实现它。</p>
<p>在 <strong>竞标期间</strong>，竞标者实际上并没有发送他们的出价，
而只是发送一个哈希版本的出价。 由于目前几乎不可能找到两个（足够长的）值，
其哈希值是相等的，因此竞标者可通过该方式提交报价。 在竞标结束后，
竞标者必须公开他们的出价：他们发送未加密的值，
合约检查出价的哈希值是否与竞标期间提供的值相同。</p>
<p>另一个挑战是如何使拍卖同时做到 <strong>绑定和秘密</strong> :
唯一能阻止竞标者在赢得拍卖后不付款的方式是，让他们将钱和竞标一起发出。
但由于资金转移在 以太坊 中不能被隐藏，因此任何人都可以看到转移的资金。</p>
<p>下面的合约通过接受任何大于最高出价的值来解决这个问题。
当然，因为这只能在揭示阶段进行检查，有些出价可能是 <strong>无效</strong> 的，
甚至，这是故意的(与高出价一起，它甚至提供了一个明确的标志来标识无效的出价):
竞标者可以通过设置几个或高或低的无效出价来迷惑竞争对手。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgQmxpbmRBdWN0aW9uIHsKICAgIHN0cnVjdCBCaWQgewogICAgICAgIGJ5dGVzMzIgYmxpbmRlZEJpZDsKICAgICAgICB1aW50IGRlcG9zaXQ7CiAgICB9CgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGJpZGRpbmdFbmQ7CiAgICB1aW50IHB1YmxpYyByZXZlYWxFbmQ7CiAgICBib29sIHB1YmxpYyBlbmRlZDsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gQmlkW10pIHB1YmxpYyBiaWRzOwoKICAgIGFkZHJlc3MgcHVibGljIGhpZ2hlc3RCaWRkZXI7CiAgICB1aW50IHB1YmxpYyBoaWdoZXN0QmlkOwoKICAgIC8vIOWFgeiuuOWPluWbnuS7peWJjeeahOernuagh+OAggogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHBlbmRpbmdSZXR1cm5zOwoKICAgIGV2ZW50IEF1Y3Rpb25FbmRlZChhZGRyZXNzIHdpbm5lciwgdWludCBoaWdoZXN0QmlkKTsKCiAgICAvLyDmj4/ov7DlpLHotKXnmoTplJnor6/kv6Hmga/jgIIKCiAgICAvLy8g6K+l5Ye95pWw6KKr6L+H5pep6LCD55So44CCCiAgICAvLy8g5ZyoIGB0aW1lYCDml7bpl7Tlho3or5XkuIDmrKHjgIIKICAgIGVycm9yIFRvb0Vhcmx5KHVpbnQgdGltZSk7CiAgICAvLy8g6K+l5Ye95pWw6KKr6L+H5pma6LCD55So44CCCiAgICAvLy8g5a6D5LiN6IO95ZyoIGB0aW1lYCDml7bpl7TkuYvlkI7ooqvosIPnlKjjgIIKICAgIGVycm9yIFRvb0xhdGUodWludCB0aW1lKTsKICAgIC8vLyDlh73mlbAgYXVjdGlvbkVuZCDlt7Lnu4/ooqvosIPnlKjjgIIKICAgIGVycm9yIEF1Y3Rpb25FbmRBbHJlYWR5Q2FsbGVkKCk7CgogICAgLy8g5L2/55SoIOS/rumlsOespu+8iG1vZGlmaWVy77yJIOWPr+S7peabtOS+v+aNt+eahOagoemqjOWHveaVsOeahOWFpeWPguOAggogICAgLy8gYG9ubHlCZWZvcmVgIOS8muiiq+eUqOS6juWQjumdoueahCBgYmlkYCDlh73mlbDvvJoKICAgIC8vIOaWsOeahOWHveaVsOS9k+aYr+eUsSBtb2RpZmllciDmnKzouqvnmoTlh73mlbDkvZPvvIzlhbbkuK1gX2Dooqvml6fnmoTlh73mlbDkvZPmiYDlj5bku6PjgIIKICAgIG1vZGlmaWVyIG9ubHlCZWZvcmUodWludCB0aW1lKSB7CiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA+PSB0aW1lKSByZXZlcnQgVG9vTGF0ZSh0aW1lKTsKICAgICAgICBfOwogICAgfQogICAgbW9kaWZpZXIgb25seUFmdGVyKHVpbnQgdGltZSkgewogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPD0gdGltZSkgcmV2ZXJ0IFRvb0Vhcmx5KHRpbWUpOwogICAgICAgIF87CiAgICB9CgogICAgY29uc3RydWN0b3IoCiAgICAgICAgdWludCBiaWRkaW5nVGltZSwKICAgICAgICB1aW50IHJldmVhbFRpbWUsCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5QWRkcmVzcwogICAgKSB7CiAgICAgICAgYmVuZWZpY2lhcnkgPSBiZW5lZmljaWFyeUFkZHJlc3M7CiAgICAgICAgYmlkZGluZ0VuZCA9IGJsb2NrLnRpbWVzdGFtcCArIGJpZGRpbmdUaW1lOwogICAgICAgIHJldmVhbEVuZCA9IGJpZGRpbmdFbmQgKyByZXZlYWxUaW1lOwogICAgfQoKICAgIC8vLyDlj6/ku6XpgJrov4cgYF9ibGluZGVkQmlkYCA9IGtlY2NhazI1Nih2YWx1ZSwgZmFrZSwgc2VjcmV0KQogICAgLy8vIOiuvue9ruS4gOS4quebsuaLjeOAggogICAgLy8vIOWPquacieWcqOWHuuS7t+aKq+mcsumYtuauteiiq+ato+ehruaKq+mcsu+8jOW3suWPkemAgeeahOS7peWkquW4geaJjeS8muiiq+mAgOi/mOOAggogICAgLy8vIOWmguaenOS4juWHuuS7t+S4gOi1t+WPkemAgeeahOS7peWkquW4geiHs+WwkeS4uiAidmFsdWUiIOS4lCAiZmFrZSIg5LiN5Li655yf77yM5YiZ5Ye65Lu35pyJ5pWI44CCCiAgICAvLy8g5bCGICJmYWtlIiDorr7nva7kuLogdHJ1ZSDvvIwKICAgIC8vLyDnhLblkI7lj5HpgIHmu6HotrPorqLph5Hph5Hpop3kvYblj4jkuI3kuI7lh7rku7fnm7jlkIznmoTph5Hpop3mmK/pmpDol4/lrp7pmYXlh7rku7fnmoTmlrnms5XjgIIKICAgIC8vLyDlkIzkuIDkuKrlnLDlnYDlj6/ku6XmlL7nva7lpJrkuKrlh7rku7fjgIIKICAgIGZ1bmN0aW9uIGJpZChieXRlczMyIGJsaW5kZWRCaWQpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBwYXlhYmxlCiAgICAgICAgb25seUJlZm9yZShiaWRkaW5nRW5kKQogICAgewogICAgICAgIGJpZHNbbXNnLnNlbmRlcl0ucHVzaChCaWQoewogICAgICAgICAgICBibGluZGVkQmlkOiBibGluZGVkQmlkLAogICAgICAgICAgICBkZXBvc2l0OiBtc2cudmFsdWUKICAgICAgICB9KSk7CiAgICB9CgogICAgLy8vIOaKq+mcsuS9oOeahOebsuaLjeWHuuS7t+OAggogICAgLy8vIOWvueS6juaJgOacieato+ehruaKq+mcsueahOaXoOaViOWHuuS7t+S7peWPiumZpOacgOmrmOWHuuS7t+S7peWklueahOaJgOacieWHuuS7t++8jOaCqOmDveWwhuiOt+W+l+mAgOasvuOAggogICAgZnVuY3Rpb24gcmV2ZWFsKAogICAgICAgIHVpbnRbXSBjYWxsZGF0YSB2YWx1ZXMsCiAgICAgICAgYm9vbFtdIGNhbGxkYXRhIGZha2VzLAogICAgICAgIGJ5dGVzMzJbXSBjYWxsZGF0YSBzZWNyZXRzCiAgICApCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5QWZ0ZXIoYmlkZGluZ0VuZCkKICAgICAgICBvbmx5QmVmb3JlKHJldmVhbEVuZCkKICAgIHsKICAgICAgICB1aW50IGxlbmd0aCA9IGJpZHNbbXNnLnNlbmRlcl0ubGVuZ3RoOwogICAgICAgIHJlcXVpcmUodmFsdWVzLmxlbmd0aCA9PSBsZW5ndGgpOwogICAgICAgIHJlcXVpcmUoZmFrZXMubGVuZ3RoID09IGxlbmd0aCk7CiAgICAgICAgcmVxdWlyZShzZWNyZXRzLmxlbmd0aCA9PSBsZW5ndGgpOwoKICAgICAgICB1aW50IHJlZnVuZDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICBCaWQgc3RvcmFnZSBiaWRUb0NoZWNrID0gYmlkc1ttc2cuc2VuZGVyXVtpXTsKICAgICAgICAgICAgKHVpbnQgdmFsdWUsIGJvb2wgZmFrZSwgYnl0ZXMzMiBzZWNyZXQpID0KICAgICAgICAgICAgICAgICAgICAodmFsdWVzW2ldLCBmYWtlc1tpXSwgc2VjcmV0c1tpXSk7CiAgICAgICAgICAgIGlmIChiaWRUb0NoZWNrLmJsaW5kZWRCaWQgIT0ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodmFsdWUsIGZha2UsIHNlY3JldCkpKSB7CiAgICAgICAgICAgICAgICAvLyDlh7rku7fmnKrog73mraPnoa7miqvpnLLjgIIKICAgICAgICAgICAgICAgIC8vIOS4jei/lOi/mOiuoumHkeOAggogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVmdW5kICs9IGJpZFRvQ2hlY2suZGVwb3NpdDsKICAgICAgICAgICAgaWYgKCFmYWtlICYmIGJpZFRvQ2hlY2suZGVwb3NpdCA+PSB2YWx1ZSkgewogICAgICAgICAgICAgICAgaWYgKHBsYWNlQmlkKG1zZy5zZW5kZXIsIHZhbHVlKSkKICAgICAgICAgICAgICAgICAgICByZWZ1bmQgLT0gdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8g5L2/5Y+R6YCB6ICF5LiN5Y+v6IO95YaN5qyh6K6k6aKG5ZCM5LiA56yU6K6i6YeR44CCCiAgICAgICAgICAgIGJpZFRvQ2hlY2suYmxpbmRlZEJpZCA9IGJ5dGVzMzIoMCk7CiAgICAgICAgfQogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIocmVmdW5kKTsKICAgIH0KCiAgICAvLy8g5pKk5Zue5Ye65Lu36L+H6auY55qE56ue5qCH44CCCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIGV4dGVybmFsIHsKICAgICAgICB1aW50IGFtb3VudCA9IHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdOwogICAgICAgIGlmIChhbW91bnQgPiAwKSB7CiAgICAgICAgICAgIC8vIOi/memHjOW+iOmHjeimge+8jOmmluWFiOimgeiuvumbtuWAvOOAggogICAgICAgICAgICAvLyDlm6DkuLrvvIzkvZzkuLrmjqXmlLbosIPnlKjnmoTkuIDpg6jliIbvvIwKICAgICAgICAgICAgLy8g5o6l5pS26ICF5Y+v5Lul5ZyoIGB0cmFuc2ZlcmAg6L+U5Zue5LmL5YmN6YeN5paw6LCD55So6K+l5Ye95pWw44CCCiAgICAgICAgICAgIC8v77yI5Y+v5p+l55yL5LiK6Z2i5YWz5LqOIOadoeS7tiAtPiDlvbHlk40gLT4g5Lqk5LqSIOeahOagh+azqO+8iQogICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IDA7CgogICAgICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICAgICAgfQogICAgfQoKICAgIC8vLyDnu5PmnZ/mi43ljZbvvIzlubbmiormnIDpq5jnmoTlh7rku7flj5HpgIHnu5nlj5fnm4rkurrjgIIKICAgIGZ1bmN0aW9uIGF1Y3Rpb25FbmQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUFmdGVyKHJldmVhbEVuZCkKICAgIHsKICAgICAgICBpZiAoZW5kZWQpIHJldmVydCBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwogICAgICAgIGVtaXQgQXVjdGlvbkVuZGVkKGhpZ2hlc3RCaWRkZXIsIGhpZ2hlc3RCaWQpOwogICAgICAgIGVuZGVkID0gdHJ1ZTsKICAgICAgICBiZW5lZmljaWFyeS50cmFuc2ZlcihoaWdoZXN0QmlkKTsKICAgIH0KCiAgICAvLyDov5nmmK/kuIDkuKogImludGVybmFsIiDlh73mlbDvvIwKICAgIC8vIOaEj+WRs+edgOWug+WPquiDveWcqOacrOWQiOe6pu+8iOaIlue7p+aJv+WQiOe6pu+8ieWGheiiq+iwg+eUqOOAggogICAgZnVuY3Rpb24gcGxhY2VCaWQoYWRkcmVzcyBiaWRkZXIsIHVpbnQgdmFsdWUpIGludGVybmFsCiAgICAgICAgICAgIHJldHVybnMgKGJvb2wgc3VjY2VzcykKICAgIHsKICAgICAgICBpZiAodmFsdWUgPD0gaGlnaGVzdEJpZCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmIChoaWdoZXN0QmlkZGVyICE9IGFkZHJlc3MoMCkpIHsKICAgICAgICAgICAgLy8g6L+U6L+Y5LmL5YmN55qE5pyA6auY5Ye65Lu3CiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW2hpZ2hlc3RCaWRkZXJdICs9IGhpZ2hlc3RCaWQ7CiAgICAgICAgfQogICAgICAgIGhpZ2hlc3RCaWQgPSB2YWx1ZTsKICAgICAgICBoaWdoZXN0QmlkZGVyID0gYmlkZGVyOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">BlindAuction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Bid</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">blindedBid</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">deposit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>beneficiary<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">biddingEnd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">revealEnd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">public </span><span class="nv">ended</span><span class="p">;</span>

<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Bid<span class="p">[])</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>bids<span class="p">;</span>

<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">highestBidder</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">highestBid</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 允许取回以前的竞标。</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pendingReturns<span class="p">;</span>

<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">AuctionEnded</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">winner</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">highestBid</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 描述失败的错误信息。</span>

<span class="w">    </span><span class="c1">/// 该函数被过早调用。</span>
<span class="w">    </span><span class="c1">/// 在 `time` 时间再试一次。</span>
<span class="w">    </span>error<span class="w"> </span>TooEarly<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">time</span><span class="p">);</span>
<span class="w">    </span><span class="c1">/// 该函数被过晚调用。</span>
<span class="w">    </span><span class="c1">/// 它不能在 `time` 时间之后被调用。</span>
<span class="w">    </span>error<span class="w"> </span>TooLate<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">time</span><span class="p">);</span>
<span class="w">    </span><span class="c1">/// 函数 auctionEnd 已经被调用。</span>
<span class="w">    </span>error<span class="w"> </span>AuctionEndAlreadyCalled<span class="p">();</span>

<span class="w">    </span><span class="c1">// 使用 修饰符（modifier） 可以更便捷的校验函数的入参。</span>
<span class="w">    </span><span class="c1">// `onlyBefore` 会被用于后面的 `bid` 函数：</span>
<span class="w">    </span><span class="c1">// 新的函数体是由 modifier 本身的函数体，其中`_`被旧的函数体所取代。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyBefore<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>time<span class="p">)</span><span class="w"> </span>revert<span class="w"> </span>TooLate<span class="p">(</span>time<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyAfter<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>time<span class="p">)</span><span class="w"> </span>revert<span class="w"> </span>TooEarly<span class="p">(</span>time<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">biddingTime</span><span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">revealTime</span><span class="p">,</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>beneficiaryAddress
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>beneficiary<span class="w"> </span><span class="o">=</span><span class="w"> </span>beneficiaryAddress<span class="p">;</span>
<span class="w">        </span>biddingEnd<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>biddingTime<span class="p">;</span>
<span class="w">        </span>revealEnd<span class="w"> </span><span class="o">=</span><span class="w"> </span>biddingEnd<span class="w"> </span><span class="o">+</span><span class="w"> </span>revealTime<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 可以通过 `_blindedBid` = keccak256(value, fake, secret)</span>
<span class="w">    </span><span class="c1">/// 设置一个盲拍。</span>
<span class="w">    </span><span class="c1">/// 只有在出价披露阶段被正确披露，已发送的以太币才会被退还。</span>
<span class="w">    </span><span class="c1">/// 如果与出价一起发送的以太币至少为 &quot;value&quot; 且 &quot;fake&quot; 不为真，则出价有效。</span>
<span class="w">    </span><span class="c1">/// 将 &quot;fake&quot; 设置为 true ，</span>
<span class="w">    </span><span class="c1">/// 然后发送满足订金金额但又不与出价相同的金额是隐藏实际出价的方法。</span>
<span class="w">    </span><span class="c1">/// 同一个地址可以放置多个出价。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">bid</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">blindedBid</span><span class="p">)</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span><span class="kt">payable</span>
<span class="w">        </span>onlyBefore<span class="p">(</span>biddingEnd<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>bids<span class="p">[</span><span class="k">msg.sender</span><span class="p">].</span>push<span class="p">(</span>Bid<span class="p">({</span>
<span class="w">            </span>blindedBid<span class="o">:</span><span class="w"> </span>blindedBid<span class="p">,</span>
<span class="w">            </span>deposit<span class="o">:</span><span class="w"> </span><span class="k">msg.value</span>
<span class="w">        </span><span class="p">}));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 披露你的盲拍出价。</span>
<span class="w">    </span><span class="c1">/// 对于所有正确披露的无效出价以及除最高出价以外的所有出价，您都将获得退款。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">reveal</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>calldata<span class="w"> </span>values<span class="p">,</span>
<span class="w">        </span><span class="kt">bool</span><span class="p">[]</span><span class="w"> </span>calldata<span class="w"> </span>fakes<span class="p">,</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="p">[]</span><span class="w"> </span>calldata<span class="w"> </span>secrets
<span class="w">    </span><span class="p">)</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span>onlyAfter<span class="p">(</span>biddingEnd<span class="p">)</span>
<span class="w">        </span>onlyBefore<span class="p">(</span>revealEnd<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>bids<span class="p">[</span><span class="k">msg.sender</span><span class="p">].</span>length<span class="p">;</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>values<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span>length<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>fakes<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span>length<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>secrets<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span>length<span class="p">);</span>

<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">refund</span><span class="p">;</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>Bid<span class="w"> </span>storage<span class="w"> </span>bidToCheck<span class="w"> </span><span class="o">=</span><span class="w"> </span>bids<span class="p">[</span><span class="k">msg.sender</span><span class="p">][</span>i<span class="p">];</span>
<span class="w">            </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">fake</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">secret</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">                    </span><span class="p">(</span>values<span class="p">[</span>i<span class="p">],</span><span class="w"> </span>fakes<span class="p">[</span>i<span class="p">],</span><span class="w"> </span>secrets<span class="p">[</span>i<span class="p">]);</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>bidToCheck<span class="p">.</span>blindedBid<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span>value<span class="p">,</span><span class="w"> </span>fake<span class="p">,</span><span class="w"> </span>secret<span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 出价未能正确披露。</span>
<span class="w">                </span><span class="c1">// 不返还订金。</span>
<span class="w">                </span><span class="kt">continue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span>refund<span class="w"> </span><span class="o">+=</span><span class="w"> </span>bidToCheck<span class="p">.</span>deposit<span class="p">;</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>fake<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>bidToCheck<span class="p">.</span>deposit<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>value<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>placeBid<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>value<span class="p">))</span>
<span class="w">                    </span>refund<span class="w"> </span><span class="o">-=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// 使发送者不可能再次认领同一笔订金。</span>
<span class="w">            </span>bidToCheck<span class="p">.</span>blindedBid<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes32</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span>refund<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 撤回出价过高的竞标。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pendingReturns<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>amount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 这里很重要，首先要设零值。</span>
<span class="w">            </span><span class="c1">// 因为，作为接收调用的一部分，</span>
<span class="w">            </span><span class="c1">// 接收者可以在 `transfer` 返回之前重新调用该函数。</span>
<span class="w">            </span><span class="c1">//（可查看上面关于 条件 -&gt; 影响 -&gt; 交互 的标注）</span>
<span class="w">            </span>pendingReturns<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>

<span class="w">            </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span>amount<span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 结束拍卖，并把最高的出价发送给受益人。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">auctionEnd</span><span class="p">()</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span>onlyAfter<span class="p">(</span>revealEnd<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>ended<span class="p">)</span><span class="w"> </span>revert<span class="w"> </span>AuctionEndAlreadyCalled<span class="p">();</span>
<span class="w">        </span>emit<span class="w"> </span>AuctionEnded<span class="p">(</span>highestBidder<span class="p">,</span><span class="w"> </span>highestBid<span class="p">);</span>
<span class="w">        </span>ended<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span>beneficiary<span class="p">.</span>transfer<span class="p">(</span>highestBid<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 这是一个 &quot;internal&quot; 函数，</span>
<span class="w">    </span><span class="c1">// 意味着它只能在本合约（或继承合约）内被调用。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">placeBid</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">bidder</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span>
<span class="w">            </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>value<span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>highestBid<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>highestBidder<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 返还之前的最高出价</span>
<span class="w">            </span>pendingReturns<span class="p">[</span>highestBidder<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>highestBid<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span>highestBid<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">        </span>highestBidder<span class="w"> </span><span class="o">=</span><span class="w"> </span>bidder<span class="p">;</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="index-2">
<span id="id6"></span><h3>安全的远程购买<a class="headerlink" href="#index-2" title="此标题的永久链接"></a></h3>
<p>目前，远程购买商品需要多方相互信任。最简单的关系涉及一个卖家和一个买家。
买方希望从卖方那里收到一件物品，卖方希望得到金钱（或等价物）作为回报。
这里面有问题的部分是的运输。没有办法确定物品是否到达买方手中。</p>
<p>有多种方法来解决这个问题，但都有这样或那样的不足之处。
在下面的例子中，双方都要把两倍价值于物品的资金放入合约中作为托管。
只要发生这种情况，钱就会一直锁在合同里面，直到买方确认收到物品。
之后，买方会得到退回的资金（他们押金的一半），卖方得到三倍的资金（他们的押金加上物品的价值）。
这背后的想法是，双方都有动力去解决这个问题，否则他们的钱就会被永远锁定。</p>
<p>这个合约当然不能解决问题，但它概述了如何在合约内使用类似状态机的构造。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgUHVyY2hhc2UgewogICAgdWludCBwdWJsaWMgdmFsdWU7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbGxlcjsKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgYnV5ZXI7CgogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgUmVsZWFzZSwgSW5hY3RpdmUgfQogICAgLy8g54q25oCB5Y+Y6YeP55qE6buY6K6k5YC85piv56ys5LiA5Liq5oiQ5ZGY77yMYFN0YXRlLmNyZWF0ZWRg44CCCiAgICBTdGF0ZSBwdWJsaWMgc3RhdGU7CgogICAgbW9kaWZpZXIgY29uZGl0aW9uKGJvb2wgY29uZGl0aW9uXykgewogICAgICAgIHJlcXVpcmUoY29uZGl0aW9uXyk7CiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8g5Y+q5pyJ5Lmw5pa55Y+v5Lul6LCD55So6L+Z5Liq5Ye95pWw44CCCiAgICBlcnJvciBPbmx5QnV5ZXIoKTsKICAgIC8vLyDlj6rmnInljZbmlrnlj6/ku6XosIPnlKjov5nkuKrlh73mlbDjgIIKICAgIGVycm9yIE9ubHlTZWxsZXIoKTsKICAgIC8vLyDlnKjlvZPliY3nirbmgIHkuIvkuI3og73osIPnlKjor6Xlh73mlbDjgIIKICAgIGVycm9yIEludmFsaWRTdGF0ZSgpOwogICAgLy8vIOaPkOS+m+eahOWAvOW/hemhu+aYr+WBtuaVsOOAggogICAgZXJyb3IgVmFsdWVOb3RFdmVuKCk7CgogICAgbW9kaWZpZXIgb25seUJ1eWVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IGJ1eWVyKQogICAgICAgICAgICByZXZlcnQgT25seUJ1eWVyKCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IHNlbGxlcikKICAgICAgICAgICAgcmV2ZXJ0IE9ubHlTZWxsZXIoKTsKICAgICAgICBfOwogICAgfQoKICAgIG1vZGlmaWVyIGluU3RhdGUoU3RhdGUgc3RhdGVfKSB7CiAgICAgICAgaWYgKHN0YXRlICE9IHN0YXRlXykKICAgICAgICAgICAgcmV2ZXJ0IEludmFsaWRTdGF0ZSgpOwogICAgICAgIF87CiAgICB9CgogICAgZXZlbnQgQWJvcnRlZCgpOwogICAgZXZlbnQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgIGV2ZW50IEl0ZW1SZWNlaXZlZCgpOwogICAgZXZlbnQgU2VsbGVyUmVmdW5kZWQoKTsKCiAgICAvLyDnoa7kv50gYG1zZy52YWx1ZWAg5piv5LiA5Liq5YG25pWw44CCCiAgICAvLyDlpoLmnpzmmK/lpYfmlbDvvIzpmaTms5XkvJrmiKrmlq3jgIIKICAgIC8vIOmAmui/h+S5mOazleajgOafpeWug+S4jeaYr+S4gOS4quWlh+aVsOOAggogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHsKICAgICAgICBzZWxsZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHZhbHVlID0gbXNnLnZhbHVlIC8gMjsKICAgICAgICBpZiAoKDIgKiB2YWx1ZSkgIT0gbXNnLnZhbHVlKQogICAgICAgICAgICByZXZlcnQgVmFsdWVOb3RFdmVuKCk7CiAgICB9CgogICAgLy8vIOe7iOatoui0reS5sOW5tuaUtuWbniBldGhlcuOAggogICAgLy8vIOWPquiDveeUseWNluaWueWcqOWQiOWQjOmUgeWumuWJjeiDveiwg+eUqOOAggogICAgZnVuY3Rpb24gYWJvcnQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seVNlbGxlcgogICAgICAgIGluU3RhdGUoU3RhdGUuQ3JlYXRlZCkKICAgIHsKICAgICAgICBlbWl0IEFib3J0ZWQoKTsKICAgICAgICBzdGF0ZSA9IFN0YXRlLkluYWN0aXZlOwogICAgICAgIC8vIOaIkeS7rOWcqOi/memHjOebtOaOpeS9v+eUqCBgdHJhbnNmZXJg44CCCiAgICAgICAgLy8g5a6D5Y+v5Lul5a6J5YWo5Zyw6YeN5YWl44CCCiAgICAgICAgLy8g5Zug5Li65a6D5piv6L+Z5Liq5Ye95pWw5Lit55qE5pyA5ZCO5LiA5qyh6LCD55So77yMCiAgICAgICAgLy8g6ICM5LiU5oiR5Lus5bey57uP5pS55Y+Y5LqG54q25oCB44CCCiAgICAgICAgc2VsbGVyLnRyYW5zZmVyKGFkZHJlc3ModGhpcykuYmFsYW5jZSk7CiAgICB9CgogICAgLy8vIOS5sOaWueehruiupOi0reS5sOOAggogICAgLy8vIOS6pOaYk+W/hemhu+WMheaLrCBgMiAqIHZhbHVlYCBldGhlcuOAggogICAgLy8vIEV0aGVyIOWwhuiiq+mUgeS9j++8jOebtOWIsOiwg+eUqCBjb25maXJtUmVjZWl2ZWTjgIIKICAgIGZ1bmN0aW9uIGNvbmZpcm1QdXJjaGFzZSgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBpblN0YXRlKFN0YXRlLkNyZWF0ZWQpCiAgICAgICAgY29uZGl0aW9uKG1zZy52YWx1ZSA9PSAoMiAqIHZhbHVlKSkKICAgICAgICBwYXlhYmxlCiAgICB7CiAgICAgICAgZW1pdCBQdXJjaGFzZUNvbmZpcm1lZCgpOwogICAgICAgIGJ1eWVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgICAgICBzdGF0ZSA9IFN0YXRlLkxvY2tlZDsKICAgIH0KCiAgICAvLy8g56Gu6K6k5oKo77yI5Lmw5pa577yJ5bey57uP5pS25Yiw5LqG6K+l54mp5ZOB44CCCiAgICAvLy8g6L+Z5bCG6YeK5pS+6ZSB5a6a55qEIGV0aGVy44CCCiAgICBmdW5jdGlvbiBjb25maXJtUmVjZWl2ZWQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUJ1eWVyCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5Mb2NrZWQpCiAgICB7CiAgICAgICAgZW1pdCBJdGVtUmVjZWl2ZWQoKTsKICAgICAgICAvLyDpppblhYjmlLnlj5jnirbmgIHmmK/lvojph43opoHnmoTvvIzlkKbliJnnmoTor53vvIwKICAgICAgICAvLyDkuIvpnaLkvb/nlKggYHNlbmRgIOiwg+eUqOeahOWQiOe6puWPr+S7peWcqOi/memHjOWGjeasoeiwg+eUqOOAggogICAgICAgIHN0YXRlID0gU3RhdGUuUmVsZWFzZTsKCiAgICAgICAgYnV5ZXIudHJhbnNmZXIodmFsdWUpOwogICAgfQoKICAgIC8vLyDor6Xlip/og73kuLrljZblrrbpgIDmrL7vvIwKICAgIC8vLyDljbPpgIDov5jljZblrrbplIHlrprnmoTotYTph5HjgIIKICAgIGZ1bmN0aW9uIHJlZnVuZFNlbGxlcigpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5U2VsbGVyCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5SZWxlYXNlKQogICAgewogICAgICAgIGVtaXQgU2VsbGVyUmVmdW5kZWQoKTsKICAgICAgICAvLyDpppblhYjmlLnlj5jnirbmgIHmmK/lvojph43opoHnmoTvvIzlkKbliJnnmoTor53vvIwKICAgICAgICAvLyDkuIvpnaLkvb/nlKggYHNlbmRgIOiwg+eUqOeahOWQiOe6puWPr+S7peWcqOi/memHjOWGjeasoeiwg+eUqOOAggogICAgICAgIHN0YXRlID0gU3RhdGUuSW5hY3RpdmU7CgogICAgICAgIHNlbGxlci50cmFuc2ZlcigzICogdmFsdWUpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Purchase</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">value</span><span class="p">;</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>seller<span class="p">;</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>buyer<span class="p">;</span>

<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Created<span class="p">,</span><span class="w"> </span>Locked<span class="p">,</span><span class="w"> </span>Release<span class="p">,</span><span class="w"> </span>Inactive<span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 状态变量的默认值是第一个成员，`State.created`。</span>
<span class="w">    </span>State<span class="w"> </span><span class="kt">public</span><span class="w"> </span>state<span class="p">;</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>condition<span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">condition_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>condition_<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 只有买方可以调用这个函数。</span>
<span class="w">    </span>error<span class="w"> </span>OnlyBuyer<span class="p">();</span>
<span class="w">    </span><span class="c1">/// 只有卖方可以调用这个函数。</span>
<span class="w">    </span>error<span class="w"> </span>OnlySeller<span class="p">();</span>
<span class="w">    </span><span class="c1">/// 在当前状态下不能调用该函数。</span>
<span class="w">    </span>error<span class="w"> </span>InvalidState<span class="p">();</span>
<span class="w">    </span><span class="c1">/// 提供的值必须是偶数。</span>
<span class="w">    </span>error<span class="w"> </span>ValueNotEven<span class="p">();</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyBuyer<span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>buyer<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>OnlyBuyer<span class="p">();</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlySeller<span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>seller<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>OnlySeller<span class="p">();</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>inState<span class="p">(</span>State<span class="w"> </span>state_<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>state<span class="w"> </span><span class="o">!=</span><span class="w"> </span>state_<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>InvalidState<span class="p">();</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Aborted</span><span class="p">();</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">PurchaseConfirmed</span><span class="p">();</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">ItemReceived</span><span class="p">();</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">SellerRefunded</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 确保 `msg.value` 是一个偶数。</span>
<span class="w">    </span><span class="c1">// 如果是奇数，除法会截断。</span>
<span class="w">    </span><span class="c1">// 通过乘法检查它不是一个奇数。</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>seller<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span>value<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">((</span><span class="m m-Decimal">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>value<span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>ValueNotEven<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 终止购买并收回 ether。</span>
<span class="w">    </span><span class="c1">/// 只能由卖方在合同锁定前能调用。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">abort</span><span class="p">()</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span>onlySeller
<span class="w">        </span>inState<span class="p">(</span>State<span class="p">.</span>Created<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>emit<span class="w"> </span>Aborted<span class="p">();</span>
<span class="w">        </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Inactive<span class="p">;</span>
<span class="w">        </span><span class="c1">// 我们在这里直接使用 `transfer`。</span>
<span class="w">        </span><span class="c1">// 它可以安全地重入。</span>
<span class="w">        </span><span class="c1">// 因为它是这个函数中的最后一次调用，</span>
<span class="w">        </span><span class="c1">// 而且我们已经改变了状态。</span>
<span class="w">        </span>seller<span class="p">.</span>transfer<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">).</span>balance<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 买方确认购买。</span>
<span class="w">    </span><span class="c1">/// 交易必须包括 `2 * value` ether。</span>
<span class="w">    </span><span class="c1">/// Ether 将被锁住，直到调用 confirmReceived。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">confirmPurchase</span><span class="p">()</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span>inState<span class="p">(</span>State<span class="p">.</span>Created<span class="p">)</span>
<span class="w">        </span>condition<span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="m m-Decimal">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>value<span class="p">))</span>
<span class="w">        </span><span class="kt">payable</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>emit<span class="w"> </span>PurchaseConfirmed<span class="p">();</span>
<span class="w">        </span>buyer<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Locked<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 确认您（买方）已经收到了该物品。</span>
<span class="w">    </span><span class="c1">/// 这将释放锁定的 ether。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">confirmReceived</span><span class="p">()</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span>onlyBuyer
<span class="w">        </span>inState<span class="p">(</span>State<span class="p">.</span>Locked<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>emit<span class="w"> </span>ItemReceived<span class="p">();</span>
<span class="w">        </span><span class="c1">// 首先改变状态是很重要的，否则的话，</span>
<span class="w">        </span><span class="c1">// 下面使用 `send` 调用的合约可以在这里再次调用。</span>
<span class="w">        </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Release<span class="p">;</span>

<span class="w">        </span>buyer<span class="p">.</span>transfer<span class="p">(</span>value<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 该功能为卖家退款，</span>
<span class="w">    </span><span class="c1">/// 即退还卖家锁定的资金。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">refundSeller</span><span class="p">()</span>
<span class="w">        </span><span class="kt">external</span>
<span class="w">        </span>onlySeller
<span class="w">        </span>inState<span class="p">(</span>State<span class="p">.</span>Release<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>emit<span class="w"> </span>SellerRefunded<span class="p">();</span>
<span class="w">        </span><span class="c1">// 首先改变状态是很重要的，否则的话，</span>
<span class="w">        </span><span class="c1">// 下面使用 `send` 调用的合约可以在这里再次调用。</span>
<span class="w">        </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Inactive<span class="p">;</span>

<span class="w">        </span>seller<span class="p">.</span>transfer<span class="p">(</span><span class="m m-Decimal">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>value<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id7">
<h3>微支付通道<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<p>在这一节中，我们将学习如何建立一个支付通道的实施实例。
它使用加密签名，使以太币在同一当事人之间的重复转移变得安全、即时，并且没有交易费用。
对于这个例子，我们需要了解如何签名和验证签名，并设置支付通道。</p>
<section id="id8">
<h4>创建和验证签名<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>想象一下，Alice想发送一些以太给Bob，
即Alice是发送方，Bob是接收方。</p>
<p>Alice 只需要在链下发送经过加密签名的信息
(例如通过电子邮件)给Bob，它类似于写支票。</p>
<p>Alice和Bob使用签名来授权交易，这在以太坊的智能合约中是可以实现的。
Alice将建立一个简单的智能合约，让她传输以太币，但她不会自己调用一个函数来启动付款，
而是让Bob来做，从而支付交易费用。</p>
<p>该合约将按以下方式运作：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Alice部署了 <code class="docutils literal notranslate"><span class="pre">ReceiverPays</span></code> 合约，附加了足够的以太币来支付将要进行的付款。</p></li>
<li><p>Alice通过用她的私钥签署一个消息来授权付款。</p></li>
<li><p>Alice将经过加密签名的信息发送给Bob。该信息不需要保密（后面会解释），而且发送机制也不重要。</p></li>
<li><p>Bob通过向智能合约发送签名的信息来索取他的付款，合约验证了信息的真实性，然后释放资金。</p></li>
</ol>
</div></blockquote>
<section id="id9">
<h5>创建签名<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h5>
<p>Alice不需要与以太坊网络交互来签署交易，这个过程是完全离线的。
在本教程中，我们将使用 <a class="reference external" href="https://github.com/ethereum/web3.js">web3.js</a> 和
<a class="reference external" href="https://metamask.io">MetaMask</a> 在浏览器中签署信息。
使用 <a class="reference external" href="https://github.com/ethereum/EIPs/pull/712">EIP-712</a> 中描述的方法，
因为它提供了许多其他安全优势。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">/// 先进行哈希运算使事情变得更容易</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">sha3</span><span class="p">(</span><span class="s2">&quot;message to sign&quot;</span><span class="p">);</span>
<span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">personal</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="nx">hash</span><span class="p">,</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">defaultAccount</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Signed&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">web3.eth.personal.sign</span></code> 把信息的长度加到签名数据中。
由于我们先进行哈希运算，消息的长度总是正好是32字节，
因此这个长度前缀总是相同的。</p>
</div>
</section>
<section id="id10">
<h5>签署内容<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h5>
<p>对于履行付款的合同，签署的信息必须包括：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>收件人的钱包地址。</p></li>
<li><p>要转移的金额。</p></li>
<li><p>重放攻击的保护。</p></li>
</ol>
</div></blockquote>
<p>重放攻击是指一个已签署的信息被重复使用，以获得对第二次交易的授权。
为了避免重放攻击，我们使用与以太坊交易本身相同的技术，
即所谓的nonce，它是一个账户发送的交易数量。
智能合约会检查一个nonce是否被多次使用。</p>
<p>另一种类型的重放攻击可能发生在所有者部署 <code class="docutils literal notranslate"><span class="pre">ReceiverPays</span></code> 合约时，
先进行了一些支付，然后销毁该合约。后来，
他们决定再次部署 <code class="docutils literal notranslate"><span class="pre">RecipientPays</span></code> 合约，
但新的合约不知道以前合约中使用的nonces，所以攻击者可以再次使用旧的信息。</p>
<p>Alice可以通过在消息中包含合约的地址来防止这种攻击，
并且只有包含合约地址本身的消息才会被接受。
您可以在本节末尾的完整合约的 <code class="docutils literal notranslate"><span class="pre">claimPayment()</span></code> 函数的前两行找到这个例子。</p>
</section>
<section id="id11">
<h5>组装参数<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h5>
<p>既然我们已经确定了要在签名信息中包含哪些信息，
我们准备把信息放在一起，进行哈希运算，然后签名。
简单起见，我们把数据连接起来。
<a class="reference external" href="https://github.com/ethereumjs/ethereumjs-abi">ethereumjs-abi</a> 库提供了一个名为 <code class="docutils literal notranslate"><span class="pre">soliditySHA3</span></code> 的函数，
模仿Solidity的 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 函数应用于使用 <code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code> 编码的参数的行为。
这里有一个JavaScript函数，为 <code class="docutils literal notranslate"><span class="pre">ReceiverPays</span></code> 的例子创建了适当的签名。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// recipient， 是应该被支付的地址。</span>
<span class="c1">// amount，单位是 wei, 指定应该发送多少ether。</span>
<span class="c1">// nonce， 可以是任何唯一的数字，以防止重放攻击。</span>
<span class="c1">// contractAddress， 用于防止跨合约的重放攻击。</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">signPayment</span><span class="p">(</span><span class="nx">recipient</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">,</span><span class="w"> </span><span class="nx">nonce</span><span class="p">,</span><span class="w"> </span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;0x&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">abi</span><span class="p">.</span><span class="nx">soliditySHA3</span><span class="p">(</span>
<span class="w">        </span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;address&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="nx">recipient</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">,</span><span class="w"> </span><span class="nx">nonce</span><span class="p">,</span><span class="w"> </span><span class="nx">contractAddress</span><span class="p">]</span>
<span class="w">    </span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="s2">&quot;hex&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">personal</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="nx">hash</span><span class="p">,</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">defaultAccount</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id12">
<h5>在Solidity中恢复信息签名者<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h5>
<p>一般来说，ECDSA的签名由两个参数组成， <code class="docutils literal notranslate"><span class="pre">r</span></code> 和 <code class="docutils literal notranslate"><span class="pre">s</span></code>。
以太坊的签名包括第三个参数 <code class="docutils literal notranslate"><span class="pre">v</span></code> ，您可以用它来验证是哪个账户的私钥被用来签署信息，
以及作为交易的发送者。Solidity 提供了一个内置函数
<a class="reference internal" href="index.html#mathematical-and-cryptographic-functions"><span class="std std-ref">ecrecover</span></a>，
它接受一个消息以及 <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">v</span></code> 参数，然后返回用于签署该消息的地址。</p>
</section>
<section id="id13">
<h5>提取签名参数<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h5>
<p>web3.js 产生的签名是 <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">v</span></code> 的拼接的，
所以第一步是把这些参数分开。您可以在客户端这样做，
但在智能合约内这样做意味着你只需要发送一个签名参数而不是三个。
将一个字节数组分割成它的组成部分是很麻烦的，
所以我们在 <code class="docutils literal notranslate"><span class="pre">splitSignature</span></code> 函数中使用
<a class="reference internal" href="index.html#document-assembly"><span class="doc">inline assembly</span></a> 完成这项工作（本节末尾的完整合约中的第三个函数）。</p>
</section>
<section id="id14">
<h5>计算信息哈希值<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h5>
<p>智能合约需要确切地知道哪些参数用于签名，
因此它必须通过参数重新创建消息，并使用该消息进行签名验证。
在 <code class="docutils literal notranslate"><span class="pre">claimPayment</span></code> 函数中，函数 <code class="docutils literal notranslate"><span class="pre">prefixed</span></code> 和 <code class="docutils literal notranslate"><span class="pre">recoverSigner</span></code> 做了这件事。</p>
</section>
<section id="id15">
<h5>完整的合约<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h5>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBSZWNlaXZlclBheXMgewogICAgYWRkcmVzcyBvd25lciA9IG1zZy5zZW5kZXI7CgogICAgbWFwcGluZyh1aW50MjU2ID0+IGJvb2wpIHVzZWROb25jZXM7CgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHt9CgogICAgZnVuY3Rpb24gY2xhaW1QYXltZW50KHVpbnQyNTYgYW1vdW50LCB1aW50MjU2IG5vbmNlLCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZSghdXNlZE5vbmNlc1tub25jZV0pOwogICAgICAgIHVzZWROb25jZXNbbm9uY2VdID0gdHJ1ZTsKCiAgICAgICAgLy8g6L+Z5bCG6YeN5paw5Yib5bu65Zyo5a6i5oi356uv5LiK562+5ZCN55qE5L+h5oGv44CCCiAgICAgICAgYnl0ZXMzMiBtZXNzYWdlID0gcHJlZml4ZWQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQobXNnLnNlbmRlciwgYW1vdW50LCBub25jZSwgdGhpcykpKTsKCiAgICAgICAgcmVxdWlyZShyZWNvdmVyU2lnbmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSkgPT0gb3duZXIpOwoKICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICB9CgogICAgLy8vIOmUgOavgeWQiOe6puW5tuaUtuWbnuWJqeS9meeahOi1hOmHkeOAggogICAgZnVuY3Rpb24gc2h1dGRvd24oKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IG93bmVyKTsKICAgICAgICBzZWxmZGVzdHJ1Y3QocGF5YWJsZShtc2cuc2VuZGVyKSk7CiAgICB9CgogICAgLy8vIOetvuWQjeaWueazleOAggogICAgZnVuY3Rpb24gc3BsaXRTaWduYXR1cmUoYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykKICAgIHsKICAgICAgICByZXF1aXJlKHNpZy5sZW5ndGggPT0gNjUpOwoKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIC8vIOWJjTMy5Liq5a2X6IqC77yM5Zyo6ZW/5bqm5YmN57yA5LmL5ZCO44CCCiAgICAgICAgICAgIHIgOj0gbWxvYWQoYWRkKHNpZywgMzIpKQogICAgICAgICAgICAvLyDnrKzkuozkuKozMuWtl+iKguOAggogICAgICAgICAgICBzIDo9IG1sb2FkKGFkZChzaWcsIDY0KSkKICAgICAgICAgICAgLy8g5pyA5ZCO5LiA5Liq5a2X6IqC77yI5LiL5LiA5LiqMzLlrZfoioLnmoTnrKzkuIDkuKrlrZfoioLvvInjgIIKICAgICAgICAgICAgdiA6PSBieXRlKDAsIG1sb2FkKGFkZChzaWcsIDk2KSkpCiAgICAgICAgfQoKICAgICAgICByZXR1cm4gKHYsIHIsIHMpOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlY292ZXJTaWduZXIoYnl0ZXMzMiBtZXNzYWdlLCBieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKGFkZHJlc3MpCiAgICB7CiAgICAgICAgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKSA9IHNwbGl0U2lnbmF0dXJlKHNpZyk7CgogICAgICAgIHJldHVybiBlY3JlY292ZXIobWVzc2FnZSwgdiwgciwgcyk7CiAgICB9CgogICAgLy8vIOaehOW7uuS4gOS4quWJjee8gOWTiOW4jOWAvO+8jOS7peaooeS7vyBldGhfc2lnbiDnmoTooYzkuLrjgIIKICAgIGZ1bmN0aW9uIHByZWZpeGVkKGJ5dGVzMzIgaGFzaCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChieXRlczMyKSB7CiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKCJceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XG4zMiIsIGhhc2gpKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">ReceiverPays</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>

<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>usedNonces<span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">claimPayment</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">nonce</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>signature<span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="o">!</span>usedNonces<span class="p">[</span>nonce<span class="p">]);</span>
<span class="w">        </span>usedNonces<span class="p">[</span>nonce<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 这将重新创建在客户端上签名的信息。</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>prefixed<span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>amount<span class="p">,</span><span class="w"> </span>nonce<span class="p">,</span><span class="w"> </span><span class="kt">this</span><span class="p">)));</span>

<span class="w">        </span><span class="kt">require</span><span class="p">(</span>recoverSigner<span class="p">(</span>message<span class="p">,</span><span class="w"> </span>signature<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">);</span>

<span class="w">        </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 销毁合约并收回剩余的资金。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">shutdown</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">);</span>
<span class="w">        </span>selfdestruct<span class="p">(</span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 签名方法。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">splitSignature</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>sig<span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">v</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">r</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>sig<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">65</span><span class="p">);</span>

<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 前32个字节，在长度前缀之后。</span>
<span class="w">            </span>r<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>sig<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">32</span><span class="p">))</span>
<span class="w">            </span><span class="c1">// 第二个32字节。</span>
<span class="w">            </span>s<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>sig<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">64</span><span class="p">))</span>
<span class="w">            </span><span class="c1">// 最后一个字节（下一个32字节的第一个字节）。</span>
<span class="w">            </span>v<span class="w"> </span><span class="o">:=</span><span class="w"> </span>byte<span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>sig<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">96</span><span class="p">)))</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>v<span class="p">,</span><span class="w"> </span>r<span class="p">,</span><span class="w"> </span>s<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">recoverSigner</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">message</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>sig<span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">v</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">r</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>splitSignature<span class="p">(</span>sig<span class="p">);</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span>ecrecover<span class="p">(</span>message<span class="p">,</span><span class="w"> </span>v<span class="p">,</span><span class="w"> </span>r<span class="p">,</span><span class="w"> </span>s<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 构建一个前缀哈希值，以模仿 eth_sign 的行为。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">prefixed</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">hash</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span><span class="s2">&quot;\x19Ethereum Signed Message:\n32&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">hash</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id16">
<h4>编写一个简单的支付通道合约<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>Alice现在建立了一个简单但完整的支付通道的实现。
支付通道使用加密签名来安全、即时地重复转移以太币，
并且没有交易费用。</p>
<section id="id17">
<h5>什么是支付通道？<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h5>
<p>支付通道允许参与者在不使用交易的情况下重复转移以太币。
这意味着，你可以避免与交易相关的延迟和费用。
我们将探讨两方（Alice和Bob）之间一个简单的单向支付通道。它涉及三个步骤：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Alice用以太币为智能合约提供资金。这就 &quot;打开&quot; 了支付通道。</p></li>
<li><p>Alice签署信息，说明欠接收者多少以太币。这个步骤对每一笔付款都要重复进行。</p></li>
<li><p>Bob &quot;关闭&quot; 支付通道，取出他的那部分以太币，并将剩余部分发回给发送方。</p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>只有步骤1和3需要以太坊交易，意味着步骤2中发送方可以通过链下方法（如电子邮件）
向接收方发送加密签名的信息。这意味着只需要两个交易就可以支持任何数量的转移。</p>
</div>
<p>Bob保证会收到他的资金，因为智能合约托管了以太币，
并兑现了一个有效的签名信息。智能合约也强制执行超时，
所以即使接收者拒绝关闭通道，Alice也能保证最终收回她的资金。
由支付通道的参与者决定保持通道的开放时间。对于一个短暂的交易，
如向网吧支付每分钟的网络访问费，支付通道可以保持有限的开放时间。
另一方面，对于经常性的支付，如向雇员支付每小时的工资，
支付渠道可能会保持开放几个月或几年。</p>
</section>
<section id="id18">
<h5>开通支付渠道<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h5>
<p>为了开通支付通道，Alice部署了智能合约，
添加了要托管的以太币，并指定了预期接收者和通道存在的最长时间。
这就是本节末尾合同中的函数 <code class="docutils literal notranslate"><span class="pre">SimplePaymentChannel</span></code>。</p>
</section>
<section id="id19">
<h5>进行支付<a class="headerlink" href="#id19" title="此标题的永久链接"></a></h5>
<p>Alice通过向Bob发送签名信息进行支付。
这一步骤完全在以太坊网络之外进行。
消息由发送方加密签名，然后直接传送给接收方。</p>
<p>每条信息包括以下信息：</p>
<blockquote>
<div><ul class="simple">
<li><p>智能合约的地址，用于防止跨合约重放攻击。</p></li>
<li><p>到目前为止，欠接收方的以太币的总金额。</p></li>
</ul>
</div></blockquote>
<p>一个支付通道只关闭一次，就是在一系列转账结束后。
正因为如此，所发送的签名信息中只有一个能被赎回。
这就是为什么每条签名信息都指定了一个累计的以太币欠款总额，
而不是单个小额支付的金额。接收方自然会选择最新的签名信息来赎回，
因为那是总额最高的签名信息。每个签名信息的nonce不再需要了，
因为智能合约只兑现一个签名信息。
智能合约的地址仍然被用来防止一个支付渠道的签名信息被用于另一个渠道。</p>
<p>下面是经过修改的JavaScript代码，用于对上一节中的信息进行加密签名：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">constructPaymentMessage</span><span class="p">(</span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">abi</span><span class="p">.</span><span class="nx">soliditySHA3</span><span class="p">(</span>
<span class="w">        </span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">]</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">signMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">personal</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span>
<span class="w">        </span><span class="s2">&quot;0x&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">message</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="s2">&quot;hex&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">defaultAccount</span><span class="p">,</span>
<span class="w">        </span><span class="nx">callback</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// contractAddress， 是用来防止跨合同的重放攻击。</span>
<span class="c1">// amount，单位是wei，指定了应该发送多少以太。</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">signPayment</span><span class="p">(</span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">constructPaymentMessage</span><span class="p">(</span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">);</span>
<span class="w">    </span><span class="nx">signMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id20">
<h5>关闭支付通道<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h5>
<p>当Bob准备好接收他的资金时，
是时候通过调用智能合约上的 <code class="docutils literal notranslate"><span class="pre">close</span></code> 函数关闭支付通道了。
关闭通道会向接收者支付欠他们的以太币，并销毁合约，
将任何剩余的以太币送回给Alice。
为了关闭通道，Bob需要提供一个由Alice签名的信息。</p>
<p>智能合约必须验证该消息是否包含发送者的有效签名。
进行这种验证的过程与接收者使用签名的过程相同。
Solidity函数 <code class="docutils literal notranslate"><span class="pre">isValidSignature</span></code> 和 <code class="docutils literal notranslate"><span class="pre">recoverSigner</span></code> 的工作方式
与上一节中的JavaScript对应函数一样，而后者的函数是从 <code class="docutils literal notranslate"><span class="pre">ReceiverPays</span></code> 合约中借用的。</p>
<p>只有支付通道的接收者可以调用 <code class="docutils literal notranslate"><span class="pre">close</span></code> 函数，
他们自然会传递最新的支付信息，因为该信息带有最高的欠款总额。
如果允许发送者调用这个函数，他们可以提供一个金额较低的签名消息，
骗取接收者的欠款。</p>
<p>该函数会验证签名的信息与给定的参数是否相符。
如果一切正常，接收者就会收到他们的那部分以太币，
而剩下的以太币将通过 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 发送给发送者。
您可以在完整的合约中看到 <code class="docutils literal notranslate"><span class="pre">close</span></code> 函数。</p>
</section>
<section id="id21">
<h5>通道到期<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h5>
<p>Bob可以在任何时候关闭支付通道，但如果他们没有这样做，
Alice需要一个方法来收回她的托管资金。在合同部署的时候，设置了一个 <em>到期时间</em>。
一旦达到这个时间，Alice可以调用 <code class="docutils literal notranslate"><span class="pre">claimTimeout</span></code> 来收回她的资金。
您可以在完整的合约中看到 <code class="docutils literal notranslate"><span class="pre">claimTimeout</span></code> 函数。</p>
<p>在这个函数被调用后，Bob不能再接收任何以太。
所以Bob必须在过期前关闭通道，这一点很重要。</p>
</section>
<section id="id22">
<h5>完整的合约<a class="headerlink" href="#id22" title="此标题的永久链接"></a></h5>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBTaW1wbGVQYXltZW50Q2hhbm5lbCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbmRlcjsgICAgICAvLyDlj5HpgIHku5jmrL7nmoTotKbmiLfjgIIKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgcmVjaXBpZW50OyAgIC8vIOaOpeaUtuS7mOasvueahOi0puaIt+OAggogICAgdWludDI1NiBwdWJsaWMgZXhwaXJhdGlvbjsgIC8vIOi2heaXtuaXtumXtO+8jOS7pemYsuaOpeaUtuiAheawuOS4jeWFs+mXreaUr+S7mOmAmumBk+OAggoKICAgIGNvbnN0cnVjdG9yIChhZGRyZXNzIHBheWFibGUgcmVjaXBpZW50QWRkcmVzcywgdWludDI1NiBkdXJhdGlvbikKICAgICAgICBwYXlhYmxlCiAgICB7CiAgICAgICAgc2VuZGVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgICAgICByZWNpcGllbnQgPSByZWNpcGllbnRBZGRyZXNzOwogICAgICAgIGV4cGlyYXRpb24gPSBibG9jay50aW1lc3RhbXAgKyBkdXJhdGlvbjsKICAgIH0KCiAgICAvLy8g5o6l5pS26ICF5Y+v5Lul5Zyo5Lu75L2V5pe25YCZ6YCa6L+H5o+Q5L6b5Y+R6YCB6ICF562+5ZCN55qE6YeR6aKd5p2l5YWz6Zet6YCa6YGT77yMCiAgICAvLy8g5o6l5pS26ICF5bCG6I635b6X6K+l6YeR6aKd77yM5YW25L2Z6YOo5YiG5bCG6L+U5Zue5Y+R6YCB6ICF44CCCiAgICBmdW5jdGlvbiBjbG9zZSh1aW50MjU2IGFtb3VudCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSkgZXh0ZXJuYWwgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSByZWNpcGllbnQpOwogICAgICAgIHJlcXVpcmUoaXNWYWxpZFNpZ25hdHVyZShhbW91bnQsIHNpZ25hdHVyZSkpOwoKICAgICAgICByZWNpcGllbnQudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICBzZWxmZGVzdHJ1Y3Qoc2VuZGVyKTsKICAgIH0KCiAgICAvLy8g5Y+R6YCB6ICF5Y+v5Lul5Zyo5Lu75L2V5pe25YCZ5bu26ZW/5Yiw5pyf5pe26Ze044CCCiAgICBmdW5jdGlvbiBleHRlbmQodWludDI1NiBuZXdFeHBpcmF0aW9uKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IHNlbmRlcik7CiAgICAgICAgcmVxdWlyZShuZXdFeHBpcmF0aW9uID4gZXhwaXJhdGlvbik7CgogICAgICAgIGV4cGlyYXRpb24gPSBuZXdFeHBpcmF0aW9uOwogICAgfQoKICAgIC8vLyDlpoLmnpzovr7liLDotoXml7bml7bpl7TogIzmjqXmlLbogIXmsqHmnInlhbPpl63pgJrpgZPvvIwKICAgIC8vLyDpgqPkuYjku6XlpKrlsLHkvJrooqvph4rmlL7lm57nu5nlj5HpgIHogIXjgIIKICAgIGZ1bmN0aW9uIGNsYWltVGltZW91dCgpIGV4dGVybmFsIHsKICAgICAgICByZXF1aXJlKGJsb2NrLnRpbWVzdGFtcCA+PSBleHBpcmF0aW9uKTsKICAgICAgICBzZWxmZGVzdHJ1Y3Qoc2VuZGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKHVpbnQyNTYgYW1vdW50LCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKQogICAgICAgIGludGVybmFsCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgYnl0ZXMzMiBtZXNzYWdlID0gcHJlZml4ZWQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodGhpcywgYW1vdW50KSkpOwoKICAgICAgICAvLyDmo4Dmn6Xnrb7lkI3mmK/lkKbmnaXoh6rku5jmrL7mlrnjgIIKICAgICAgICByZXR1cm4gcmVjb3ZlclNpZ25lcihtZXNzYWdlLCBzaWduYXR1cmUpID09IHNlbmRlcjsKICAgIH0KCiAgICAvLy8g5LiL6Z2i55qE5omA5pyJ5Yqf6IO95piv5Y+W6IeqICfliJvlu7rlkozpqozor4Hnrb7lkI0nIOeahOeroOiKguOAggoKICAgIGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKGJ5dGVzIG1lbW9yeSBzaWcpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludDggdiwgYnl0ZXMzMiByLCBieXRlczMyIHMpCiAgICB7CiAgICAgICAgcmVxdWlyZShzaWcubGVuZ3RoID09IDY1KTsKCiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyDliY0zMuS4quWtl+iKgu+8jOWcqOmVv+W6puWJjee8gOS5i+WQjuOAggogICAgICAgICAgICByIDo9IG1sb2FkKGFkZChzaWcsIDMyKSkKICAgICAgICAgICAgLy8g56ys5LqM5LiqMzLlrZfoioLjgIIKICAgICAgICAgICAgcyA6PSBtbG9hZChhZGQoc2lnLCA2NCkpCiAgICAgICAgICAgIC8vIOacgOWQjuS4gOS4quWtl+iKgu+8iOS4i+S4gOS4qjMy5a2X6IqC55qE56ys5LiA5Liq5a2X6IqC77yJ44CCCiAgICAgICAgICAgIHYgOj0gYnl0ZSgwLCBtbG9hZChhZGQoc2lnLCA5NikpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuICh2LCByLCBzKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZWNvdmVyU2lnbmVyKGJ5dGVzMzIgbWVzc2FnZSwgYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zIChhZGRyZXNzKQogICAgewogICAgICAgICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykgPSBzcGxpdFNpZ25hdHVyZShzaWcpOwoKICAgICAgICByZXR1cm4gZWNyZWNvdmVyKG1lc3NhZ2UsIHYsIHIsIHMpOwogICAgfQoKICAgIC8vLyDmnoTlu7rkuIDkuKrliY3nvIDlk4jluIzlgLzvvIzku6XmqKHku79ldGhfc2lnbueahOihjOS4uuOAggogICAgZnVuY3Rpb24gcHJlZml4ZWQoYnl0ZXMzMiBoYXNoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJ5dGVzMzIpIHsKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoIlx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcbjMyIiwgaGFzaCkpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">SimplePaymentChannel</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>sender<span class="p">;</span><span class="w">      </span><span class="c1">// 发送付款的账户。</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>recipient<span class="p">;</span><span class="w">   </span><span class="c1">// 接收付款的账户。</span>
<span class="w">    </span><span class="kt">uint256</span><span class="w"> </span><span class="k">public </span><span class="nv">expiration</span><span class="p">;</span><span class="w">  </span><span class="c1">// 超时时间，以防接收者永不关闭支付通道。</span>

<span class="w">    </span><span class="kt">constructor</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>recipientAddress<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">duration</span><span class="p">)</span>
<span class="w">        </span><span class="kt">payable</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>sender<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span>recipient<span class="w"> </span><span class="o">=</span><span class="w"> </span>recipientAddress<span class="p">;</span>
<span class="w">        </span>expiration<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>duration<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 接收者可以在任何时候通过提供发送者签名的金额来关闭通道，</span>
<span class="w">    </span><span class="c1">/// 接收者将获得该金额，其余部分将返回发送者。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">close</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>signature<span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>recipient<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>isValidSignature<span class="p">(</span>amount<span class="p">,</span><span class="w"> </span>signature<span class="p">));</span>

<span class="w">        </span>recipient<span class="p">.</span>transfer<span class="p">(</span>amount<span class="p">);</span>
<span class="w">        </span>selfdestruct<span class="p">(</span>sender<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 发送者可以在任何时候延长到期时间。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">extend</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">newExpiration</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>sender<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>newExpiration<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>expiration<span class="p">);</span>

<span class="w">        </span>expiration<span class="w"> </span><span class="o">=</span><span class="w"> </span>newExpiration<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 如果达到超时时间而接收者没有关闭通道，</span>
<span class="w">    </span><span class="c1">/// 那么以太就会被释放回给发送者。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">claimTimeout</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>expiration<span class="p">);</span>
<span class="w">        </span>selfdestruct<span class="p">(</span>sender<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">isValidSignature</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>signature<span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>view
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>prefixed<span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span><span class="kt">this</span><span class="p">,</span><span class="w"> </span>amount<span class="p">)));</span>

<span class="w">        </span><span class="c1">// 检查签名是否来自付款方。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>recoverSigner<span class="p">(</span>message<span class="p">,</span><span class="w"> </span>signature<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>sender<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 下面的所有功能是取自 &#39;创建和验证签名&#39; 的章节。</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">splitSignature</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>sig<span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">v</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">r</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>sig<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">65</span><span class="p">);</span>

<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 前32个字节，在长度前缀之后。</span>
<span class="w">            </span>r<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>sig<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">32</span><span class="p">))</span>
<span class="w">            </span><span class="c1">// 第二个32字节。</span>
<span class="w">            </span>s<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>sig<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">64</span><span class="p">))</span>
<span class="w">            </span><span class="c1">// 最后一个字节（下一个32字节的第一个字节）。</span>
<span class="w">            </span>v<span class="w"> </span><span class="o">:=</span><span class="w"> </span>byte<span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>sig<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">96</span><span class="p">)))</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>v<span class="p">,</span><span class="w"> </span>r<span class="p">,</span><span class="w"> </span>s<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">recoverSigner</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">message</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>sig<span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">v</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">r</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>splitSignature<span class="p">(</span>sig<span class="p">);</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span>ecrecover<span class="p">(</span>message<span class="p">,</span><span class="w"> </span>v<span class="p">,</span><span class="w"> </span>r<span class="p">,</span><span class="w"> </span>s<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 构建一个前缀哈希值，以模仿eth_sign的行为。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">prefixed</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">hash</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span><span class="s2">&quot;\x19Ethereum Signed Message:\n32&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">hash</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>函数 <code class="docutils literal notranslate"><span class="pre">splitSignature</span></code> 并没有使用所有的安全检查。
真正的实现应该使用更严格的测试库，例如openzepplin的
<a class="reference external" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol">这个版本</a>
的这个代码。</p>
</div>
</section>
<section id="id24">
<h5>验证付款<a class="headerlink" href="#id24" title="此标题的永久链接"></a></h5>
<p>不同与上一节，支付通道中的信息不会马上被兑换。
接收者会跟踪最新的信息，并在关闭支付通道的时候赎回它。
这意味着接收者对每条信息进行自行验证是至关重要的。
否则就不能保证接收者最终能够得到付款。</p>
<p>接收者应使用以下程序验证每条信息：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>验证签名信息中的合约地址是否与支付通道相符。</p></li>
<li><p>验证新的总额是否为预期的数额。</p></li>
<li><p>确认新的总额不超过代管的以太币数额。</p></li>
<li><p>验证签名是否有效，是否来自于支付通道的发送方。</p></li>
</ol>
</div></blockquote>
<p>我们将使用 <a class="reference external" href="https://github.com/ethereumjs/ethereumjs-util">ethereumjs-util</a>
库来编写这个验证。最后一步可以用多种方式完成，我们使用JavaScript。
下面的代码借用了上面 <strong>JavaScript代码</strong> 中加密签名的 <code class="docutils literal notranslate"><span class="pre">constructPaymentMessage</span></code> 函数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这模拟了eth_sign 的JSON-RPC构建前缀的方法。</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">prefixed</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">ethereumjs</span><span class="p">.</span><span class="nx">ABI</span><span class="p">.</span><span class="nx">soliditySHA3</span><span class="p">(</span>
<span class="w">        </span><span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;bytes32&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="s2">&quot;\x19Ethereum Signed Message:\n32&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">]</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">recoverSigner</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">signature</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">split</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ethereumjs</span><span class="p">.</span><span class="nx">Util</span><span class="p">.</span><span class="nx">fromRpcSig</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">publicKey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ethereumjs</span><span class="p">.</span><span class="nx">Util</span><span class="p">.</span><span class="nx">ecrecover</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">split</span><span class="p">.</span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">split</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">split</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">signer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ethereumjs</span><span class="p">.</span><span class="nx">Util</span><span class="p">.</span><span class="nx">pubToAddress</span><span class="p">(</span><span class="nx">publicKey</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="s2">&quot;hex&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">signer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">isValidSignature</span><span class="p">(</span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">,</span><span class="w"> </span><span class="nx">signature</span><span class="p">,</span><span class="w"> </span><span class="nx">expectedSigner</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">prefixed</span><span class="p">(</span><span class="nx">constructPaymentMessage</span><span class="p">(</span><span class="nx">contractAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">));</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">signer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">recoverSigner</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">signature</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">signer</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span><span class="w"> </span><span class="o">==</span>
<span class="w">        </span><span class="nx">ethereumjs</span><span class="p">.</span><span class="nx">Util</span><span class="p">.</span><span class="nx">stripHexPrefix</span><span class="p">(</span><span class="nx">expectedSigner</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="index-3">
<span id="id25"></span><h3>模块化合约<a class="headerlink" href="#index-3" title="此标题的永久链接"></a></h3>
<p>用模块化的方法来构建您的合约，可以帮助减少复杂性，提高可读性，
这将有助于在开发和代码审查中发现错误和漏洞。
如果您单独指定且控制每个模块的行为，您必须考虑的相互作用只是模块之间的相互作用，
而不是合约的其他每个灵活模块函数。
在下面的例子中，合约使用 <code class="docutils literal notranslate"><span class="pre">Balances</span></code> <a class="reference internal" href="index.html#libraries"><span class="std std-ref">库</span></a> 的 <code class="docutils literal notranslate"><span class="pre">move</span></code> 方法
来检查地址之间发送的余额是否符合您的期望。通过这种方式， <code class="docutils literal notranslate"><span class="pre">Balances</span></code> 库提供了一个独立的组件，
可以正确地跟踪账户的余额。
很容易验证 <code class="docutils literal notranslate"><span class="pre">Balances</span></code> 库永远不会产生负的余额或溢出，
所有余额的总和在合约的有效期内是一个不变的量。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKbGlicmFyeSBCYWxhbmNlcyB7CiAgICBmdW5jdGlvbiBtb3ZlKG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBzdG9yYWdlIGJhbGFuY2VzLCBhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBpbnRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShiYWxhbmNlc1tmcm9tXSA+PSBhbW91bnQpOwogICAgICAgIHJlcXVpcmUoYmFsYW5jZXNbdG9dICsgYW1vdW50ID49IGJhbGFuY2VzW3RvXSk7CiAgICAgICAgYmFsYW5jZXNbZnJvbV0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VzW3RvXSArPSBhbW91bnQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBiYWxhbmNlczsKICAgIHVzaW5nIEJhbGFuY2VzIGZvciAqOwogICAgbWFwcGluZyhhZGRyZXNzID0+IG1hcHBpbmcgKGFkZHJlc3MgPT4gdWludDI1NikpIGFsbG93ZWQ7CgogICAgZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBcHByb3ZhbChhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHNwZW5kZXIsIHVpbnQgYW1vdW50KTsKCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHRvLCB1aW50IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgYmFsYW5jZXMubW92ZShtc2cuc2VuZGVyLCB0bywgYW1vdW50KTsKICAgICAgICBlbWl0IFRyYW5zZmVyKG1zZy5zZW5kZXIsIHRvLCBhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwoKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlckZyb20oYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgcmVxdWlyZShhbGxvd2VkW2Zyb21dW21zZy5zZW5kZXJdID49IGFtb3VudCk7CiAgICAgICAgYWxsb3dlZFtmcm9tXVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXMubW92ZShmcm9tLCB0bywgYW1vdW50KTsKICAgICAgICBlbWl0IFRyYW5zZmVyKGZyb20sIHRvLCBhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50IHRva2VucykgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgcmVxdWlyZShhbGxvd2VkW21zZy5zZW5kZXJdW3NwZW5kZXJdID09IDAsICIiKTsKICAgICAgICBhbGxvd2VkW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gdG9rZW5zOwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgdG9rZW5zKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcyB0b2tlbk93bmVyKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQgYmFsYW5jZSkgewogICAgICAgIHJldHVybiBiYWxhbmNlc1t0b2tlbk93bmVyXTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>Balances<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">move</span><span class="p">(</span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span>storage<span class="w"> </span>balances<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">from</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>balances<span class="p">[</span>from<span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>balances<span class="p">[</span>to<span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>amount<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>balances<span class="p">[</span>to<span class="p">]);</span>
<span class="w">        </span>balances<span class="p">[</span>from<span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>balances<span class="p">[</span>to<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span>balances<span class="p">;</span>
<span class="w">    </span>using<span class="w"> </span>Balances<span class="w"> </span><span class="kt">for</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">))</span><span class="w"> </span>allowed<span class="p">;</span>

<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">from</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Approval</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">spender</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>balances<span class="p">.</span>move<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span>emit<span class="w"> </span>Transfer<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>

<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferFrom</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">from</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>allowed<span class="p">[</span>from<span class="p">][</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span>allowed<span class="p">[</span>from<span class="p">][</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>balances<span class="p">.</span>move<span class="p">(</span>from<span class="p">,</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span>emit<span class="w"> </span>Transfer<span class="p">(</span>from<span class="p">,</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">approve</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">spender</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">tokens</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>allowed<span class="p">[</span><span class="k">msg.sender</span><span class="p">][</span>spender<span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="w">        </span>allowed<span class="p">[</span><span class="k">msg.sender</span><span class="p">][</span>spender<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>tokens<span class="p">;</span>
<span class="w">        </span>emit<span class="w"> </span>Approval<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>spender<span class="p">,</span><span class="w"> </span>tokens<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">tokenOwner</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>balances<span class="p">[</span>tokenOwner<span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-layout-of-source-files"></span><section id="solidity">
<h2>Solidity 源文件结构<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h2>
<p>源文件可以包含任意数量的
<a class="reference internal" href="index.html#contract-structure"><span class="std std-ref">contract 定义</span></a>, <a class="reference internal" href="#import">import</a> 指令,
<a class="reference internal" href="#pragma"><span class="std std-ref">pragma</span></a> 指令和 <a class="reference internal" href="index.html#using-for"><span class="std std-ref">using for</span></a> 指令
和 <a class="reference internal" href="index.html#structs"><span class="std std-ref">struct</span></a>, <a class="reference internal" href="index.html#enums"><span class="std std-ref">enum</span></a>, <a class="reference internal" href="index.html#functions"><span class="std std-ref">function</span></a>, <a class="reference internal" href="index.html#errors"><span class="std std-ref">error</span></a>
以及 <a class="reference internal" href="index.html#constants"><span class="std std-ref">constant 变量</span></a> 的定义。</p>
<section id="spdx">
<span id="index-0"></span><h3>SPDX 许可标识符<a class="headerlink" href="#spdx" title="此标题的永久链接"></a></h3>
<p>如果智能合约的源代码是公开的，就可以更好地建立对智能合约的信任。
由于提供源代码总是涉及到版权方面的法律问题，
Solidity 编译器鼓励使用机器可读的 <a class="reference external" href="https://spdx.org">SPDX 许可标识符</a> 。
每个源文件都应该以一个注释开始，表明其许可证</p>
<p><code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">SPDX-License-Identifier:</span> <span class="pre">MIT</span></code></p>
<p>编译器不会验证许可证是否属于 <a class="reference external" href="https://spdx.org/licenses/">SPDX许可的列表</a>，
但它确实包括在 <a class="reference internal" href="index.html#metadata"><span class="std std-ref">字节码元数据（bytecode metadata）</span></a> 提供的字符串中。</p>
<p>如果您不想指定一个许可，或者源代码不是开源的，
请使用特殊值 <code class="docutils literal notranslate"><span class="pre">UNLICENSED</span></code>。请注意， <code class="docutils literal notranslate"><span class="pre">UNLICENSED</span></code> （不允许使用，
不存在于SPDX许可证列表中）与 <code class="docutils literal notranslate"><span class="pre">UNLICENSE</span></code> （授予所有人所有权利）不同。
Solidity 遵循 <a class="reference external" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license">npm 的推荐</a>。</p>
<p>提供这个注释并不能使您摆脱与许可有关的其他义务，
如必须在每个源文件中提到特定的许可头或原始版权人。</p>
<p>编译器可以在文件的任何位置识别该注释，
但建议把它放在文件的顶部。</p>
<p>关于如何使用 SPDX 许可证标识的更多信息可以在 <a class="reference external" href="https://spdx.org/ids-how">SPDX 网站</a> 中找到。</p>
</section>
<section id="pragma">
<span id="index-1"></span><span id="id4"></span><h3>编译指示<a class="headerlink" href="#pragma" title="此标题的永久链接"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pragma</span></code> 关键字用于启用某些编译器特性或检查。
一个 pragma 指令始终是源文件的本地指令，
所以如果您想在整个项目中使用 pragma 指令，
您必须在您的所有文件中添加这个指令。
如果您 <a class="reference internal" href="#import"><span class="std std-ref">import</span></a> 另一个文件，
该文件的 pragma 指令 <em>不会</em> 自动应用于导入文件。</p>
<section id="version-pragma">
<span id="index-2"></span><span id="id5"></span><h4>版本编译指示<a class="headerlink" href="#version-pragma" title="此标题的永久链接"></a></h4>
<p>源文件可以（而且应该）用版本 pragma 指令来注释，
以拒绝用未来的编译器版本进行编译，因为这可能会引入不兼容的变化。
我们力图把这类变更做到尽可能小，
我们需要以一种当修改语义时必须同步修改语法的方式引入变更，
当然这有时候也难以做到。正因为如此，
至少在包含重大变化的版本中，通读一下更新日志总是一个好主意。
这些版本总是有 <code class="docutils literal notranslate"><span class="pre">0.x.0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">x.0.0</span></code> 形式的版本。</p>
<p>版本编译指示使用如下： <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">solidity</span> <span class="pre">^0.5.2;</span></code></p>
<p>带有上述代码的源文件在 0.5.2 版本之前的编译器上不能编译，
在 0.6.0 版本之后的编译器上也不能工作（这第二个条件是通过使用 <code class="docutils literal notranslate"><span class="pre">^</span></code> 添加的）。
因为在 <code class="docutils literal notranslate"><span class="pre">0.6.0</span></code> 版本之前不会有任何重大的变化，
所以您可以确信您的代码是按照您的预期编译的。
上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。</p>
<p>可以为编译器版本指定更复杂的规则，
这些规则与 <a class="reference external" href="https://docs.npmjs.com/cli/v6/using-npm/semver">npm</a> 使用相同的语法。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>使用版本 pragma 指令 <em>不会</em> 改变编译器的版本。
它也 <em>不会</em> 启用或禁用编译器的功能。
它只是指示编译器检查它的版本是否与编译指示所要求的版本一致。
如果不匹配，编译器会发出一个错误。</p>
</div>
</section>
<section id="abi">
<span id="abi-coder"></span><span id="index-3"></span><h4>ABI编码编译指示<a class="headerlink" href="#abi" title="此标题的永久链接"></a></h4>
<p>通过使用 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v2</span></code> ，
您可以选择ABI编码器和解码器的两种实现。</p>
<p>新的 ABI 编码器（v2）能够对任意嵌套的数组和结构进行编码和解码。
除了支持更多的类型外，它还涉及更广泛的验证和安全检查，
这可能导致更高的气体成本，但也提高了安全性。
从 Solidity 0.6.0 开始，它被认为是非实验性的，
并且从 Solidity 0.8.0 开始，它被默认启用。
旧的 ABI 编码器仍然可以使用 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v1;</span></code> 来选择。</p>
<p>新编码器所支持的类型集是旧编码器所支持的类型的一个严格超集。
使用新编码器的合约可以与不使用新编码器的合约进行交互，没有任何限制。
只有当非 <code class="docutils literal notranslate"><span class="pre">abicoder</span> <span class="pre">v2</span></code> 的合约不试图进行需要解码新编码器支持的类型的调用时，
才有可能出现相反的情况。
编译器可以检测到这一点，并会发出一个错误。
只要为您的合同启用 <code class="docutils literal notranslate"><span class="pre">abicoder</span> <span class="pre">v2</span></code> ，就足以使错误消失。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这个编译指示适用于激活它的文件中定义的所有代码，
无论这些代码最终在哪里结束。这意味着，
一个合约的源文件被选择用 ABI 编码器v1编译，
它仍然可以包含通过从另一个合约继承来使用新编码器的代码。
如果新类型只在内部使用，而不是在外部函数签名中使用，
这是被允许的。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>到 Solidity 0.7.4 为止，可以通过使用 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">ABIEncoderV2</span></code>
来选择 ABI 编码器v2，但不可能明确选择编码器v1，因为它是默认的。</p>
</div>
</section>
<section id="experimental-pragma">
<span id="index-4"></span><span id="id7"></span><h4>实验性编译指示<a class="headerlink" href="#experimental-pragma" title="此标题的永久链接"></a></h4>
<p>第二个编译指示是实验性的编译指示。
它可以用来启用编译器或语言中尚未默认启用的功能。
目前支持以下实验性编译指示：</p>
<section id="abi-v2">
<span id="index-5"></span><h5>ABI 编码器 V2<a class="headerlink" href="#abi-v2" title="此标题的永久链接"></a></h5>
<p>因为 ABI 编码器v2不再被认为是实验性的，
它可以通过 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v2</span></code> （请见上文）从 Solidity 0.7.4 开始选择。</p>
</section>
<section id="smt">
<span id="smt-checker"></span><span id="index-6"></span><h5>SMT检查器<a class="headerlink" href="#smt" title="此标题的永久链接"></a></h5>
<p>这个组件必须在构建 Solidity 编译器时被启用，
因此它不是在所有 Solidity 二进制文件中都可用。
<a class="reference internal" href="index.html#smt-solvers-build"><span class="std std-ref">构建说明</span></a> 解释了如何激活这个选项。
它在大多数版本中为 Ubuntu PPA 版本激活，
但不用于 Docker 镜像、Windows 二进制文件或静态构建的 Linux 二进制文件。
如果您在本地安装了SMT检查器并通过节点（而不是通过浏览器）运行 solc-js，
可以通过 <a class="reference external" href="https://github.com/ethereum/solc-js#example-usagewith-smtsolver-callback">smtCallback</a>
为 solc-js 激活它。</p>
<p>如果您使用 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">SMTChecker;</span></code>，
那么您会得到额外的 <a class="reference internal" href="index.html#formal-verification"><span class="std std-ref">安全警告</span></a>。
这些警告是通过查询SMT求解器获得的。
该组件还不支持 Solidity 语言的所有功能，可能会输出许多警告。
如果它报告不支持的功能，那么分析可能不完全正确。</p>
</section>
</section>
</section>
<section id="import">
<span id="index-7"></span><span id="id8"></span><h3>导入其他源文件<a class="headerlink" href="#import" title="此标题的永久链接"></a></h3>
<section id="id9">
<h4>语法与语义<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>Solidity 支持导入语句，以帮助模块化您的代码，
这些语句与 JavaScript 中可用的语句相似(从ES6开始)。
然而，Solidity 并不支持 <a class="reference external" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#Description">默认导出</a>
的概念。</p>
<p>在全局层面，您可以使用以下形式的导入语句：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICJmaWxlbmFtZSI7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;filename&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">filename</span></code> 部分被称为 <em>导入路径</em>。
该语句将所有来自 “filename” 的全局符号（以及在那里导入的符号）
导入到当前的全局范围（与ES6中不同，但对Solidity来说是向后兼容的）。
这种形式不建议使用，因为它不可预测地污染了命名空间。
如果您在 “filename” 里面添加新的顶层项目，
它们会自动出现在所有像这样从 “filename” 导入的文件中。
最好是明确地导入特定的符号。</p>
<p>下面的例子创建了一个新的全局符号 <code class="docutils literal notranslate"><span class="pre">symbolName</span></code>，其成员均来自 <code class="docutils literal notranslate"><span class="pre">&quot;filename&quot;</span></code> 中全局符号；</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICogYXMgc3ltYm9sTmFtZSBmcm9tICJmaWxlbmFtZSI7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>as<span class="w"> </span>symbolName<span class="w"> </span>from<span class="w"> </span><span class="s2">&quot;filename&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>这意味着所有全局符号以 <code class="docutils literal notranslate"><span class="pre">symbolName.symbol</span></code> 的格式提供。</p>
<p>另一种语法不属于 ES6，但可能是有用的：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICJmaWxlbmFtZSIgYXMgc3ltYm9sTmFtZTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;filename&quot;</span><span class="w"> </span>as<span class="w"> </span>symbolName<span class="p">;</span>
</pre></div>
</div>
<p>这条语句等同于 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span> <span class="pre">as</span> <span class="pre">symbolName</span> <span class="pre">from</span> <span class="pre">&quot;filename&quot;;</span></code>。</p>
<p>如果有命名冲突，您可以在导入的同时重命名符号。
例如，下面的代码创建了新的全局符号 <code class="docutils literal notranslate"><span class="pre">alias</span></code> 和 <code class="docutils literal notranslate"><span class="pre">symbol2</span></code>，
它们分别从 <code class="docutils literal notranslate"><span class="pre">&quot;filename&quot;</span></code> 里面引用 <code class="docutils literal notranslate"><span class="pre">symbol1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">symbol2</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0IHtzeW1ib2wxIGFzIGFsaWFzLCBzeW1ib2wyfSBmcm9tICJmaWxlbmFtZSI7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="p">{</span>symbol1<span class="w"> </span>as<span class="w"> </span>alias<span class="p">,</span><span class="w"> </span>symbol2<span class="p">}</span><span class="w"> </span>from<span class="w"> </span><span class="s2">&quot;filename&quot;</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="index-8">
<span id="id11"></span><h4>导入路径<a class="headerlink" href="#index-8" title="此标题的永久链接"></a></h4>
<p>为了能够在所有平台上支持可重复的构建，
Solidity 编译器必须抽象出存储源文件的文件系统的细节。
由于这个原因，导入路径并不直接指向主机文件系统中的文件。
相反，编译器维护一个内部数据库（ <em>虚拟文件系统</em> 或简称 <em>VFS</em> ），
每个源单元被分配一个唯一的 <em>源单元名称</em>，
这是一个不透明的、非结构化的标识。
在导入语句中指定的导入路径被转译成源单元名称，并用于在这个数据库中找到相应的源单元。</p>
<p>使用 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准 JSON</span></a> API，
可以直接提供所有源文件的名称和内容作为编译器输入的一部分。
在这种情况下，源单元的名称确实是任意的。
然而，如果您想让编译器自动查找并将源代码加载到VFS中，
您的源单元名称需要以一种结构化的方式，使 <a class="reference internal" href="index.html#import-callback"><span class="std std-ref">回调引用</span></a> 能够定位它们。
当使用命令行编译器时，默认的回调引用只支持从主机文件系统加载源代码，
这意味着您的源单元名称必须是路径。一些环境提供了自定义的回调，其用途更广。
例如， <a class="reference external" href="https://remix.ethereum.org/">Remix IDE</a> 提供了一个可以让您
<a class="reference external" href="https://remix-ide.readthedocs.io/en/latest/import.html">从HTTP、IPFS和Swarm URL导入文件，或者直接引用NPM注册表中的包</a>。</p>
<p>关于虚拟文件系统和编译器使用的路径解析逻辑的完整描述，请参见 <a class="reference internal" href="index.html#path-resolution"><span class="std std-ref">路径解析</span></a>。</p>
</section>
</section>
<section id="index-9">
<span id="id12"></span><h3>注释<a class="headerlink" href="#index-9" title="此标题的永久链接"></a></h3>
<p>可以使用单行注释（ <code class="docutils literal notranslate"><span class="pre">//</span></code> ）和多行注释（ <code class="docutils literal notranslate"><span class="pre">/*...*/</span></code> ）</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8g6L+Z5piv5LiA5Liq5Y2V6KGM5rOo6YeK44CCCgovKgrov5nmmK/kuIDkuKoK5aSa6KGM5rOo6YeK44CCCiov"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这是一个单行注释。</span>

<span class="cm">/*</span>
<span class="cm">这是一个</span>
<span class="cm">多行注释。</span>
<span class="cm">*/</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>单行注释由 UTF-8 编码中的任何单码行结束符（LF、VF、FF、CR、NEL、LS 或 PS）结束。
终结符在注释之后仍然是源代码的一部分，
所以如果它不是一个 ASCII 符号（这些是 NEL、LS 和 PS），将导致解析器错误。</p>
</div>
<p>此外，还有一种注释叫做 NatSpec 注释，在 <a class="reference internal" href="index.html#style-guide-natspec"><span class="std std-ref">格式指南</span></a> 中详细说明。
它们用三斜线（ <code class="docutils literal notranslate"><span class="pre">///</span></code> ）或双星号块（ <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">...</span> <span class="pre">*/</span></code> ）来写，
它们应该直接用在函数声明或语句的上方。</p>
</section>
</section>
<span id="document-structure-of-a-contract"></span><section id="contract-structure">
<span id="index-0"></span><span id="id1"></span><h2>合约结构<a class="headerlink" href="#contract-structure" title="此标题的永久链接"></a></h2>
<p>在 Solidity 中，合约类似于面向对象编程语言中的类。
每个合约中可以包含 <a class="reference internal" href="#structure-state-variables"><span class="std std-ref">状态变量</span></a>， <a class="reference internal" href="#structure-functions"><span class="std std-ref">函数</span></a>，
<a class="reference internal" href="#structure-function-modifiers"><span class="std std-ref">函数修饰器</span></a>， <a class="reference internal" href="#structure-events"><span class="std std-ref">事件</span></a>，
<a class="reference internal" href="#structure-errors"><span class="std std-ref">错误</span></a>， <a class="reference internal" href="#structure-struct-types"><span class="std std-ref">结构类型</span></a>
和 <a class="reference internal" href="#structure-enum-types"><span class="std std-ref">枚举类型</span></a> 的声明，且合约可以从其他合约继承。</p>
<p>还有一些特殊种类的合同，叫做 <a class="reference internal" href="index.html#libraries"><span class="std std-ref">库合约</span></a> 和 <a class="reference internal" href="index.html#interfaces"><span class="std std-ref">接口合约</span></a>。</p>
<p>在关于 <a class="reference internal" href="index.html#contracts"><span class="std std-ref">合约</span></a> 的部分包含比本节更多的细节，它的作用是提供一个快速的概述。</p>
<section id="structure-state-variables">
<span id="id2"></span><h3>状态变量<a class="headerlink" href="#structure-state-variables" title="此标题的永久链接"></a></h3>
<p>状态变量是指其值被永久地存储在合约存储中的变量。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlU3RvcmFnZSB7CiAgICB1aW50IHN0b3JlZERhdGE7IC8vIOeKtuaAgeWPmOmHjwogICAgLy8gLi4uCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleStorage</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">storedData</span><span class="p">;</span><span class="w"> </span><span class="c1">// 状态变量</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有效的状态变量类型请参阅 <a class="reference internal" href="index.html#types"><span class="std std-ref">类型</span></a> 章节，
对状态变量可见性的可能选择请参阅 <a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">可见性和 getter 函数</span></a>。</p>
</section>
<section id="structure-functions">
<span id="id3"></span><h3>函数<a class="headerlink" href="#structure-functions" title="此标题的永久链接"></a></h3>
<p>函数是代码的可执行单位。
通常在合约内定义函数，但它们也可以被定义在合约之外。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICBmdW5jdGlvbiBiaWQoKSBwdWJsaWMgcGF5YWJsZSB7IC8vIOWHveaVsAogICAgICAgIC8vIC4uLgogICAgfQp9CgovLyDlrprkuYnlnKjlkIjnuqbkuYvlpJbnmoTovoXliqnlh73mlbAKZnVuY3Rpb24gaGVscGVyKHVpbnQgeCkgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICByZXR1cm4geCAqIDI7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleAuction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">bid</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 函数</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 定义在合约之外的辅助函数</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">helper</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="index.html#function-calls"><span class="std std-ref">函数调用</span></a> 可以发生在内部或外部，
并且对其他合约有不同程度的 <a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">可见性</span></a>。
<a class="reference internal" href="index.html#functions"><span class="std std-ref">函数</span></a> 接受参数并返回变量，以便在它们之间传递参数和值。</p>
</section>
<section id="structure-function-modifiers">
<span id="id4"></span><h3>函数修饰器<a class="headerlink" href="#structure-function-modifiers" title="此标题的永久链接"></a></h3>
<p>函数修饰器可以被用来以声明的方式修改函数的语义(见合约部分的 <a class="reference internal" href="index.html#modifiers"><span class="std std-ref">函数修饰器</span></a>)。</p>
<p>重载，也就是具有同一个修饰器的名字但有不同的参数，是不可能的。</p>
<p>与函数一样，修饰器也可以被 <a class="reference internal" href="index.html#modifier-overriding"><span class="std std-ref">重载</span></a>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IFB1cmNoYXNlIHsKICAgIGFkZHJlc3MgcHVibGljIHNlbGxlcjsKCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgeyAvLyDkv67ppbDlmagKICAgICAgICByZXF1aXJlKAogICAgICAgICAgICBtc2cuc2VuZGVyID09IHNlbGxlciwKICAgICAgICAgICAgIk9ubHkgc2VsbGVyIGNhbiBjYWxsIHRoaXMuIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBhYm9ydCgpIHB1YmxpYyB2aWV3IG9ubHlTZWxsZXIgeyAvLyDkv67ppbDlmajnmoTkvb/nlKgKICAgICAgICAvLyAuLi4KICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Purchase</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">seller</span><span class="p">;</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlySeller<span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 修饰器</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>seller<span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;Only seller can call this.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">abort</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span>onlySeller<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 修饰器的使用</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="structure-events">
<span id="id5"></span><h3>事件<a class="headerlink" href="#structure-events" title="此标题的永久链接"></a></h3>
<p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZUF1Y3Rpb24gewogICAgZXZlbnQgSGlnaGVzdEJpZEluY3JlYXNlZChhZGRyZXNzIGJpZGRlciwgdWludCBhbW91bnQpOyAvLyDkuovku7YKCiAgICBmdW5jdGlvbiBiaWQoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gLi4uCiAgICAgICAgZW1pdCBIaWdoZXN0QmlkSW5jcmVhc2VkKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSk7IC8vIOinpuWPkeS6i+S7tgogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.21</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleAuction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">HighestBidIncreased</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">bidder</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span><span class="w"> </span><span class="c1">// 事件</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">bid</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span>emit<span class="w"> </span>HighestBidIncreased<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span><span class="w"> </span><span class="c1">// 触发事件</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 <a class="reference internal" href="index.html#events"><span class="std std-ref">事件</span></a>。</p>
</section>
<section id="structure-errors">
<span id="id6"></span><h3>错误<a class="headerlink" href="#structure-errors" title="此标题的永久链接"></a></h3>
<p>错误(类型)允许您为失败情况定义描述性的名称和数据。
错误(类型)可以在 <a class="reference internal" href="index.html#revert-statement"><span class="std std-ref">回滚声明</span></a> 中使用。
与字符串描述相比，错误(类型)要便宜得多，并允许您对额外的数据进行编码。
您可以使用 NatSpec 格式来向用户描述错误。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDmsqHmnInotrPlpJ/nmoTotYTph5HnlKjkuo7ovazotKbjgILopoHmsYIgYHJlcXVlc3RlZGDjgIIKLy8vIOS9huWPquaciSBgYXZhaWxhYmxlYCDlj6/nlKjjgIIKZXJyb3IgTm90RW5vdWdoRnVuZHModWludCByZXF1ZXN0ZWQsIHVpbnQgYXZhaWxhYmxlKTsKCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlczsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBwdWJsaWMgewogICAgICAgIHVpbnQgYmFsYW5jZSA9IGJhbGFuY2VzW21zZy5zZW5kZXJdOwogICAgICAgIGlmIChiYWxhbmNlIDwgYW1vdW50KQogICAgICAgICAgICByZXZlcnQgTm90RW5vdWdoRnVuZHMoYW1vdW50LCBiYWxhbmNlKTsKICAgICAgICBiYWxhbmNlc1ttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXNbdG9dICs9IGFtb3VudDsKICAgICAgICAvLyAuLi4KICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="c1">/// 没有足够的资金用于转账。要求 `requested`。</span>
<span class="c1">/// 但只有 `available` 可用。</span>
error<span class="w"> </span>NotEnoughFunds<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">requested</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">available</span><span class="p">);</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>balances<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>balance<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>amount<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>NotEnoughFunds<span class="p">(</span>amount<span class="p">,</span><span class="w"> </span>balance<span class="p">);</span>
<span class="w">        </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>balances<span class="p">[</span>to<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>更多信息请参阅合约章节中的 <a class="reference internal" href="index.html#errors"><span class="std std-ref">错误和恢复语句</span></a>。</p>
</section>
<section id="structure-struct-types">
<span id="id7"></span><h3>结构类型<a class="headerlink" href="#structure-struct-types" title="此标题的永久链接"></a></h3>
<p>结构类型是可以将几个变量分组的自定义类型（参阅类型章节中的 <a class="reference internal" href="index.html#structs"><span class="std std-ref">结构体</span></a>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQmFsbG90IHsKICAgIHN0cnVjdCBWb3RlciB7IC8vIOe7k+aehAogICAgICAgIHVpbnQgd2VpZ2h0OwogICAgICAgIGJvb2wgdm90ZWQ7CiAgICAgICAgYWRkcmVzcyBkZWxlZ2F0ZTsKICAgICAgICB1aW50IHZvdGU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Ballot</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Voter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 结构</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">weight</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nv">voted</span><span class="p">;</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">delegate</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">vote</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="structure-enum-types">
<span id="id8"></span><h3>枚举类型<a class="headerlink" href="#structure-enum-types" title="此标题的永久链接"></a></h3>
<p>枚举可用来创建由一定数量的'常量值'构成的自定义类型（参阅类型章节中的 <a class="reference internal" href="index.html#enums"><span class="std std-ref">枚举类型</span></a>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgUHVyY2hhc2UgewogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgSW5hY3RpdmUgfSAvLyDmnprkuL4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Purchase</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Created<span class="p">,</span><span class="w"> </span>Locked<span class="p">,</span><span class="w"> </span>Inactive<span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// 枚举</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<span id="document-types"></span><section id="types">
<span id="index-0"></span><span id="id1"></span><h2>类型<a class="headerlink" href="#types" title="此标题的永久链接"></a></h2>
<p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定。
Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p>
<p>除此之外，各个类型之间可以在包含运算符号的表达式中进行交互。
关于各种运算符的快速参考，可以参考 <a class="reference internal" href="#order"><span class="std std-ref">运算符的优先顺序</span></a>。</p>
<p>Solidity中不存在&quot;未定义&quot;或&quot;空&quot;值的概念，
但新声明的变量总是有一个取决于其类型的 <a class="reference internal" href="index.html#default-value"><span class="std std-ref">默认值</span></a>。
为了处理任何意外的值，您应该使用 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">revert 函数</span></a> 来恢复整个事务，
或者返回一个带有第二个 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 值的元组来表示成功。</p>
<section id="value-types">
<span id="index-1"></span><span id="id2"></span><h3>值类型<a class="headerlink" href="#value-types" title="此标题的永久链接"></a></h3>
<p>以下类型也称为值类型，因为这些类型的变量将始终按值来传递。
也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。</p>
<section id="index-2">
<span id="id3"></span><h4>布尔类型<a class="headerlink" href="#index-2" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">bool</span></code> ：可能的取值为常数值 <code class="docutils literal notranslate"><span class="pre">true</span></code> 和 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<p>运算符：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!</span></code> (逻辑非)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (逻辑与, &quot;and&quot;)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">||</span></code> (逻辑或, &quot;or&quot;)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">==</span></code> (等于)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!=</span></code> (不等于)</p></li>
</ul>
<p>运算符 <code class="docutils literal notranslate"><span class="pre">||</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> 都遵循同样的短路（ short-circuiting ）规则。
就是说在表达式 <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">||</span> <span class="pre">g(y)</span></code> 中， 如果 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">true</span></code> ，
那么 <code class="docutils literal notranslate"><span class="pre">g(y)</span></code> 就不会被执行，即使会出现一些副作用。</p>
</section>
<section id="integers">
<span id="index-3"></span><span id="id4"></span><h4>整型<a class="headerlink" href="#integers" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">int</span></code> / <code class="docutils literal notranslate"><span class="pre">uint</span></code>: 分别表示有符号和无符号的不同位数的整型变量。
关键字 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 到 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> （无符号整型，从 8 位到 256 位）以及 <code class="docutils literal notranslate"><span class="pre">int8</span></code> 到 <code class="docutils literal notranslate"><span class="pre">int256</span></code>，
以 8 位为步长递增。 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int</span></code> 分别是 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int256</span></code> 的别名。</p>
<p>运算符：</p>
<ul class="simple">
<li><p>比较运算符： <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> （返回布尔值）</p></li>
<li><p>位运算符： <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>， <code class="docutils literal notranslate"><span class="pre">|</span></code>， <code class="docutils literal notranslate"><span class="pre">^</span></code> (异或)， <code class="docutils literal notranslate"><span class="pre">~</span></code> (位取反)</p></li>
<li><p>移位运算符： <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> （左移）， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> （右移）</p></li>
<li><p>算数运算符： <code class="docutils literal notranslate"><span class="pre">+</span></code>， <code class="docutils literal notranslate"><span class="pre">-</span></code>， 一元运算 <code class="docutils literal notranslate"><span class="pre">-</span></code> （只适用于有符号的整数）， <code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code> (取余)， <code class="docutils literal notranslate"><span class="pre">**</span></code> (幂)</p></li>
</ul>
<p>对于一个整数类型 <code class="docutils literal notranslate"><span class="pre">X</span></code>，您可以使用 <code class="docutils literal notranslate"><span class="pre">type(X).min</span></code> 和 <code class="docutils literal notranslate"><span class="pre">type(X).max</span></code> 来访问该类型代表的最小值和最大值。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Solidity 中的整数被限制在一个特定的范围内。例如，对于 <code class="docutils literal notranslate"><span class="pre">uint32</span></code>，这是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">2**32</span> <span class="pre">-</span> <span class="pre">1</span></code>。
有两种模式在这些类型上进行算术。“包装” 或 “未检查” 模式和 “检查” 模式。
默认情况下，算术总是 “检查” 模式的，这意味着如果一个操作的结果超出了该类型的值范围，
调用将通过一个 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">失败的断言</span></a> 而被恢复。
您可以用 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>。 更多的细节可以在关于 <a class="reference internal" href="index.html#unchecked"><span class="std std-ref">未检查</span></a> 的章节中找到。</p>
</div>
<section id="id5">
<h5>比较运算<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h5>
<p>比较的值是通过比较整数值得到的值。</p>
</section>
<section id="id6">
<h5>位运算<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h5>
<p>位操作是在数字的二进制补码表示上进行的。
这意味着，例如 <code class="docutils literal notranslate"><span class="pre">~int256(0)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code>。</p>
</section>
<section id="id7">
<h5>移位运算<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h5>
<p>移位操作的结果具有左操作数的类型，将结果截断以符合类型。
右操作数必须是无符号类型，试图对有符号类型进行移位会产生一个编译错误。</p>
<p>移位可以通过以下方式用2的幂的乘法来 &quot;模拟&quot;。
请注意，对左边操作数类型的截断总是在最后进行，但没有明确提及。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code> 等同于数学表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2**y</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> 等同于数学表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code>，向负无穷远的方向取整。</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">0.5.0</span></code> 版本之前，负数 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的右移 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> 相当于数学表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code> 向零舍入，
即右移使用向上舍入（向零舍入）而不是向下舍入（向负无穷大）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>就像对算术操作那样，对移位操作从不进行溢出检查。相反，结果总是被截断的。</p>
</div>
</section>
<section id="id8">
<h5>加法、减法和乘法<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h5>
<p>加法、减法和乘法具有通常的语义，在上溢和下溢方面有两种不同的模式：</p>
<p>默认情况下，所有的算术都会被检查是否有下溢或上溢，但这可以用 <a class="reference internal" href="index.html#unchecked"><span class="std std-ref">未检查限制</span></a> 来禁用。
这会导致包装的算术。更多细节可以在那一节中找到。</p>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">-x</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">(T(0)</span> <span class="pre">-</span> <span class="pre">x)</span></code>，其中
<code class="docutils literal notranslate"><span class="pre">T</span></code> 是 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的类型。它只能用于有符号的类型。
如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是负的， <code class="docutils literal notranslate"><span class="pre">-x</span></code> 的值就是正的。
还有一个注意事项也是由二进制补码表示产生的：</p>
<p>如果您有（这样的表达式） <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">type(int).min;</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">-x</span></code> 就不符合正数范围。
这意味着 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">assert(-x</span> <span class="pre">==</span> <span class="pre">x);</span> <span class="pre">}</span></code> 可以工作，
而表达式 <code class="docutils literal notranslate"><span class="pre">-x</span></code> 在检查模式下使用时将导致断言失败。</p>
</section>
<section id="id9">
<h5>除法<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h5>
<p>由于运算结果的类型总是操作数之一的类型，整数除法的结果总是一个整数。
在 Solidity 中，除法是向零进位的。这意味着 <code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">/</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(-2)</span></code>。</p>
<p>请注意，与此相反，在 <a class="reference internal" href="#rational-literals"><span class="std std-ref">字面上</span></a> 的除法会产生任意精度的分数值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>除以0会导致 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">异常</span></a>。这个检查 <strong>不能</strong> 通过 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 禁用。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">type(int).min</span> <span class="pre">/</span> <span class="pre">(-1)</span></code> 是除法导致溢出的唯一情况。
在检查算术模式下，这将导致一个失败的断言，
而在包装模式下，值将是 <code class="docutils literal notranslate"><span class="pre">type(int).min</span></code>。</p>
</div>
</section>
<section id="id10">
<h5>取余<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h5>
<p>模数运算 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">n</span></code> 是操作数 <code class="docutils literal notranslate"><span class="pre">a</span></code> 除以操作数 <code class="docutils literal notranslate"><span class="pre">n</span></code> 后产生余数 <code class="docutils literal notranslate"><span class="pre">r</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">int(a</span> <span class="pre">/</span> <span class="pre">n)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">-</span> <span class="pre">(n</span> <span class="pre">*</span> <span class="pre">q)</span></code>。
这意味着模数运算的结果与它的左边操作数（或零）相同，
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">-(-a</span> <span class="pre">%</span> <span class="pre">n)</span></code> 对负的 <code class="docutils literal notranslate"><span class="pre">a</span></code> 来说成立。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int256(5)</span> <span class="pre">%</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int256(5)</span> <span class="pre">%</span> <span class="pre">int256(-2)</span> <span class="pre">==</span> <span class="pre">int256(1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">%</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">%</span> <span class="pre">int256(-2)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对0取余会导致 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">异常</span></a>。这个检查 <strong>不能</strong> 通过 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 禁用。</p>
</div>
</section>
<section id="id11">
<h5>幂运算<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h5>
<p>幂运算只适用于指数中的无符号类型。幂运算的结果类型总是等于基数的类型。
请注意，它要足够大以容纳结果，并为潜在的断言失败或包装行为做好准备。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在检查模式下，幂运算只对小基数使用相对便宜的 <code class="docutils literal notranslate"><span class="pre">exp</span></code> 操作码。
对于 <code class="docutils literal notranslate"><span class="pre">x**3</span></code> 的情况，表达式 <code class="docutils literal notranslate"><span class="pre">x*x*x</span></code> 可能更便宜。
在任何情况下，气体成本测试和使用优化器都是可取的。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">0**0</span></code> 被EVM定义为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
</div>
</section>
</section>
<section id="index-4">
<span id="id12"></span><h4>定长浮点型<a class="headerlink" href="#index-4" title="此标题的永久链接"></a></h4>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，
但不能给它们赋值或把它们赋值给其他变量。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fixed</span></code> / <code class="docutils literal notranslate"><span class="pre">ufixed</span></code>：表示各种大小的有符号和无符号的定长浮点型。
在关键字 <code class="docutils literal notranslate"><span class="pre">ufixedMxN</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fixedMxN</span></code> 中， <code class="docutils literal notranslate"><span class="pre">M</span></code> 表示该类型占用的位数，
<code class="docutils literal notranslate"><span class="pre">N</span></code> 表示可用的小数位数。 <code class="docutils literal notranslate"><span class="pre">M</span></code> 必须能整除 8，即 8 到 256 位。
<code class="docutils literal notranslate"><span class="pre">N</span></code> 则可以是从 0 到 80 之间的任意数。 <code class="docutils literal notranslate"><span class="pre">ufixed</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fixed</span></code> 分别是 <code class="docutils literal notranslate"><span class="pre">ufixed128x18</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fixed128x18</span></code> 的别名。</p>
<p>运算符：</p>
<ul class="simple">
<li><p>比较运算符： <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> （返回值是布尔型）</p></li>
<li><p>算术运算符： <code class="docutils literal notranslate"><span class="pre">+</span></code>， <code class="docutils literal notranslate"><span class="pre">-</span></code>， 一元运算 <code class="docutils literal notranslate"><span class="pre">-</span></code>， <code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code> (取余数)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>浮点型（在许多语言中的 <code class="docutils literal notranslate"><span class="pre">float</span></code> 和 <code class="docutils literal notranslate"><span class="pre">double</span></code> ，更准确地说是 IEEE 754 类型）和定长浮点型之间最大的不同点是，
在前者中整数部分和小数部分（小数点后的部分）需要的位数是灵活可变的，而后者中这两部分的长度受到严格的规定。
一般来说，在浮点型中，几乎整个空间都用来表示数字，但只有少数的位来表示小数点的位置。</p>
</div>
</section>
<section id="address">
<span id="index-5"></span><span id="id13"></span><h4>地址类型<a class="headerlink" href="#address" title="此标题的永久链接"></a></h4>
<p>地址类型有两种，大体上是相同的：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code>: 保存一个20字节的值（一个以太坊地址的大小）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>: 与 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型相同，但有额外的方法 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">send</span></code>。</p></li>
</ul>
<p>这种区别背后的想法是， <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 是一个您可以发送以太币的地址，
而您不应该发送以太币给一个普通的 <code class="docutils literal notranslate"><span class="pre">address</span></code>，例如，因为它可能是一个智能合约，
而这个合约不是为接受以太币而建立的。</p>
<p>类型转换：</p>
<p>允许从 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 到 <code class="docutils literal notranslate"><span class="pre">address</span></code> 的隐式转换，
而从 <code class="docutils literal notranslate"><span class="pre">address</span></code> 到 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 的转换必须通过 <code class="docutils literal notranslate"><span class="pre">payable(&lt;address&gt;)</span></code> 来明确。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">uint160</span></code>、整数、 <code class="docutils literal notranslate"><span class="pre">bytes20</span></code> 和合约类型，允许对 <code class="docutils literal notranslate"><span class="pre">address</span></code> 进行明确的转换和输出。</p>
<p>只有 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型和合约类型的表达式可以通过 <code class="docutils literal notranslate"><span class="pre">payable(...)</span></code> 显式转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型。
对于合约类型，只有在合约可以接收以太的情况下才允许这种转换，也就是说，
合约要么有一个 <a class="reference internal" href="index.html#receive-ether-function"><span class="std std-ref">receive</span></a> 函数，要么有一个 payable 类型的 fallback 的函数。
请注意， <code class="docutils literal notranslate"><span class="pre">payable(0)</span></code> 是有效的，是这个规则的例外。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您需要一个 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型的变量，并计划向其发送以太，那么就将其类型声明为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，
以使这一要求可行。另外，尽量尽早地进行这种区分或转换。</p>
<p><code class="docutils literal notranslate"><span class="pre">address</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 之间的区别是从 0.5.0 版本开始的。
同样从该版本开始，合约不能隐式地转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，但仍然可以显式地转换为
<code class="docutils literal notranslate"><span class="pre">address</span></code> 或 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，如果它们有一个 receive 或 payable 类型的 fallback 函数的话。</p>
</div>
<p>运算符：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果您使用较大字节的类型转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code>，例如 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">address</span></code> 就被截断了。
为了减少转换的模糊性，从 0.4.24 版本开始，编译器将强迫您在转换中明确地进行截断处理。以32字节的值
<code class="docutils literal notranslate"><span class="pre">0x111122333344556677888899AAAABBBBCCCCDDDDEEFFFFCCCC</span></code> 为例。</p>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">address(uint160(bytes20(b)))</span></code>，结果是 <code class="docutils literal notranslate"><span class="pre">0x111122223333444455556666777788889999aAaa</span></code>，
或者您可以使用 <code class="docutils literal notranslate"><span class="pre">address(uint160(uint256(b)))</span></code>，结果是 <code class="docutils literal notranslate"><span class="pre">0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>符合 <a class="reference external" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a> 的混合大小写十六进制数字会自动被视为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型的字面数字。参见 <a class="reference internal" href="#address-literals"><span class="std std-ref">地址字面类型</span></a>。</p>
</div>
<section id="members-of-addresses">
<span id="id14"></span><h5>地址类型成员变量<a class="headerlink" href="#members-of-addresses" title="此标题的永久链接"></a></h5>
<p>快速参考，请见 <a class="reference internal" href="index.html#address-related"><span class="std std-ref">地址类型的成员</span></a>。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">balance</span></code> 和 <code class="docutils literal notranslate"><span class="pre">transfer</span></code></p></li>
</ul>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">balance</span></code> 属性来查询一个地址的以太币余额，
也可以使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 函数向一个地址发送以太币（以 wei 为单位）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="mh">0x123</span><span class="p">);</span>
<span class="kt">address</span><span class="w"> </span><span class="nv">myAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">);</span>
<span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="p">.</span>balance<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>myAddress<span class="p">.</span>balance<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span><span class="w"> </span>x<span class="p">.</span>transfer<span class="p">(</span><span class="m m-Decimal">10</span><span class="p">);</span>
</pre></div>
</div>
<p>如果当前合约的余额不足，或者以太币转账被接收账户拒绝，那么 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 功能就会失败。
<code class="docutils literal notranslate"><span class="pre">transfer</span></code> 功能在失败后会被还原。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是一个合约地址，它的代码（更具体地说：它的 <a class="reference internal" href="index.html#receive-ether-function"><span class="std std-ref">接收以太的函数</span></a>，如果有的话，
或者它的 <a class="reference internal" href="index.html#fallback-function"><span class="std std-ref">Fallback 函数</span></a>，如果有的话）将与 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 调用一起执行（这是EVM的一个特性，无法阻止）。
如果执行过程中耗尽了气体或出现了任何故障，以太币的转移将被还原，当前的合约将以异常的方式停止。</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">send</span></code></p></li>
</ul>
<p>Send是 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 的低级对应部分。如果执行失败，当前的合约不会因异常而停止，但 <code class="docutils literal notranslate"><span class="pre">send</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 有一些危险：如果调用堆栈深度为1024，传输就会失败（这可以由调用者强制执行），
如果接收者的气体耗尽，也会失败。因此，为了安全地进行以太币转账，
一定要检查 <code class="docutils literal notranslate"><span class="pre">send</span></code> 的返回值，或者使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code>，甚至使用更好的方式：
使用收款人提款的模式。</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">call</span></code>, <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code></p></li>
</ul>
<p>为了与不遵守ABI的合约对接，或者为了更直接地控制编码，
我们提供了 <code class="docutils literal notranslate"><span class="pre">call</span></code>, <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 函数。
它们都接受一个 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> 参数，并返回成功条件（作为一个 <code class="docutils literal notranslate"><span class="pre">bool</span></code>）
和返回的数据（ <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code>）。
函数 <code class="docutils literal notranslate"><span class="pre">abi.encode</span></code>, <code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code>, <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector</span></code>
和 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSignature</span></code> 可以用来编码结构化的数据。</p>
<p>示例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>payload<span class="w"> </span><span class="o">=</span><span class="w"> </span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">);</span>
<span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>returnData<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">(</span>payload<span class="p">);</span>
<span class="kt">require</span><span class="p">(</span>success<span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>所有这些函数都是低级别的函数，应该谨慎使用。
具体来说，任何未知的合约都可能是恶意的，如果您调用它，
您就把控制权交给了该合约，而该合约又可能回调到您的合约中，
所以要准备好在调用返回时改变您合约的状态变量。
与其他合约互动的常规方法是在合约对象上调用一个函数（ <code class="docutils literal notranslate"><span class="pre">x.f()</span></code>）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>以前的 Solidity 版本允许这些函数接收任意的参数，
并且也会以不同的方式处理 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 类型的第一个参数。
这些边缘情况在0.5.0版本中被移除。</p>
</div>
<p>可以用 <code class="docutils literal notranslate"><span class="pre">gas</span></code> 修饰器来调整所提供的气体：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">{</span>gas<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">1000000</span><span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>同样，所提供的以太值也可以被控制：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">{</span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>最后，这些修饰器可以合并。它们的顺序并不重要：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">{</span>gas<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">1000000</span><span class="p">,</span><span class="w"> </span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>以类似的方式，可以使用函数 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>：不同的是，它只使用给定地址的代码，
所有其他方面（存储，余额，...）都取自当前的合约。
<code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 的目的是为了使用存储在另一个合约中的库代码。
用户必须确保两个合约中的存储结构都适合使用delegatecall。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 homestead 版本之前，只有一个功能类似但作用有限的 <code class="docutils literal notranslate"><span class="pre">callcode</span></code> 的函数可用，
但它不能获取委托方的 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code>。这个功能在 0.5.0 版本中被移除。</p>
</div>
<p>从 byzantium 开始，也可以使用 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code>。这基本上与 <code class="docutils literal notranslate"><span class="pre">call</span></code> 相同，
但如果被调用的函数以任何方式修改了状态，则会恢复。</p>
<p>这三个函数 <code class="docutils literal notranslate"><span class="pre">call</span></code>， <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 都是非常低级的函数，
只应该作为 <em>最后的手段</em> 来使用，因为它们破坏了Solidity的类型安全。</p>
<p><code class="docutils literal notranslate"><span class="pre">gas</span></code> 选项在所有三种方法中都可用，而 <code class="docutils literal notranslate"><span class="pre">value</span></code> 选项只在 <code class="docutils literal notranslate"><span class="pre">call</span></code> 中可用。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>最好避免在您的智能合约代码中依赖硬编码的气体值，无论状态是读出还是写入，
因为这可能有很多隐患。另外，对气体的访问在未来可能会改变。</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">code</span></code> 和 <code class="docutils literal notranslate"><span class="pre">codehash</span></code></p></li>
</ul>
<p>您可以查询任何智能合约的部署代码。使用 <code class="docutils literal notranslate"><span class="pre">.code</span></code> 获得作为 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> 的EVM字节码，
这可能是空的。使用 <code class="docutils literal notranslate"><span class="pre">.codehash</span></code> 获得该代码的Keccak-256哈希值（作为 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>）。
注意，使用 <code class="docutils literal notranslate"><span class="pre">addr.codehash</span></code> 比 <code class="docutils literal notranslate"><span class="pre">keccak256(addr.code)</span></code> 更便宜。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>所有的合约都可以转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，所以可以用 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 查询当前合约的余额。</p>
</div>
</section>
</section>
<section id="contract-types">
<span id="index-6"></span><span id="id15"></span><h4>合约类型<a class="headerlink" href="#contract-types" title="此标题的永久链接"></a></h4>
<p>每个 <a class="reference internal" href="index.html#contracts"><span class="std std-ref">合约</span></a> 都定义了自己的类型。
您可以隐式地将一个合约转换为它们所继承的另一个合约。
合约可以显式地转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，也可以从 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型中转换。</p>
<p>只有在合约类型具有 receive 或 payable 类型的 fallback 函数的情况下，
才有可能明确转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型和从该类型转换。
这种转换仍然使用 <code class="docutils literal notranslate"><span class="pre">address(x)</span></code> 进行转换。如果合约类型没有一个 receive 或 payable 类型的 fallback 函数，
可以使用 <code class="docutils literal notranslate"><span class="pre">payable(address(x))</span></code> 来转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 。
您可以在 <a class="reference internal" href="#address"><span class="std std-ref">地址类型</span></a> 一节中找到更多信息。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.5.0 版本之前，合约直接从地址类型派生出来，
并且在 <code class="docutils literal notranslate"><span class="pre">address</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 之间没有区别。</p>
</div>
<p>如果您声明了一个本地类型的变量（ <code class="docutils literal notranslate"><span class="pre">MyContract</span> <span class="pre">c</span></code> ），您可以调用该合约上的函数。
注意要从相同合约类型的地方将其赋值。</p>
<p>您也可以实例化合约（这意味着它们是新创建的）。
您可以在 <a class="reference internal" href="index.html#creating-contracts"><span class="std std-ref">'通过关键字new创建合约'</span></a> 部分找到更多细节。</p>
<p>合约的数据表示与 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型相同，该类型也用于 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a>。</p>
<p>合约不支持任何运算符。</p>
<p>合约类型的成员是合约的外部函数，包括任何标记为 <code class="docutils literal notranslate"><span class="pre">public</span></code> 的状态变量。</p>
<p>对于一个合约 <code class="docutils literal notranslate"><span class="pre">C</span></code>，您可以使用 <code class="docutils literal notranslate"><span class="pre">type(C)</span></code> 来访问
关于该合约的 <a class="reference internal" href="index.html#meta-type"><span class="std std-ref">类型信息</span></a> 。</p>
</section>
<section id="index-7">
<span id="id16"></span><h4>定长字节数组<a class="headerlink" href="#index-7" title="此标题的永久链接"></a></h4>
<p>值类型 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes2</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes3</span></code>, ..., <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 代表从1到32的字节序列。</p>
<p>运算符：</p>
<p>比较运算符：&lt;=， &lt;， ==， !=， &gt;=， &gt; （返回布尔型）</p>
<ul class="simple">
<li><p>比较运算符： <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (返回 <code class="docutils literal notranslate"><span class="pre">bool</span></code>)</p></li>
<li><p>位运算符： <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>， <code class="docutils literal notranslate"><span class="pre">|</span></code>， <code class="docutils literal notranslate"><span class="pre">^</span></code> （按位异或）， <code class="docutils literal notranslate"><span class="pre">~</span></code> （按位取反）</p></li>
<li><p>移位运算符： <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> （左移位）， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> （右移位）</p></li>
<li><p>索引访问： 如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">bytesI</span></code> 类型，那么当 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">I</span></code> 时， <code class="docutils literal notranslate"><span class="pre">x[k]</span></code> 返回第 <code class="docutils literal notranslate"><span class="pre">k</span></code> 个字节（只读）。</p></li>
</ul>
<p>移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型），
它表示要移位的位数。有符号类型的移位将产生一个编译错误。</p>
<p>成员变量：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.length</span></code> 表示这个字节数组的长度（只读）.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>类型 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 是一个字节数组，但是由于填充规则，它为每个元素浪费了31个字节的空间（在存储中除外）。
因此最好使用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 类型来代替。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.8.0 版本之前， <code class="docutils literal notranslate"><span class="pre">byte</span></code> 曾经是 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> 的别名。</p>
</div>
</section>
<section id="id17">
<h4>变长字节数组<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code>:</dt><dd><p>变长字节数组，参见 <a class="reference internal" href="#arrays"><span class="std std-ref">数组</span></a>。它并不是值类型！</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string</span></code>:</dt><dd><p>变长 UTF-8 编码字符串类型，参见 <a class="reference internal" href="#arrays"><span class="std std-ref">数组</span></a>。并不是值类型！</p>
</dd>
</dl>
</section>
<section id="address-literals">
<span id="index-8"></span><span id="id18"></span><h4>地址字面常数（Address Literals）<a class="headerlink" href="#address-literals" title="此标题的永久链接"></a></h4>
<p>比如像 <code class="docutils literal notranslate"><span class="pre">0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</span></code> 这样的
通过了地址校验测试的十六进制字属于 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。
十六进制字数在39到41位之间，并且没有通过校验测试，会产生一个错误。
您可以预加（对于整数类型）或附加（对于bytesNN类型）零来消除该错误。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>混合大小写的地址校验和格式定义在 <a class="reference external" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a>。</p>
</div>
</section>
<section id="rational-literals">
<span id="index-9"></span><span id="id20"></span><h4>有理数和整数字面常数<a class="headerlink" href="#rational-literals" title="此标题的永久链接"></a></h4>
<p>整数字面常数由范围在 0-9 的一串数字组成，表现成十进制。
例如， <code class="docutils literal notranslate"><span class="pre">69</span></code> 表示十进制数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。</p>
<p>小数字面常数由 <code class="docutils literal notranslate"><span class="pre">.</span></code> 和小数点后的至少一个数字组成。例如， <code class="docutils literal notranslate"><span class="pre">.1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">1.3``（但不是</span> <span class="pre">``1.</span></code>）。</p>
<p>也支持 <code class="docutils literal notranslate"><span class="pre">2e10</span></code> 形式的科学符号，其中尾数可以是小数，但指数必须是一个整数。
字面的 <code class="docutils literal notranslate"><span class="pre">MeE</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">*</span> <span class="pre">10**E</span></code>。
例子包括 <code class="docutils literal notranslate"><span class="pre">2e10</span></code>, <code class="docutils literal notranslate"><span class="pre">-2e10</span></code>, <code class="docutils literal notranslate"><span class="pre">2e-10</span></code>, <code class="docutils literal notranslate"><span class="pre">2.5e1</span></code>。</p>
<p>下划线可以用来分隔数字字面的数字，以帮助阅读。
例如，十进制 <code class="docutils literal notranslate"><span class="pre">123_000</span></code>，十六进制 <code class="docutils literal notranslate"><span class="pre">0x2eff_abde</span></code>，科学十进制 <code class="docutils literal notranslate"><span class="pre">1_2e345_678</span></code> 都是有效的。
下划线只允许在两个数字之间，并且只允许一个连续的下划线。
含有下划线的数字字面没有额外的语义，下划线被忽略。</p>
<p>数值字面常数表达式保留任意精度，直到它们被转换为非字面常数类型
（即通过与数字字面常数表达式以外的任何东西一起使用（如布尔字面常数）或通过显式转换）。
这意味着在数值常量表达式中，计算不会溢出，除法不会截断。</p>
<p>例如， <code class="docutils literal notranslate"><span class="pre">(2**800</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">-</span> <span class="pre">2**800</span></code> 的结果是常数 <code class="docutils literal notranslate"><span class="pre">1</span></code> （类型 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>），
尽管中间的结果甚至不符合机器字的大小。此外， <code class="docutils literal notranslate"><span class="pre">.5</span> <span class="pre">*</span> <span class="pre">8</span></code> 的结果是整数 <code class="docutils literal notranslate"><span class="pre">4</span></code> （尽管中间使用了非整数）。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>虽然大多数运算符在应用于字面常数时都会产生一个字面常数表达式，但有一些运算符并不遵循这种模式：</p>
<ul class="simple">
<li><p>三元运算符（ <code class="docutils literal notranslate"><span class="pre">...？</span> <span class="pre">...：...</span></code>）。</p></li>
<li><p>数组下标（ <code class="docutils literal notranslate"><span class="pre">&lt;array&gt;[&lt;index&gt;]</span></code>）。</p></li>
</ul>
<p>您可能期望像 <code class="docutils literal notranslate"><span class="pre">255</span> <span class="pre">+</span> <span class="pre">(true</span> <span class="pre">?</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">0)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">255</span> <span class="pre">+</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3][0]</span></code> 这样的表达式等同于直接使用字面常数256，
但实际上它们是在 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 类型中计算的，可能会溢出。</p>
</div>
<p>只要操作数是整数，任何可以应用于整数的操作数也可以应用于数值字面常数表达式。
如果两者中的任何一个是小数，则不允许进行位操作，
如果指数是小数，则不允许进行幂运算（因为这可能导致无理数）。</p>
<p>以数值字面常数表达式为左（或基数）操作数，以整数类型为右（指数）操作数的移位和幂运算，
总是在 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> （非负数数值字面常数）或 <code class="docutils literal notranslate"><span class="pre">int256</span></code> （负数数值字面常数）类型中进行。
无论右（指数）操作数的类型如何。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在 0.4.0 版本之前，Solidity 中整数字的除法会被截断，但现在它转换为一个有理数，即 <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></code> 不等于 <code class="docutils literal notranslate"><span class="pre">2</span></code>，而是 <code class="docutils literal notranslate"><span class="pre">2.5</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Solidity 对每个有理数都有对应的数值字面常数类型。
整数字面常数和有理数字面常数都属于数值字面常数类型。
除此之外，所有的数值字面常数表达式（即只包含数值字面常数和运算符的表达式）都属于数值字面常数类型。
因此数值字面常数表达式 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code> 的结果跟有理数3的数值字面常数类型相同。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>数字字面表达式一旦与非字面表达式一起使用，就会被转换为非字面类型。
不考虑类型，下面分配给 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的表达式的值被评估为一个整数。
因为 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint128</span></code>，所以表达式 <code class="docutils literal notranslate"><span class="pre">2.5</span> <span class="pre">+</span> <span class="pre">a</span></code> 必须有一个合适的类型。
由于 <code class="docutils literal notranslate"><span class="pre">2.5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint128</span></code> 的类型没有共同的类型，Solidity编译器不接受这段代码。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint128</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="kt">uint128</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">.</span><span class="m m-Decimal">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">.</span><span class="m m-Decimal">5</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="string-literals">
<span id="index-10"></span><span id="id21"></span><h4>字符串字面常数和类型<a class="headerlink" href="#string-literals" title="此标题的永久链接"></a></h4>
<p>字符串字面常数是指由双引号或单引号引起来的字符串（ <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">'bar'</span></code>）。
它们也可以分成多个连续部分（ <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span> <span class="pre">&quot;bar&quot;</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">&quot;foobar&quot;</span></code> ），这在处理长字符串时很有帮助。
它们不像在 C 语言中那样带有结束符； <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 相当于3个字节而不是4个。
和整数字面常数一样，字符串字面常数的类型也可以发生改变，
但它们可以隐式地转换成 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code>，……， <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>，如果合适的话，还可以转换成 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">string</span></code>。</p>
<p>例如，使用 <code class="docutils literal notranslate"><span class="pre">bytes32</span> <span class="pre">samevar</span> <span class="pre">=</span> <span class="pre">&quot;stringliteral&quot;</span></code>，
当分配给 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 类型时，字符串字面常数被解释成原始字节形式。</p>
<p>字符串字面常数只能包含可打印的ASCII字符，也就是0x20 ... 0x7E之间的字符。</p>
<p>此外，字符串字元还支持以下转义字符：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;newline&gt;</span></code> （转义一个实际的换行）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\\</span></code> （反斜杠）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\'</span></code> （单引号）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&quot;</span></code> （双引号）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\n</span></code> （换行）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\r</span></code> （回车键）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\t</span></code> （制表）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\xNN</span></code> （十六进制转义，见下文）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> （unicode转义，见下文）</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">\xNN</span></code> 接收一个十六进制值并插入相应的字节，而 <code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> 接收一个Unicode编码点并插入一个UTF-8序列。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.8.0 版本之前，有三个额外的转义序列。 <code class="docutils literal notranslate"><span class="pre">\b</span></code>， <code class="docutils literal notranslate"><span class="pre">\f</span></code> 和 <code class="docutils literal notranslate"><span class="pre">v</span></code>。
它们在其他语言中通常是可用的，但在实践中很少需要。
如果您确实需要它们，仍然可以通过十六进制转义插入，
即分别为 <code class="docutils literal notranslate"><span class="pre">\x08</span></code>， <code class="docutils literal notranslate"><span class="pre">x0c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\x0b</span></code>，就像其他ASCII字符一样。</p>
</div>
<p>下面例子中的字符串的长度为10个字节。
它以一个换行字节开始，接着是一个双引号，一个单引号，一个反斜杠字符，
然后（没有分隔符）是字符序列 <code class="docutils literal notranslate"><span class="pre">abcdef</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=IlxuXCJcJ1xcYWJjXApkZWYi"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;\n\&quot;</span><span class="err">\&#39;\\</span>abc<span class="err">\</span>
def<span class="err">&quot;</span>
</pre></div>
</div>
<p>任何非换行的 Unicode 行结束符（即LF, VF, FF, CR, NEL, LS, PS）都被认为是字符串字面的结束。
换行只在字符串字面内容前面没有 <code class="docutils literal notranslate"><span class="pre">\</span></code> 的情况下终止。</p>
</section>
<section id="unicode">
<h4>Unicode 字面常数<a class="headerlink" href="#unicode" title="此标题的永久链接"></a></h4>
<p>普通字符串字面常数只能包含ASCII码，而 Unicode 字面常数 - 以关键字 <code class="docutils literal notranslate"><span class="pre">unicode</span></code> 为前缀 - 可以包含任何有效的UTF-8序列。
它们也支持与普通字符串字面意义相同的转义序列。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>unicode<span class="s2">&quot;Hello 😃&quot;</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="index-11">
<span id="id22"></span><h4>十六进制字面常数<a class="headerlink" href="#index-11" title="此标题的永久链接"></a></h4>
<p>十六进制字面常数以关键字 <code class="docutils literal notranslate"><span class="pre">hex</span></code> 打头，
后面紧跟着用单引号或双引号引起来的字符串（ <code class="docutils literal notranslate"><span class="pre">hex&quot;001122FF&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">hex'0011_22_FF'</span></code>）。
它们的内容必须是十六进制的数字，可以选择使用一个下划线作为字节边界之间的分隔符。
字面的值将是十六进制序列的二进制表示。</p>
<p>由空格分隔的多个十六进制字面常数被串联成一个字面常数：
<code class="docutils literal notranslate"><span class="pre">hex&quot;00112233&quot;</span> <span class="pre">hex&quot;44556677&quot;</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">hex&quot;0011223344556677&quot;</span></code>。</p>
<p>十六进制字面常数的行为与 <a class="reference internal" href="#string-literals"><span class="std std-ref">字符串字面常数</span></a> 类似，并有相同的可转换性限制。</p>
</section>
<section id="enums">
<span id="index-12"></span><span id="id23"></span><h4>枚举类型<a class="headerlink" href="#enums" title="此标题的永久链接"></a></h4>
<p>枚举是在 Solidity 中创建用户定义类型的一种方式。
它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。
从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">异常</span></a>。
枚举要求至少有一个成员，其声明时的默认值是第一个成员。
枚举不能有超过256个成员。</p>
<p>数据表示与 C 语言中的枚举相同。选项由后续的从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始无符号整数值表示。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">type(NameOfEnum).min</span></code> 和 <code class="docutils literal notranslate"><span class="pre">type(NameOfEnum).max</span></code>
您可以得到给定枚举的最小值和最大值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8g55Sx5LqO5p6a5Li+57G75Z6L5LiN5bGe5LqOQUJJ55qE5LiA6YOo5YiG77yM5Zug5q2k5a+55LqO5omA5pyJ5p2l6IeqIFNvbGlkaXR5IOWklumDqOeahOiwg+eUqO+8jAogICAgLy8gImdldENob2ljZSIg55qE562+5ZCN5Lya6Ieq5Yqo6KKr5pS55oiQICJnZXRDaG9pY2UoKSByZXR1cm5zICh1aW50OCki44CCCiAgICBmdW5jdGlvbiBnZXRDaG9pY2UoKSBwdWJsaWMgdmlldyByZXR1cm5zIChBY3Rpb25DaG9pY2VzKSB7CiAgICAgICAgcmV0dXJuIGNob2ljZTsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXREZWZhdWx0Q2hvaWNlKCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB1aW50KGRlZmF1bHRDaG9pY2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldExhcmdlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5tYXg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0U21hbGxlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5taW47CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.8</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">ActionChoices</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>GoLeft<span class="p">,</span><span class="w"> </span>GoRight<span class="p">,</span><span class="w"> </span>GoStraight<span class="p">,</span><span class="w"> </span>SitStill<span class="w"> </span><span class="p">}</span>
<span class="w">    </span>ActionChoices<span class="w"> </span>choice<span class="p">;</span>
<span class="w">    </span>ActionChoices<span class="w"> </span><span class="kt">constant</span><span class="w"> </span>defaultChoice<span class="w"> </span><span class="o">=</span><span class="w"> </span>ActionChoices<span class="p">.</span>GoStraight<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setGoStraight</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>choice<span class="w"> </span><span class="o">=</span><span class="w"> </span>ActionChoices<span class="p">.</span>GoStraight<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span>
<span class="w">    </span><span class="c1">// &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getChoice</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>ActionChoices<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>choice<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getDefaultChoice</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">uint</span><span class="p">(</span>defaultChoice<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getLargestValue</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>ActionChoices<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>type<span class="p">(</span>ActionChoices<span class="p">).</span>max<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getSmallestValue</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>ActionChoices<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>type<span class="p">(</span>ActionChoices<span class="p">).</span>min<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>枚举也可以在文件级别上声明，在合约或库定义之外。</p>
</div>
</section>
<section id="user-defined-value-types">
<span id="index-13"></span><span id="id24"></span><h4>用户定义的值类型<a class="headerlink" href="#user-defined-value-types" title="此标题的永久链接"></a></h4>
<p>一个用户定义的值类型允许在一个基本的值类型上创建一个零成本的抽象。
这类似于一个别名，但有更严格的类型要求。</p>
<p>一个用户定义的值类型是用 <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">C</span> <span class="pre">is</span> <span class="pre">V</span></code> 定义的，其中 <code class="docutils literal notranslate"><span class="pre">C</span></code> 是新引入的类型的名称，
<code class="docutils literal notranslate"><span class="pre">V</span></code> 必须是一个内置的值类型（“底层类型”）。
函数 <code class="docutils literal notranslate"><span class="pre">C.wrap</span></code> 被用来从底层类型转换到自定义类型。同样地，
函数 <code class="docutils literal notranslate"><span class="pre">C.unwrap</span></code> 用于从自定义类型转换到底层类型。</p>
<p>类型 <code class="docutils literal notranslate"><span class="pre">C</span></code> 没有任何运算符或约束成员函数。特别的是，甚至运算符 <code class="docutils literal notranslate"><span class="pre">==</span></code> 也没有定义。
也不允许与其他类型进行显式和隐式转换。</p>
<p>这种类型的值的数据表示是从底层类型中继承的，底层类型也被用于ABI中。</p>
<p>下面的例子说明了一个自定义类型 <code class="docutils literal notranslate"><span class="pre">UFixed256x18</span></code>，
代表一个有18位小数的十进制定点类型和一个最小的库来对该类型做算术运算。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIOS9v+eUqOeUqOaIt+WumuS5ieeahOWAvOexu+Wei+ihqOekuuS4gOS4qjE45L2N5bCP5pWw77yMMjU25L2N5a6955qE5a6a54K557G75Z6L44CCCnR5cGUgVUZpeGVkMjU2eDE4IGlzIHVpbnQyNTY7CgovLy8g5LiA5Liq5ZyoVUZpeGVkMjU2eDE45LiK6L+b6KGM5a6a54K55pON5L2c55qE5pyA5bCP5bqT44CCCmxpYnJhcnkgRml4ZWRNYXRoIHsKICAgIHVpbnQgY29uc3RhbnQgbXVsdGlwbGllciA9IDEwKioxODsKCiAgICAvLy8g5bCG5Lik5LiqVUZpeGVkMjU2eDE455qE5pWw5a2X55u45Yqg44CC5rqi5Ye65pe25bCG6L+U5Zue77yM5L6d6Z2gdWludDI1NueahOeul+acr+ajgOafpeOAggogICAgZnVuY3Rpb24gYWRkKFVGaXhlZDI1NngxOCBhLCBVRml4ZWQyNTZ4MTggYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSArIFVGaXhlZDI1NngxOC51bndyYXAoYikpOwogICAgfQogICAgLy8vIOWwhlVGaXhlZDI1NngxOOWSjHVpbnQyNTbnm7jkuZjjgILmuqLlh7rml7blsIbov5Tlm57vvIzkvp3pnaB1aW50MjU255qE566X5pyv5qOA5p+l44CCCiAgICBmdW5jdGlvbiBtdWwoVUZpeGVkMjU2eDE4IGEsIHVpbnQyNTYgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSAqIGIpOwogICAgfQogICAgLy8vIOWvueS4gOS4qlVGaXhlZDI1NngxOOexu+Wei+eahOaVsOWtl+ebuOS4i+WPluaVtOOAggogICAgLy8vIEByZXR1cm4g5LiN6LaF6L+HIGBhYCDnmoTmnIDlpKfmlbTmlbDjgIIKICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8g5bCG5LiA5LiqdWludDI1Nui9rOWMluS4uuebuOWQjOWAvOeahFVGaXhlZDI1NngxOOOAggogICAgLy8vIOWmguaenOaVtOaVsOWkquWkp++8jOWImeaBouWkjeiuoeeul+OAggogICAgZnVuY3Rpb24gdG9VRml4ZWQyNTZ4MTgodWludDI1NiBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKFVGaXhlZDI1NngxOCkgewogICAgICAgIHJldHVybiBVRml4ZWQyNTZ4MTgud3JhcChhICogbXVsdGlwbGllcik7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.8</span><span class="p">;</span>

<span class="c1">// 使用用户定义的值类型表示一个18位小数，256位宽的定点类型。</span>
type<span class="w"> </span>UFixed256x18<span class="w"> </span><span class="kt">is</span><span class="w"> </span><span class="kt">uint256</span><span class="p">;</span>

<span class="c1">/// 一个在UFixed256x18上进行定点操作的最小库。</span>
<span class="kt">library</span><span class="w"> </span>FixedMath<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>multiplier<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="o">**</span><span class="m m-Decimal">18</span><span class="p">;</span>

<span class="w">    </span><span class="c1">/// 将两个UFixed256x18的数字相加。溢出时将返回，依靠uint256的算术检查。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">add</span><span class="p">(</span>UFixed256x18<span class="w"> </span>a<span class="p">,</span><span class="w"> </span>UFixed256x18<span class="w"> </span>b<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>UFixed256x18<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>wrap<span class="p">(</span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>b<span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">/// 将UFixed256x18和uint256相乘。溢出时将返回，依靠uint256的算术检查。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">mul</span><span class="p">(</span>UFixed256x18<span class="w"> </span>a<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>UFixed256x18<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>wrap<span class="p">(</span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>b<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">/// 对一个UFixed256x18类型的数字相下取整。</span>
<span class="w">    </span><span class="c1">/// @return 不超过 `a` 的最大整数。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">floor</span><span class="p">(</span>UFixed256x18<span class="w"> </span>a<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span>multiplier<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">/// 将一个uint256转化为相同值的UFixed256x18。</span>
<span class="w">    </span><span class="c1">/// 如果整数太大，则恢复计算。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">toUFixed256x18</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>UFixed256x18<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>wrap<span class="p">(</span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span>multiplier<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意 <code class="docutils literal notranslate"><span class="pre">UFixed256x18.wrap</span></code> 和 <code class="docutils literal notranslate"><span class="pre">FixedMath.toUFixed256x18</span></code> 有相同的签名，
但执行两个非常不同的操作。 <code class="docutils literal notranslate"><span class="pre">UFixed256x18.wrap</span></code> 函数返回一个与输入的数据表示相同的 <code class="docutils literal notranslate"><span class="pre">UFixed256x18</span></code>，
而 <code class="docutils literal notranslate"><span class="pre">toUFixed256x18</span></code> 则返回一个具有相同数值的 <code class="docutils literal notranslate"><span class="pre">UFixed256x18</span></code>。</p>
</section>
<section id="function-types">
<span id="index-14"></span><span id="id25"></span><h4>函数类型<a class="headerlink" href="#function-types" title="此标题的永久链接"></a></h4>
<p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，
也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。
函数类型有两类：- <em>内部（internal）</em> 函数和 <em>外部（external）</em> 函数：</p>
<p>内部函数只能在当前合约内被调用（更具体来说，
在当前代码块内，包括内部库函数和继承的函数中），
因为它们不能在当前合约上下文的外部被执行。
调用一个内部函数是通过跳转到它的入口标签来实现的，
就像在当前合约的内部调用一个函数。</p>
<p>外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。</p>
<p>函数类型表示成如下的形式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span>parameter<span class="w"> </span>types<span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="kt">internal</span><span class="o">|</span><span class="kt">external</span><span class="p">}</span><span class="w"> </span><span class="p">[</span>pure<span class="o">|</span>view<span class="o">|</span><span class="kt">payable</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="kt">return</span><span class="w"> </span>types<span class="o">&gt;</span><span class="p">)]</span>
</pre></div>
</div>
<p>与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，
则需要删除整个 <code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">(&lt;return</span> <span class="pre">types&gt;)</span></code> 部分。</p>
<p>默认情况下，函数类型是内部函数，所以可以省略 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 关键字。
注意，这只适用于函数类型。对于合约中定义的函数，
必须明确指定其可见性，它们没有默认类型。</p>
<p>转换：</p>
<p>当且仅当它们的参数类型相同，它们的返回类型相同，它们的内部/外部属性相同，
并且 <code class="docutils literal notranslate"><span class="pre">A</span></code> 的状态可变性比 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的状态可变性更具限制性时，
一个函数类型 <code class="docutils literal notranslate"><span class="pre">A</span></code> 就可以隐式转换为一个函数类型 <code class="docutils literal notranslate"><span class="pre">B</span></code>。特别是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数可以转换为 <code class="docutils literal notranslate"><span class="pre">view</span></code> 和 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">view</span></code> 函数可以转换为 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">payable</span></code> 函数可以转换为 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 函数</p></li>
</ul>
<p>其他函数类型之间的转换是不可能的。</p>
<p>关于 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 和 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 的规则可能有点混乱，
但实质上，如果一个函数是 <code class="docutils literal notranslate"><span class="pre">payable</span></code>，这意味着
它也接受零以太的支付，所以它也是 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code>。
另一方面，一个 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 的函数将拒绝发送给它的以太，
所以 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 的函数不能被转换为 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 的函数。</p>
<p>如果一个函数类型的变量没有被初始化，调用它将导致
会出现 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">异常</span></a>。如果您在一个函数上使用了 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 之后再调用它，
也会发生同样的情况。</p>
<p>如果外部函数类型在 Solidity 的上下文中被使用，
它们将被视为 <code class="docutils literal notranslate"><span class="pre">function</span></code> 类型，它将地址和函数标识符一起编码为一个 <code class="docutils literal notranslate"><span class="pre">bytes24</span></code> 类型。</p>
<p>请注意，当前合约的公开函数既可以被当作内部函数也可以被当作外部函数使用。
如果想将一个函数当作内部函数使用，就用 <code class="docutils literal notranslate"><span class="pre">f</span></code> 调用，
如果想将其当作外部函数，使用 <code class="docutils literal notranslate"><span class="pre">this.f</span></code> 。</p>
<p>一个内部类型的函数可以被分配给一个内部函数类型的变量，而不管它在哪里被定义。
这包括合约和库合约的隐私、内部和公共函数，以及自由函数。
另一方面，外部函数类型只与公共和外部合约函数兼容。
库合约被排除在外，因为它们需要一个 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>，
并且 <a class="reference internal" href="index.html#library-selectors"><span class="std std-ref">对它们的选择器使用不同的 ABI 约定</span></a>。
在接口中声明的函数没有定义，所以指向它们也没有意义。</p>
<p>成员：
外部（或公共）函数有以下成员：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.address</span></code> 返回该函数的合约地址。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.selector</span></code> 返回 <a class="reference internal" href="index.html#abi-function-selector"><span class="std std-ref">ABI 函数选择器</span></a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>外部（或公共）函数曾经有额外的成员 <code class="docutils literal notranslate"><span class="pre">.gas(uint)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.value(uint)</span></code>。
这些在 Solidity 0.6.2 中被废弃，并在 Solidity 0.7.0 中被移除。取而代之的是
使用 <code class="docutils literal notranslate"><span class="pre">{gas:</span> <span class="pre">...}</span></code> 和 <code class="docutils literal notranslate"><span class="pre">{value:</span> <span class="pre">...}</span></code> 来分别指定发送到函数的气体量或以太（wei为单位）量。
参见 <a class="reference internal" href="index.html#external-function-calls"><span class="std std-ref">外部函数调用</span></a> 以获得更多信息。</p>
</div>
<p>以下例子展示如何使用这些成员：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.4</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Example</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bytes4<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>assert<span class="p">(</span><span class="kt">this</span><span class="p">.</span>f<span class="p">.</span><span class="kt">address</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">));</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">this</span><span class="p">.</span>f<span class="p">.</span>selector<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">this</span><span class="p">.</span>f<span class="p">{</span>gas<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">,</span><span class="w"> </span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">800</span><span class="p">}();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下例子展示如何使用内部函数类型：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyDlhoXpg6jlh73mlbDlj6/ku6XlnKjlhoXpg6jlupPlh73mlbDkuK3kvb/nlKjvvIzlm6DkuLrlroPku6zlsIbmmK/lkIzkuIDku6PnoIHkuIrkuIvmlofnmoTkuIDpg6jliIYKICAgIGZ1bmN0aW9uIG1hcCh1aW50W10gbWVtb3J5IHNlbGYsIGZ1bmN0aW9uICh1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludFtdIG1lbW9yeSByKQogICAgewogICAgICAgIHIgPSBuZXcgdWludFtdKHNlbGYubGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBmKHNlbGZbaV0pOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiByZWR1Y2UoCiAgICAgICAgdWludFtdIG1lbW9yeSBzZWxmLAogICAgICAgIGZ1bmN0aW9uICh1aW50LCB1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYKICAgICkKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHIpCiAgICB7CiAgICAgICAgciA9IHNlbGZbMF07CiAgICAgICAgZm9yICh1aW50IGkgPSAxOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByID0gZihyLCBzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmFuZ2UodWludCBsZW5ndGgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludFtdIG1lbW9yeSByKSB7CiAgICAgICAgciA9IG5ldyB1aW50W10obGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBpOwogICAgICAgIH0KICAgIH0KfQoKCmNvbnRyYWN0IFB5cmFtaWQgewogICAgdXNpbmcgQXJyYXlVdGlscyBmb3IgKjsKCiAgICBmdW5jdGlvbiBweXJhbWlkKHVpbnQgbCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBBcnJheVV0aWxzLnJhbmdlKGwpLm1hcChzcXVhcmUpLnJlZHVjZShzdW0pOwogICAgfQoKICAgIGZ1bmN0aW9uIHNxdWFyZSh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICogeDsKICAgIH0KCiAgICBmdW5jdGlvbiBzdW0odWludCB4LCB1aW50IHkpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICsgeTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>ArrayUtils<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 内部函数可以在内部库函数中使用，因为它们将是同一代码上下文的一部分</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">map</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">function</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>f<span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>self<span class="p">.</span>length<span class="p">);</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>r<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">(</span>self<span class="p">[</span>i<span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">reduce</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>self<span class="p">,</span>
<span class="w">        </span><span class="kt">function</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>f
<span class="w">    </span><span class="p">)</span>
<span class="w">        </span><span class="kt">internal</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">];</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">(</span>r<span class="p">,</span><span class="w"> </span>self<span class="p">[</span>i<span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">range</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">length</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>length<span class="p">);</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>r<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>r<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>i<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Pyramid</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>using<span class="w"> </span>ArrayUtils<span class="w"> </span><span class="kt">for</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">pyramid</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>ArrayUtils<span class="p">.</span>range<span class="p">(</span>l<span class="p">).</span>map<span class="p">(</span>square<span class="p">).</span>reduce<span class="p">(</span>sum<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">square</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">*</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sum</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span>y<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>另一个使用外部函数类型的例子：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z6YeM6KaB5qOA5p+l55qE5piv6LCD55So6L+U5Zue5piv5ZCm5p2l6Ieq5Y+v5L+h55qE5p2l5rqQCiAgICAgICAgcmVxdWVzdHNbcmVxdWVzdElEXS5jYWxsYmFjayhyZXNwb25zZSk7CiAgICB9Cn0KCgpjb250cmFjdCBPcmFjbGVVc2VyIHsKICAgIE9yYWNsZSBjb25zdGFudCBwcml2YXRlIE9SQUNMRV9DT05TVCA9IE9yYWNsZShhZGRyZXNzKDB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYSkpOyAvLyDlt7Lnn6XnmoTlkIjnuqYKICAgIHVpbnQgcHJpdmF0ZSBleGNoYW5nZVJhdGU7CgogICAgZnVuY3Rpb24gYnV5U29tZXRoaW5nKCkgcHVibGljIHsKICAgICAgICBPUkFDTEVfQ09OU1QucXVlcnkoIlVTRCIsIHRoaXMub3JhY2xlUmVzcG9uc2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9yYWNsZVJlc3BvbnNlKHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBhZGRyZXNzKE9SQUNMRV9DT05TVCksCiAgICAgICAgICAgICJPbmx5IG9yYWNsZSBjYW4gY2FsbCB0aGlzLiIKICAgICAgICApOwogICAgICAgIGV4Y2hhbmdlUmF0ZSA9IHJlc3BvbnNlOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Oracle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Request</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">data</span><span class="p">;</span>
<span class="w">        </span><span class="kt">function</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>callback<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span>Request<span class="p">[]</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>requests<span class="p">;</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">NewRequest</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">query</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>data<span class="p">,</span><span class="w"> </span><span class="kt">function</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>callback<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>requests<span class="p">.</span>push<span class="p">(</span>Request<span class="p">(</span>data<span class="p">,</span><span class="w"> </span>callback<span class="p">));</span>
<span class="w">        </span>emit<span class="w"> </span>NewRequest<span class="p">(</span>requests<span class="p">.</span>length<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">reply</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">requestID</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">response</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这里要检查的是调用返回是否来自可信的来源</span>
<span class="w">        </span>requests<span class="p">[</span>requestID<span class="p">].</span>callback<span class="p">(</span>response<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">OracleUser</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>Oracle<span class="w"> </span><span class="kt">constant</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>ORACLE_CONST<span class="w"> </span><span class="o">=</span><span class="w"> </span>Oracle<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="mh">0x00000000219ab540356cBB839Cbe05303d7705Fa</span><span class="p">));</span><span class="w"> </span><span class="c1">// 已知的合约</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">private </span><span class="nv">exchangeRate</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">buySomething</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>ORACLE_CONST<span class="p">.</span>query<span class="p">(</span><span class="s2">&quot;USD&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">this</span><span class="p">.</span>oracleResponse<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">oracleResponse</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">response</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>ORACLE_CONST<span class="p">),</span>
<span class="w">            </span><span class="s2">&quot;Only oracle can call this.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span>exchangeRate<span class="w"> </span><span class="o">=</span><span class="w"> </span>response<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Lambda 或内联函数是计划中的，但还不支持。</p>
</div>
</section>
</section>
<section id="reference-types">
<span id="index-15"></span><span id="id26"></span><h3>引用类型<a class="headerlink" href="#reference-types" title="此标题的永久链接"></a></h3>
<p>引用类型的值可以通过多个不同的名称进行修改。
这与值类型形成鲜明对比，在值类型的变量被使用时，您会得到一个独立的副本。
正因为如此，对引用类型的处理要比对值类型的处理更加谨慎。目前，
引用类型包括结构、数组和映射。如果您使用一个引用类型，
您必须明确地提供存储该类型的数据区域。 <code class="docutils literal notranslate"><span class="pre">memory</span></code> （其寿命限于外部函数调用），
<code class="docutils literal notranslate"><span class="pre">storage</span></code> （存储状态变量的位置，其寿命限于合约的寿命）
或 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> （包含函数参数的特殊数据位置）。</p>
<p>改变数据位置的赋值或类型转换将总是导致自动复制操作，
而同一数据位置内的赋值只在某些情况下对存储类型进行复制。</p>
<section id="data-location">
<span id="id27"></span><h4>数据位置<a class="headerlink" href="#data-location" title="此标题的永久链接"></a></h4>
<p>每个引用类型都有一个额外的属性，即 &quot;数据位置&quot;，
关于它的存储位置。有三个数据位置。 <code class="docutils literal notranslate"><span class="pre">memory</span></code>, <code class="docutils literal notranslate"><span class="pre">storage</span></code> 和 <code class="docutils literal notranslate"><span class="pre">calldata</span></code>。
Calldata是一个不可修改的、非持久性的区域，用于存储函数参数，其行为主要类似于memory。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果可以的话，尽量使用 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 作为数据位置，因为这样可以避免复制，
也可以确保数据不能被修改。使用 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 数据位置的数组和结构也可以从函数中返回，
但不可能分配这种类型。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.6.9版本之前，引用型参数的数据位置被限制在外部函数中的 <code class="docutils literal notranslate"><span class="pre">calldata</span></code>，
公开函数中的 <code class="docutils literal notranslate"><span class="pre">memory</span></code>，以及内部和私有函数中的 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 或 <code class="docutils literal notranslate"><span class="pre">storage</span></code>。
现在 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 和 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 在所有函数中都被允许使用，无论其可见性如何。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.5.0版本之前，数据位置可以省略，并且会根据变量的种类、函数类型等默认为不同的位置，
但现在所有的复杂类型都必须给出一个明确的数据位置。</p>
</div>
<section id="data-location-assignment">
<span id="id28"></span><h5>数据位置和分配行为<a class="headerlink" href="#data-location-assignment" title="此标题的永久链接"></a></h5>
<p>数据位置不仅与数据的持久性有关，而且也与分配的语义有关：</p>
<ul class="simple">
<li><p>在 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 和 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 之间的分配（或从 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 中分配） 总是创建一个独立的拷贝。</p></li>
<li><p>从 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 到 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 的赋值只创建引用。
这意味着对一个内存变量的改变在所有其他引用相同数据的内存变量中也是可见的。</p></li>
<li><p>从  <code class="docutils literal notranslate"><span class="pre">storage</span></code> 到 <strong>local</strong> 存储变量的赋值也只赋值一个引用。</p></li>
<li><p>所有其他对 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 的赋值总是拷贝的。
这种情况的例子是对状态变量或存储结构类型的局部变量成员的赋值，
即使局部变量本身只是一个引用。</p></li>
</ul>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyB4IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBzdG9yYWdl44CCCiAgICAvLyDov5nmmK/llK/kuIDlj6/ku6XnnIHnlaXmlbDmja7kvY3nva7nmoTlnLDmlrnjgIIKICAgIHVpbnRbXSB4OwoKICAgIC8vIG1lbW9yeUFycmF5IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBtZW1vcnnjgIIKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBtZW1vcnlBcnJheSkgcHVibGljIHsKICAgICAgICB4ID0gbWVtb3J5QXJyYXk7IC8vIOWwhuaVtOS4quaVsOe7hOaLt+i0neWIsCBzdG9yYWdlIOS4re+8jOWPr+ihjAogICAgICAgIHVpbnRbXSBzdG9yYWdlIHkgPSB4OyAvLyDliIbphY3kuIDkuKrmjIfpkojvvIzlhbbkuK0geSDnmoTmlbDmja7lrZjlgqjkvY3nva7mmK8gc3RvcmFnZe+8jOWPr+ihjAogICAgICAgIHlbN107IC8vIOi/lOWbnuesrCA4IOS4quWFg+e0oO+8jOWPr+ihjAogICAgICAgIHkucG9wKCk7IC8vIOmAmui/h3nkv67mlLl477yM5Y+v6KGMCiAgICAgICAgZGVsZXRlIHg7IC8vIOa4hemZpOaVsOe7hO+8jOWQjOaXtuS/ruaUuSB577yM5Y+v6KGMCiAgICAgICAgLy8g5LiL6Z2i55qE5bCx5LiN5Y+v6KGM5LqG77yb6ZyA6KaB5ZyoIHN0b3JhZ2Ug5Lit5Yib5bu65paw55qE5pyq5ZG95ZCN55qE5Li05pe25pWw57uE77yMLwogICAgICAgIC8vIOS9hiBzdG9yYWdlIOaYr+KAnOmdmeaAgeKAneWIhumFjeeahO+8mgogICAgICAgIC8vIHkgPSBtZW1vcnlBcnJheTsKICAgICAgICAvLyDlkIzmoLfvvIwgImRlbGV0ZSB5IiDkuZ/mmK/ml6DmlYjnmoTvvIwKICAgICAgICAvLyDlm6DkuLrlr7nlvJXnlKjlrZjlgqjlr7nosaHnmoTlsYDpg6jlj5jph4/nmoTotYvlgLzlj6rog73ku47njrDmnInnmoTlrZjlgqjlr7nosaHkuK3ov5vooYzjgIIKICAgICAgICAvLyDlroPlsIYg4oCc6YeN572u4oCdIOaMh+mSiO+8jOS9huayoeacieS7u+S9leWQiOeQhueahOS9jee9ruWPr+S7peaMh+WQkeWug+OAggogICAgICAgIC8vIOabtOWkmue7huiKguingSAiZGVsZXRlIiDmk43kvZznrKbnmoTmlofmoaPjgIIKICAgICAgICAvLyBkZWxldGUgeTsKICAgICAgICBnKHgpOyAvLyDosIPnlKggZyDlh73mlbDvvIzlkIzml7bnp7vkuqTlr7kgeCDnmoTlvJXnlKgKICAgICAgICBoKHgpOyAvLyDosIPnlKggaCDlh73mlbDvvIzlkIzml7blnKggbWVtb3J5IOS4reWIm+W7uuS4gOS4queLrOeri+eahOS4tOaXtuaLt+i0nQogICAgfQoKICAgIGZ1bmN0aW9uIGcodWludFtdIHN0b3JhZ2UpIGludGVybmFsIHB1cmUge30KICAgIGZ1bmN0aW9uIGgodWludFtdIG1lbW9yeSkgcHVibGljIHB1cmUge30KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// x 的数据存储位置是 storage。</span>
<span class="w">    </span><span class="c1">// 这是唯一可以省略数据位置的地方。</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>x<span class="p">;</span>

<span class="w">    </span><span class="c1">// memoryArray 的数据存储位置是 memory。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>memoryArray<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>memoryArray<span class="p">;</span><span class="w"> </span><span class="c1">// 将整个数组拷贝到 storage 中，可行</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 分配一个指针，其中 y 的数据存储位置是 storage，可行</span>
<span class="w">        </span>y<span class="p">[</span><span class="m m-Decimal">7</span><span class="p">];</span><span class="w"> </span><span class="c1">// 返回第 8 个元素，可行</span>
<span class="w">        </span>y<span class="p">.</span>pop<span class="p">();</span><span class="w"> </span><span class="c1">// 通过y修改x，可行</span>
<span class="w">        </span>delete<span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 清除数组，同时修改 y，可行</span>
<span class="w">        </span><span class="c1">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，/</span>
<span class="w">        </span><span class="c1">// 但 storage 是“静态”分配的：</span>
<span class="w">        </span><span class="c1">// y = memoryArray;</span>
<span class="w">        </span><span class="c1">// 同样， &quot;delete y&quot; 也是无效的，</span>
<span class="w">        </span><span class="c1">// 因为对引用存储对象的局部变量的赋值只能从现有的存储对象中进行。</span>
<span class="w">        </span><span class="c1">// 它将 “重置” 指针，但没有任何合理的位置可以指向它。</span>
<span class="w">        </span><span class="c1">// 更多细节见 &quot;delete&quot; 操作符的文档。</span>
<span class="w">        </span><span class="c1">// delete y;</span>
<span class="w">        </span>g<span class="p">(</span>x<span class="p">);</span><span class="w"> </span><span class="c1">// 调用 g 函数，同时移交对 x 的引用</span>
<span class="w">        </span>h<span class="p">(</span>x<span class="p">);</span><span class="w"> </span><span class="c1">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="arrays">
<span id="index-16"></span><span id="id29"></span><h4>数组<a class="headerlink" href="#arrays" title="此标题的永久链接"></a></h4>
<p>数组可以在声明时指定长度，也可以动态调整大小。</p>
<p>一个元素类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code>，固定长度为 <code class="docutils literal notranslate"><span class="pre">k</span></code> 的数组可以声明为 <code class="docutils literal notranslate"><span class="pre">T[k]</span></code>，
而动态数组声明为 <code class="docutils literal notranslate"><span class="pre">T[]</span></code>。</p>
<p>例如，一个由5个 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 的动态数组组成的数组被写成 <code class="docutils literal notranslate"><span class="pre">uint[][5]</span></code>。
与其他一些语言相比, 这种记法是相反的。
在Solidity中, <code class="docutils literal notranslate"><span class="pre">X[3]</span></code> 总是一个包含三个 <code class="docutils literal notranslate"><span class="pre">X</span></code> 类型元素的数组，
即使 <code class="docutils literal notranslate"><span class="pre">X</span></code> 本身是一个数组。 这在其他语言中是不存在的，如C语言。</p>
<p>索引是基于零的，访问方向与声明相反。</p>
<p>例如，如果您有一个变量 <code class="docutils literal notranslate"><span class="pre">uint[][5]</span> <span class="pre">memory</span> <span class="pre">x</span></code>，您用 <code class="docutils literal notranslate"><span class="pre">x[2][6]</span></code> 访问第三个动态数组中的第七个 <code class="docutils literal notranslate"><span class="pre">uint</span></code>，
要访问第三个动态数组，用 <code class="docutils literal notranslate"><span class="pre">x[2]</span></code>。同样，如果您有一个数组 <code class="docutils literal notranslate"><span class="pre">T[5]</span> <span class="pre">a</span></code> 的类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>，
也可以是一个数组，那么 <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> 总是有类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>数组元素可以是任何类型，包括映射或结构体。
并适用于类型的一般限制，映射只能存储在 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 数据位置，
公开可见的函数需要参数是 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI类型</span></a>。</p>
<p>可以将状态变量数组标记为 <code class="docutils literal notranslate"><span class="pre">public</span></code>，
并让Solidity创建一个 <a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">getter</span></a> 函数。数字索引成为该函数的一个必要参数。</p>
<p>访问一个超过它的末端的数组会导致一个失败的断言。
方法 <code class="docutils literal notranslate"><span class="pre">.push()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.push(value)</span></code> 可以用来在数组的末端追加一个新的元素，
其中 <code class="docutils literal notranslate"><span class="pre">.push()</span></code> 追加一个零初始化的元素并返回它的引用。</p>
<section id="bytes-string">
<span id="bytes"></span><span id="strings"></span><span id="index-17"></span><h5><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型的数组<a class="headerlink" href="#bytes-string" title="此标题的永久链接"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型的变量是特殊的数组。 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 类似于 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code>，
但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。
<code class="docutils literal notranslate"><span class="pre">string</span></code> 与 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 相同，但不允许用长度或索引来访问。</p>
<p>Solidity没有字符串操作函数，但有第三方的字符串库。
您也可以用 <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encodePacked(s1))</span> <span class="pre">==</span> <span class="pre">keccak256(abi.encodePacked(s2))</span></code>
来比较两个字符串的keccak256-hash，用 <code class="docutils literal notranslate"><span class="pre">string.concat(s1,</span> <span class="pre">s2)</span></code> 来连接两个字符串。</p>
<p>您应该使用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code>，因为它更便宜，
因为在 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 中使用 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 会在元素之间增加31个填充字节。
请注意，在 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 中，由于紧打包，没有填充，参见 <a class="reference internal" href="index.html#bytes-and-string"><span class="std std-ref">字节和字符串</span></a>。
一般来说，对于任意长度的原始字节数据使用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>，对于任意长度的字符串（UTF-8）数据使用 <code class="docutils literal notranslate"><span class="pre">string</span></code>。
如果您能将长度限制在一定的字节数，总是使用 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> 到 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 中的一种值类型，因为它们更便宜。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果想要访问以字节表示的字符串 <code class="docutils literal notranslate"><span class="pre">s</span></code>，
请使用 <code class="docutils literal notranslate"><span class="pre">bytes(s).length</span></code> / <code class="docutils literal notranslate"><span class="pre">bytes(s)[7]</span> <span class="pre">=</span> <span class="pre">'x';</span></code>。
注意这时您访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。</p>
</div>
</section>
<section id="bytes-concat-string-concat">
<span id="string-concat"></span><span id="bytes-concat"></span><span id="index-18"></span><h5>函数 <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code><a class="headerlink" href="#bytes-concat-string-concat" title="此标题的永久链接"></a></h5>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code> 连接任意数量的 <code class="docutils literal notranslate"><span class="pre">string</span></code> 值。
该函数返回一个单一的 <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">memory</span></code> 数组，其中包含没有填充的参数内容。
如果您想使用不能隐式转换为 <code class="docutils literal notranslate"><span class="pre">string</span></code> 的其他类型的参数，您需要先将它们转换为 <code class="docutils literal notranslate"><span class="pre">string</span></code>。</p>
<p>同样， <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code> 函数可以连接任意数量的 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes1</span> <span class="pre">...</span> <span class="pre">bytes32</span></code> 值。
该函数返回一个单一的 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> 数组，其中包含没有填充的参数内容。
如果您想使用字符串参数或其他不能隐式转换为 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 的类型，
您需要先将它们转换为 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> /.../ <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.12</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;Storage&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">calldata</span><span class="w"> </span>bc<span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>sm<span class="p">,</span><span class="w"> </span><span class="kt">bytes16</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>concatString<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">string</span><span class="p">.</span>concat<span class="p">(</span>s<span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">(</span>bc<span class="p">),</span><span class="w"> </span><span class="s2">&quot;Literal&quot;</span><span class="p">,</span><span class="w"> </span>sm<span class="p">);</span>
<span class="w">        </span>assert<span class="p">((</span><span class="kt">bytes</span><span class="p">(</span>s<span class="p">).</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span>bc<span class="p">.</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>sm<span class="p">).</span>length<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>concatString<span class="p">).</span>length<span class="p">);</span>

<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>concatBytes<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes</span><span class="p">.</span>concat<span class="p">(</span><span class="kt">bytes</span><span class="p">(</span>s<span class="p">),</span><span class="w"> </span>bc<span class="p">,</span><span class="w"> </span>bc<span class="p">[</span><span class="o">:</span><span class="m m-Decimal">2</span><span class="p">],</span><span class="w"> </span><span class="s2">&quot;Literal&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>sm<span class="p">),</span><span class="w"> </span>b<span class="p">);</span>
<span class="w">        </span>assert<span class="p">((</span><span class="kt">bytes</span><span class="p">(</span>s<span class="p">).</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span>bc<span class="p">.</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>sm<span class="p">).</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">.</span>length<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>concatBytes<span class="p">.</span>length<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您不带参数调用 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code>，它们会返回一个空数组。</p>
</section>
<section id="index-19">
<span id="id30"></span><h5>创建内存数组<a class="headerlink" href="#index-19" title="此标题的永久链接"></a></h5>
<p>具有动态长度的内存数组可以使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 操作符创建。
与存储数组不同的是，<strong>不可能</strong> 调整内存数组的大小（例如， <code class="docutils literal notranslate"><span class="pre">.push</span></code> 成员函数不可用）。
您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。</p>
<p>正如Solidity中的所有变量一样，新分配的数组元素总是以 <a class="reference internal" href="index.html#default-value"><span class="std std-ref">默认值</span></a> 进行初始化。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span><span class="m m-Decimal">7</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>len<span class="p">);</span>
<span class="w">        </span>assert<span class="p">(</span>a<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">);</span>
<span class="w">        </span>assert<span class="p">(</span>b<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span>len<span class="p">);</span>
<span class="w">        </span>a<span class="p">[</span><span class="m m-Decimal">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="index-20">
<span id="id31"></span><h5>数组字面常数<a class="headerlink" href="#index-20" title="此标题的永久链接"></a></h5>
<p>数组字面常数表达式是一个逗号分隔的一个或多个表达式的列表，用方括号（ <code class="docutils literal notranslate"><span class="pre">[...]</span></code> ）括起来。
例如， <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">a,</span> <span class="pre">f(3)]</span></code>。数组字面常数的类型确定如下：</p>
<p>它总是一个静态大小的内存数组，其长度是表达式的数量。</p>
<p>数组的基本类型是列表上第一个表达式的类型，这样所有其他表达式都可以隐含地转换为它。
如果不能做到这一点，则会有一个类型错误。</p>
<p>仅仅存在一个所有元素都可以转换的类型是不够的。其中一个元素必须是该类型的。</p>
<p>在下面的例子中， <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint8[3]</span> <span class="pre">memory</span></code>，
因为这些常量的类型都是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>。如果您想让结果是 <code class="docutils literal notranslate"><span class="pre">uint[3]</span> <span class="pre">memory</span></code> 类型，
您需要把第一个元素转换为 <code class="docutils literal notranslate"><span class="pre">uint</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>g<span class="p">([</span><span class="kt">uint</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>数组表达式 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">-1]</span></code> 是无效的，因为第一个表达式的类型是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>，
而第二个表达式的类型是 <code class="docutils literal notranslate"><span class="pre">int8</span></code>，它们不能相互隐式转换。为了使其有效，
例如，您可以使用 <code class="docutils literal notranslate"><span class="pre">[int8(1),</span> <span class="pre">-1]</span></code>。</p>
<p>由于不同类型的固定大小的内存数组不能相互转换（即使基类可以），
如果您想使用二维数组字面常数，您必须总是明确指定一个共同的基类：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIOS4i+mdoueahOaWueazleS4jeS8mui1t+S9nOeUqO+8jOWboOS4uuS4gOS6m+WGhemDqOaVsOe7hOeahOexu+Wei+S4jeWvueOAggogICAgICAgIC8vIHVpbnRbMl1bNF0gbWVtb3J5IHggPSBbWzB4MSwgMV0sIFsweGZmZmZmZiwgMl0sIFsweGZmLCAzXSwgWzB4ZmZmZiwgNF1dOwogICAgICAgIHJldHVybiB4OwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint24</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][</span><span class="m m-Decimal">4</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint24</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][</span><span class="m m-Decimal">4</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="kt">uint24</span><span class="p">(</span><span class="mh">0x1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mh">0xffffff</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">uint24</span><span class="p">(</span><span class="mh">0xff</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">uint24</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">]];</span>
<span class="w">        </span><span class="c1">// 下面的方法不会起作用，因为一些内部数组的类型不对。</span>
<span class="w">        </span><span class="c1">// uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>固定大小的内存数组不能分配给动态大小的内存数组，也就是说，以下情况是不可能的：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8g6L+Z5LiN5Lya6KKr57yW6K+R44CCCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyB7CiAgICAgICAgLy8g5LiL5LiA6KGM5Lya5Lqn55Sf5LiA5Liq57G75Z6L6ZSZ6K+v77yM5Zug5Li6dWludFszXeWGheWtmOS4jeiDveiiq+i9rOaNouS4unVpbnRbXeWGheWtmOOAggogICAgICAgIHVpbnRbXSBtZW1vcnkgeCA9IFt1aW50KDEpLCAzLCA0XTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 这不会被编译。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 下一行会产生一个类型错误，因为uint[3]内存不能被转换为uint[]内存。</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>计划在将来取消这一限制，但由于ABI中数组的传递方式，它产生了一些复杂的问题。</p>
<p>如果您想初始化动态大小的数组，您必须分配各个元素：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span><span class="m m-Decimal">3</span><span class="p">);</span>
<span class="w">        </span>x<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">        </span>x<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
<span class="w">        </span>x<span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="array-members">
<span id="index-21"></span><span id="id32"></span><h5>数组成员<a class="headerlink" href="#array-members" title="此标题的永久链接"></a></h5>
<dl class="simple">
<dt><strong>length</strong>:</dt><dd><p>数组有 <code class="docutils literal notranslate"><span class="pre">length</span></code> 成员变量表示当前数组的长度。一经创建，
内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。</p>
</dd>
<dt><strong>push()</strong>:</dt><dd><p>动态存储数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> （不是 <code class="docutils literal notranslate"><span class="pre">string</span></code> ）有一个叫 <code class="docutils literal notranslate"><span class="pre">push()</span></code> 的成员函数，
您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用，
因此可以像 <code class="docutils literal notranslate"><span class="pre">x.push().t</span> <span class="pre">=</span> <span class="pre">2</span></code> 或 <code class="docutils literal notranslate"><span class="pre">x.push()</span> <span class="pre">=</span> <span class="pre">b</span></code> 那样使用。</p>
</dd>
<dt><strong>push(x)</strong>:</dt><dd><p>动态存储数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> （不是 <code class="docutils literal notranslate"><span class="pre">string</span></code> ）有一个叫 <code class="docutils literal notranslate"><span class="pre">push(x)</span></code> 的成员函数，
您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。</p>
</dd>
<dt><strong>pop()</strong>:</dt><dd><p>动态存储数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> （不是 <code class="docutils literal notranslate"><span class="pre">string</span></code> ）有一个叫 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 的成员函数，
您可以用它来从数组的末端移除一个元素。
这也隐含地在被删除的元素上调用 <a class="reference internal" href="#delete"><span class="std std-ref">delete</span></a>。该函数不返回任何东西。</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>通过调用 <code class="docutils literal notranslate"><span class="pre">push()</span></code> 增加存储数组的长度有恒定的气体成本，因为存储是零初始化的，
而通过调用 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 减少长度的成本取决于被移除元素的 &quot;大小&quot;。
如果该元素是一个数组，它的成本可能非常高，
因为它包括明确地清除被移除的元素，类似于对它们调用 <a class="reference internal" href="#delete"><span class="std std-ref">delete</span></a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>要在外部（而不是公开）函数中使用数组的数组，
您需要激活ABI coder v2。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在Byzantium之前的EVM版本中，不可能访问从函数调用返回的动态数组。
如果您调用返回动态数组的函数，请确保使用设置为Byzantium模式的EVM。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIOivt+azqOaEj++8jOS4i+mdouS4jeaYr+S4gOWvueWKqOaAgeaVsOe7hO+8jAogICAgLy8g6ICM5piv5LiA5Liq5Yqo5oCB5pWw57uE5a+577yI5Y2z6ZW/5bqm5Li6MueahOWbuuWumuWkp+Wwj+aVsOe7hO+8ieOAggogICAgLy8g5ZyoIFNvbGlkaXR5IOS4re+8jFRba13lkoxUW13mgLvmmK/lhbfmnIlU57G75Z6L5YWD57Sg55qE5pWw57uE77yMCiAgICAvLyDljbPkvb9U5pys6Lqr5piv5LiA5Liq5pWw57uE44CCCiAgICAvLyDmraPlm6DkuLrlpoLmraTvvIxib29sWzJdW13mmK/kuIDkuKrliqjmgIHmlbDnu4Tlr7nvvIzlhbblhYPntKDmmK9ib29sWzJd44CCCiAgICAvLyDov5nkuI7lhbbku5bor63oqIDkuI3lkIzvvIzmr5TlpoJD77yMCiAgICAvLyDmiYDmnInnirbmgIHlj5jph4/nmoTmlbDmja7kvY3nva7pg73mmK/lrZjlgqjjgIIKICAgIGJvb2xbMl1bXSBwYWlyc09mRmxhZ3M7CgogICAgLy8gbmV3UGFpcnPooqvlrZjlgqjlnKhtZW1vcnnkuK0tLei/meaYr+WFrOW8gOWQiOe6puWHveaVsOWPguaVsOeahOWUr+S4gOWPr+iDveaAp+OAggogICAgZnVuY3Rpb24gc2V0QWxsRmxhZ1BhaXJzKGJvb2xbMl1bXSBtZW1vcnkgbmV3UGFpcnMpIHB1YmxpYyB7CiAgICAgICAgLy8g6LWL5YC85Yiw5LiA5Liq5a2Y5YKo5pWw57uE5Lya5omn6KGMIGBgbmV3UGFpcnNgYCDnmoTmi7fotJ3vvIwKICAgICAgICAvLyDlubbmm7/mjaLlrozmlbTnmoTmlbDnu4QgYGBwYWlyc09mRmxhZ3NgYOOAggogICAgICAgIHBhaXJzT2ZGbGFncyA9IG5ld1BhaXJzOwogICAgfQoKICAgIHN0cnVjdCBTdHJ1Y3RUeXBlIHsKICAgICAgICB1aW50W10gY29udGVudHM7CiAgICAgICAgdWludCBtb3JlSW5mbzsKICAgIH0KICAgIFN0cnVjdFR5cGUgczsKCiAgICBmdW5jdGlvbiBmKHVpbnRbXSBtZW1vcnkgYykgcHVibGljIHsKICAgICAgICAvLyDlnKggYGBnYGAg5Lit5a2Y5YKo5LiA5Liq5a+5IGBgc2BgIOeahOW8leeUqOOAggogICAgICAgIFN0cnVjdFR5cGUgc3RvcmFnZSBnID0gczsKICAgICAgICAvLyDkuZ/mlLnlj5jkuoYgYGBzLm1vcmVJbmZvYGAuCiAgICAgICAgZy5tb3JlSW5mbyA9IDI7CiAgICAgICAgLy8g5oyH5a6a5LiA5Liq5ou36LSd77yM5Zug5Li6IGBgZy5jb250ZW50c2BgIOS4jeaYr+S4gOS4quWxgOmDqOWPmOmHj++8jAogICAgICAgIC8vIOiAjOaYr+S4gOS4quWxgOmDqOWPmOmHj+eahOaIkOWRmOOAggogICAgICAgIGcuY29udGVudHMgPSBjOwogICAgfQoKICAgIGZ1bmN0aW9uIHNldEZsYWdQYWlyKHVpbnQgaW5kZXgsIGJvb2wgZmxhZ0EsIGJvb2wgZmxhZ0IpIHB1YmxpYyB7CiAgICAgICAgLy8g6K6/6Zeu5LiA5Liq5LiN5a2Y5Zyo55qE5pWw57uE57Si5byV5Lya5byV5Y+R5LiA5Liq5byC5bi4CiAgICAgICAgcGFpcnNPZkZsYWdzW2luZGV4XVswXSA9IGZsYWdBOwogICAgICAgIHBhaXJzT2ZGbGFnc1tpbmRleF1bMV0gPSBmbGFnQjsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VGbGFnQXJyYXlTaXplKHVpbnQgbmV3U2l6ZSkgcHVibGljIHsKICAgICAgICAvLyDkvb/nlKhwdXNo5ZKMcG9w5piv5pS55Y+Y5pWw57uE6ZW/5bqm55qE5ZSv5LiA5pa55rOV44CCCiAgICAgICAgaWYgKG5ld1NpemUgPCBwYWlyc09mRmxhZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHdoaWxlIChwYWlyc09mRmxhZ3MubGVuZ3RoID4gbmV3U2l6ZSkKICAgICAgICAgICAgICAgIHBhaXJzT2ZGbGFncy5wb3AoKTsKICAgICAgICB9IGVsc2UgaWYgKG5ld1NpemUgPiBwYWlyc09mRmxhZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHdoaWxlIChwYWlyc09mRmxhZ3MubGVuZ3RoIDwgbmV3U2l6ZSkKICAgICAgICAgICAgICAgIHBhaXJzT2ZGbGFncy5wdXNoKCk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGNsZWFyKCkgcHVibGljIHsKICAgICAgICAvLyDov5nkupvlrozlhajmuIXpmaTkuobmlbDnu4QKICAgICAgICBkZWxldGUgcGFpcnNPZkZsYWdzOwogICAgICAgIGRlbGV0ZSBhTG90T2ZJbnRlZ2VyczsKICAgICAgICAvLyDov5nph4zmnInnm7jlkIznmoTmlYjmnpwKICAgICAgICBwYWlyc09mRmxhZ3MgPSBuZXcgYm9vbFsyXVtdKDApOwogICAgfQoKICAgIGJ5dGVzIGJ5dGVEYXRhOwoKICAgIGZ1bmN0aW9uIGJ5dGVBcnJheXMoYnl0ZXMgbWVtb3J5IGRhdGEpIHB1YmxpYyB7CiAgICAgICAgLy8g5a2X6IqC5pWw57uE77yIImJ5dGUi77yJ5piv5LiN5ZCM55qE77yM5Zug5Li65a6D5Lus55qE5a2Y5YKo5rKh5pyJ5aGr5YWF77yMCiAgICAgICAgLy8g5L2G5Y+v5Lul5LiOICJ1aW50OFtdIuebuOWQjOOAggogICAgICAgIGJ5dGVEYXRhID0gZGF0YTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCA3OyBpKyspCiAgICAgICAgICAgIGJ5dGVEYXRhLnB1c2goKTsKICAgICAgICBieXRlRGF0YVszXSA9IDB4MDg7CiAgICAgICAgZGVsZXRlIGJ5dGVEYXRhWzJdOwogICAgfQoKICAgIGZ1bmN0aW9uIGFkZEZsYWcoYm9vbFsyXSBtZW1vcnkgZmxhZykgcHVibGljIHJldHVybnMgKHVpbnQpIHsKICAgICAgICBwYWlyc09mRmxhZ3MucHVzaChmbGFnKTsKICAgICAgICByZXR1cm4gcGFpcnNPZkZsYWdzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlBcnJheSh1aW50IHNpemUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkgewogICAgICAgIC8vIOS9v+eUqCBgbmV3YCDliJvlu7rliqjmgIEgbWVtb3J5IOaVsOe7hO+8mgogICAgICAgIHVpbnRbMl1bXSBtZW1vcnkgYXJyYXlPZlBhaXJzID0gbmV3IHVpbnRbMl1bXShzaXplKTsKCiAgICAgICAgLy8g5YaF6IGU5pWw57uE5oC75piv6Z2Z5oCB5aSn5bCP55qE77yM5aaC5p6c5oKo5Y+q5L2/55So5a2X6Z2i5bi45pWw6KGo6L6+5byP77yM5oKo5b+F6aG76Iez5bCR5o+Q5L6b5LiA56eN57G75Z6L44CCCiAgICAgICAgYXJyYXlPZlBhaXJzWzBdID0gW3VpbnQoMSksIDJdOwoKICAgICAgICAvLyDliJvlu7rkuIDkuKrliqjmgIHlrZfoioLmlbDnu4TvvJoKICAgICAgICBieXRlcyBtZW1vcnkgYiA9IG5ldyBieXRlcygyMDApOwogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspCiAgICAgICAgICAgIGJbaV0gPSBieXRlczEodWludDgoaSkpOwogICAgICAgIHJldHVybiBiOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">ArrayContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="o">**</span><span class="m m-Decimal">20</span><span class="p">]</span><span class="w"> </span>aLotOfIntegers<span class="p">;</span>
<span class="w">    </span><span class="c1">// 请注意，下面不是一对动态数组，</span>
<span class="w">    </span><span class="c1">// 而是一个动态数组对（即长度为2的固定大小数组）。</span>
<span class="w">    </span><span class="c1">// 在 Solidity 中，T[k]和T[]总是具有T类型元素的数组，</span>
<span class="w">    </span><span class="c1">// 即使T本身是一个数组。</span>
<span class="w">    </span><span class="c1">// 正因为如此，bool[2][]是一个动态数组对，其元素是bool[2]。</span>
<span class="w">    </span><span class="c1">// 这与其他语言不同，比如C，</span>
<span class="w">    </span><span class="c1">// 所有状态变量的数据位置都是存储。</span>
<span class="w">    </span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][]</span><span class="w"> </span>pairsOfFlags<span class="p">;</span>

<span class="w">    </span><span class="c1">// newPairs被存储在memory中--这是公开合约函数参数的唯一可能性。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setAllFlagPairs</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>newPairs<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 赋值到一个存储数组会执行 ``newPairs`` 的拷贝，</span>
<span class="w">        </span><span class="c1">// 并替换完整的数组 ``pairsOfFlags``。</span>
<span class="w">        </span>pairsOfFlags<span class="w"> </span><span class="o">=</span><span class="w"> </span>newPairs<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">StructType</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>contents<span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">moreInfo</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>StructType<span class="w"> </span>s<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>c<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 在 ``g`` 中存储一个对 ``s`` 的引用。</span>
<span class="w">        </span>StructType<span class="w"> </span>storage<span class="w"> </span>g<span class="w"> </span><span class="o">=</span><span class="w"> </span>s<span class="p">;</span>
<span class="w">        </span><span class="c1">// 也改变了 ``s.moreInfo``.</span>
<span class="w">        </span>g<span class="p">.</span>moreInfo<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 指定一个拷贝，因为 ``g.contents`` 不是一个局部变量，</span>
<span class="w">        </span><span class="c1">// 而是一个局部变量的成员。</span>
<span class="w">        </span>g<span class="p">.</span>contents<span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setFlagPair</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">index</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">flagA</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">flagB</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 访问一个不存在的数组索引会引发一个异常</span>
<span class="w">        </span>pairsOfFlags<span class="p">[</span>index<span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>flagA<span class="p">;</span>
<span class="w">        </span>pairsOfFlags<span class="p">[</span>index<span class="p">][</span><span class="m m-Decimal">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>flagB<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeFlagArraySize</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newSize</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用push和pop是改变数组长度的唯一方法。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>newSize<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>pairsOfFlags<span class="p">.</span>length<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>pairsOfFlags<span class="p">.</span>length<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>newSize<span class="p">)</span>
<span class="w">                </span>pairsOfFlags<span class="p">.</span>pop<span class="p">();</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kt">else</span><span class="w"> </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>newSize<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>pairsOfFlags<span class="p">.</span>length<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>pairsOfFlags<span class="p">.</span>length<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>newSize<span class="p">)</span>
<span class="w">                </span>pairsOfFlags<span class="p">.</span>push<span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">clear</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这些完全清除了数组</span>
<span class="w">        </span>delete<span class="w"> </span>pairsOfFlags<span class="p">;</span>
<span class="w">        </span>delete<span class="w"> </span>aLotOfIntegers<span class="p">;</span>
<span class="w">        </span><span class="c1">// 这里有相同的效果</span>
<span class="w">        </span>pairsOfFlags<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][](</span><span class="m m-Decimal">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">byteData</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">byteArrays</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>data<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 字节数组（&quot;byte&quot;）是不同的，因为它们的存储没有填充，</span>
<span class="w">        </span><span class="c1">// 但可以与 &quot;uint8[]&quot;相同。</span>
<span class="w">        </span>byteData<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">;</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span>
<span class="w">            </span>byteData<span class="p">.</span>push<span class="p">();</span>
<span class="w">        </span>byteData<span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x08</span><span class="p">;</span>
<span class="w">        </span>delete<span class="w"> </span>byteData<span class="p">[</span><span class="m m-Decimal">2</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">addFlag</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>flag<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>pairsOfFlags<span class="p">.</span>push<span class="p">(</span>flag<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>pairsOfFlags<span class="p">.</span>length<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createMemoryArray</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">size</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 `new` 创建动态 memory 数组：</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>arrayOfPairs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][](</span>size<span class="p">);</span>

<span class="w">        </span><span class="c1">// 内联数组总是静态大小的，如果您只使用字面常数表达式，您必须至少提供一种类型。</span>
<span class="w">        </span>arrayOfPairs<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// 创建一个动态字节数组：</span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span><span class="m m-Decimal">200</span><span class="p">);</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>b<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span>
<span class="w">            </span>b<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes1<span class="p">(</span><span class="kt">uint8</span><span class="p">(</span>i<span class="p">));</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="dangling-references">
<span id="index-22"></span><h5>对存储数组元素的悬空引用（Dangling References）<a class="headerlink" href="#dangling-references" title="此标题的永久链接"></a></h5>
<p>当使用存储数组时，您需要注意避免悬空引用。
悬空引用是指一个指向不再存在的或已经被移动而未更新引用的内容的引用。
例如，如果您将一个数组元素的引用存储在一个局部变量中，
然后从包含数组中使用 <code class="docutils literal notranslate"><span class="pre">.pop()</span></code>，就可能发生悬空引用：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W11bXSBzOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIOWtmOWCqOS4gOS4quaMh+WQkXPnmoTmnIDlkI7kuIDkuKrmlbDnu4TlhYPntKDnmoTmjIfpkojjgIIKICAgICAgICB1aW50W10gc3RvcmFnZSBwdHIgPSBzW3MubGVuZ3RoIC0gMV07CiAgICAgICAgLy8g5Yig6Zmkc+eahOacgOWQjuS4gOS4quaVsOe7hOWFg+e0oOOAggogICAgICAgIHMucG9wKCk7CiAgICAgICAgLy8g5YaZ5YWl5bey5LiN5Zyo5pWw57uE5YaF55qE5pWw57uE5YWD57Sg44CCCiAgICAgICAgcHRyLnB1c2goMHg0Mik7CiAgICAgICAgLy8g546w5Zyo5ZCRIGBgc2BgIOa3u+WKoOS4gOS4quaWsOWFg+e0oOS4jeS8mua3u+WKoOS4gOS4quepuuaVsOe7hO+8jAogICAgICAgIC8vIOiAjOaYr+S8muS6p+eUn+S4gOS4qumVv+W6puS4ujHnmoTmlbDnu4TvvIzlhYPntKDkuLogYGAweDQyYGDjgIIKICAgICAgICBzLnB1c2goKTsKICAgICAgICBhc3NlcnQoc1tzLmxlbmd0aCAtIDFdWzBdID09IDB4NDIpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span>s<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 存储一个指向s的最后一个数组元素的指针。</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>ptr<span class="w"> </span><span class="o">=</span><span class="w"> </span>s<span class="p">[</span>s<span class="p">.</span>length<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">];</span>
<span class="w">        </span><span class="c1">// 删除s的最后一个数组元素。</span>
<span class="w">        </span>s<span class="p">.</span>pop<span class="p">();</span>
<span class="w">        </span><span class="c1">// 写入已不在数组内的数组元素。</span>
<span class="w">        </span>ptr<span class="p">.</span>push<span class="p">(</span><span class="mh">0x42</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 现在向 ``s`` 添加一个新元素不会添加一个空数组，</span>
<span class="w">        </span><span class="c1">// 而是会产生一个长度为1的数组，元素为 ``0x42``。</span>
<span class="w">        </span>s<span class="p">.</span>push<span class="p">();</span>
<span class="w">        </span>assert<span class="p">(</span>s<span class="p">[</span>s<span class="p">.</span>length<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x42</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ptr.push(0x42)</span></code> 中的写法 <strong>不会</strong> 恢复操作，尽管 <code class="docutils literal notranslate"><span class="pre">ptr</span></code> 不再指向 <code class="docutils literal notranslate"><span class="pre">s</span></code> 的一个有效元素。
由于编译器假定未使用的存储空间总是被清零，
随后的 <code class="docutils literal notranslate"><span class="pre">s.push()</span></code> 不会明确地将零写入存储空间，
所以在 <code class="docutils literal notranslate"><span class="pre">push()</span></code> 之后， <code class="docutils literal notranslate"><span class="pre">s</span></code> 的最后一个元素的长度是 <code class="docutils literal notranslate"><span class="pre">1</span></code>，
并且包含 <code class="docutils literal notranslate"><span class="pre">0x42</span></code> 作为其第一个元素。</p>
<p>注意，Solidity 不允许在存储中声明对值类型的引用。
这类显式的悬空引用被限制在嵌套引用类型中。然而，
当在数组赋值中使用复杂表达式时，悬空引用也会短暂发生：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W10gczsKICAgIHVpbnRbXSB0OwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8g5ZCR5a2Y5YKo5pWw57uE5o6o6YCB5LiA5Lqb5Yid5aeL5YC844CCCiAgICAgICAgcy5wdXNoKDB4MDcpOwogICAgICAgIHQucHVzaCgweDAzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkgaW50ZXJuYWwgcmV0dXJucyAodWludFtdIHN0b3JhZ2UpIHsKICAgICAgICBzLnBvcCgpOwogICAgICAgIHJldHVybiB0OwogICAgfQoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIC8vIOS4i+mdouWwhummluWFiOivhOS8sCBgYHMucHVzaCgpYCDliLDkuIDkuKrntKLlvJXkuLox55qE5paw5YWD57Sg55qE5byV55So44CCCiAgICAgICAgLy8g5LmL5ZCO77yM6LCD55SoIGBgZ2BgIOW8ueWHuui/meS4quaWsOWFg+e0oO+8jAogICAgICAgIC8vIOWvvOiHtOacgOW3pui+ueeahOWFg+e7hOWFg+e0oOaIkOS4uuS4gOS4quaCrOepuueahOW8leeUqOOAggogICAgICAgIC8vIOi1i+WAvOS7jeeEtuWPkeeUn++8jOW5tuWwhuWGmeWFpSBgYHNgYCDnmoTmlbDmja7ljLrln5/kuYvlpJbjgIIKICAgICAgICAocy5wdXNoKCksIGcoKVswXSkgPSAoMHg0MiwgMHgxNyk7CiAgICAgICAgLy8g6ZqP5ZCO5a+5IGBgc2BgIOeahOaOqOmAgeWwhuaYvuekuuWJjeS4gOS4quivreWPpeWGmeWFpeeahOWAvO+8jAogICAgICAgIC8vIOWNs+WcqOi/meS4quWHveaVsOe7k+adn+aXtiBgYHNgYCDnmoTmnIDlkI7kuIDkuKrlhYPntKDlsIbmnIkgYGAweDQyYGAg55qE5YC844CCCiAgICAgICAgcy5wdXNoKCk7CiAgICAgICAgcmV0dXJuIHM7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>s<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>t<span class="p">;</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 向存储数组推送一些初始值。</span>
<span class="w">        </span>s<span class="p">.</span>push<span class="p">(</span><span class="mh">0x07</span><span class="p">);</span>
<span class="w">        </span>t<span class="p">.</span>push<span class="p">(</span><span class="mh">0x03</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>s<span class="p">.</span>pop<span class="p">();</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>t<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 下面将首先评估 ``s.push()` 到一个索引为1的新元素的引用。</span>
<span class="w">        </span><span class="c1">// 之后，调用 ``g`` 弹出这个新元素，</span>
<span class="w">        </span><span class="c1">// 导致最左边的元组元素成为一个悬空的引用。</span>
<span class="w">        </span><span class="c1">// 赋值仍然发生，并将写入 ``s`` 的数据区域之外。</span>
<span class="w">        </span><span class="p">(</span>s<span class="p">.</span>push<span class="p">(),</span><span class="w"> </span>g<span class="p">()[</span><span class="m m-Decimal">0</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="mh">0x17</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 随后对 ``s`` 的推送将显示前一个语句写入的值，</span>
<span class="w">        </span><span class="c1">// 即在这个函数结束时 ``s`` 的最后一个元素将有 ``0x42`` 的值。</span>
<span class="w">        </span>s<span class="p">.</span>push<span class="p">();</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>s<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>每条语句只对存储进行一次赋值，并避免在赋值的左侧使用复杂的表达式，这样做总是比较安全的。</p>
<p>您需要特别小心处理对 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 数组元素的引用，
因为 bytes 数组的  <code class="docutils literal notranslate"><span class="pre">.push()</span></code> 操作可能会 <a class="reference internal" href="index.html#bytes-and-string"><span class="std std-ref">在存储中从短布局切换到长布局</span></a>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKLy8g6L+Z5bCG5oql5ZGK5LiA5Liq6K2m5ZGKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgeCA9ICIwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkiOwoKICAgIGZ1bmN0aW9uIHRlc3QoKSBleHRlcm5hbCByZXR1cm5zKHVpbnQpIHsKICAgICAgICAoeC5wdXNoKCksIHgucHVzaCgpKSA9ICgweDAxLCAweDAyKTsKICAgICAgICByZXR1cm4geC5sZW5ndGg7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 这将报告一个警告</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;012345678901234567890123456789&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span>x<span class="p">.</span>push<span class="p">(),</span><span class="w"> </span>x<span class="p">.</span>push<span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="p">.</span>length<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里，当第一个 <code class="docutils literal notranslate"><span class="pre">x.push()</span></code> 被运算时， <code class="docutils literal notranslate"><span class="pre">x</span></code> 仍然被存储在短布局中，
因此 <code class="docutils literal notranslate"><span class="pre">x.push()</span></code> 返回对 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的第一个存储槽中元素的引用。
然而，第二个 <code class="docutils literal notranslate"><span class="pre">x.push()</span></code> 将字节数组切换为长布局。
现在 <code class="docutils literal notranslate"><span class="pre">x.push()</span></code> 所指的元素在数组的数据区，
而引用仍然指向它原来的位置，现在它是长度字段的一部分，
赋值将有效地扰乱 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的长度。
为了安全起见，在一次赋值中最多只放大字节数组中的一个元素，
不要在同一语句中同时对数组进行索引存取。</p>
<p>虽然上面描述了当前版本的编译器中悬空存储引用的行为，
但任何带有悬空引用的代码都应被视为具有 <em>未定义行为</em>。
特别的是，这意味着任何未来版本的编译器都可能改变涉及悬空引用的代码的行为。</p>
<p>请确保避免在您的代码中出现悬空引用。</p>
</section>
</section>
<section id="array-slices">
<span id="index-23"></span><span id="id33"></span><h4>数组切片<a class="headerlink" href="#array-slices" title="此标题的永久链接"></a></h4>
<p>数组切片是对一个数组的连续部分的预览。
它们被写成 <code class="docutils literal notranslate"><span class="pre">x[start:end]</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">start</span></code> 和 <code class="docutils literal notranslate"><span class="pre">end</span></code> 是表达式，
结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 <code class="docutils literal notranslate"><span class="pre">x[start]</span></code>，
最后一个元素是 <code class="docutils literal notranslate"><span class="pre">x[end</span> <span class="pre">-</span> <span class="pre">1]</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">start</span></code> 大于 <code class="docutils literal notranslate"><span class="pre">end</span></code>，或者 <code class="docutils literal notranslate"><span class="pre">end</span></code> 大于数组的长度，
就会出现异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">start</span></code> 和 <code class="docutils literal notranslate"><span class="pre">end</span></code> 都是可选的： <code class="docutils literal notranslate"><span class="pre">start</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，
<code class="docutils literal notranslate"><span class="pre">end</span></code> 默认为数组的长度。</p>
<p>数组切片没有任何成员。它们可以隐含地转换为其底层类型的数组并支持索引访问。
索引访问在底层数组中不是绝对的，而是相对于分片的开始。</p>
<p>数组切片没有类型名，这意味着任何变量都不能以数组切片为类型，
它们只存在于中间表达式中。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>到现在为止，数组切片只有calldata数组可以实现。</p>
</div>
<p>数组切片对于ABI解码在函数参数中传递的二级数据很有用：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiDnlLHku6PnkIbnrqHnkIbnmoTlrqLmiLflkIjnuqbnmoTlnLDlnYDvvIzljbPmnKzlkIjnuqbnmoTlnLDlnYAKICAgIGFkZHJlc3MgY2xpZW50OwoKICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MgY2xpZW50XykgewogICAgICAgIGNsaWVudCA9IGNsaWVudF87CiAgICB9CgogICAgLy8vIOi9rOWPkeWvuSAic2V0T3duZXIoYWRkcmVzcykiIOeahOiwg+eUqO+8jAogICAgLy8vIOivpeiwg+eUqOWcqOWvueWcsOWdgOWPguaVsOi/m+ihjOWfuuacrOmqjOivgeWQjueUseWuouaIt+err+aJp+ihjOOAggogICAgZnVuY3Rpb24gZm9yd2FyZChieXRlcyBjYWxsZGF0YSBwYXlsb2FkKSBleHRlcm5hbCB7CiAgICAgICAgYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkWzo0XSk7CiAgICAgICAgLy8g55Sx5LqO5oiq5pat6KGM5Li677yMYnl0ZXM0KHBheWxvYWQp55qE6KGo546w5piv55u45ZCM55qE44CCCiAgICAgICAgLy8gYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkKTsKICAgICAgICBpZiAoc2lnID09IGJ5dGVzNChrZWNjYWsyNTYoInNldE93bmVyKGFkZHJlc3MpIikpKSB7CiAgICAgICAgICAgIGFkZHJlc3Mgb3duZXIgPSBhYmkuZGVjb2RlKHBheWxvYWRbNDpdLCAoYWRkcmVzcykpOwogICAgICAgICAgICByZXF1aXJlKG93bmVyICE9IGFkZHJlc3MoMCksICJBZGRyZXNzIG9mIG93bmVyIGNhbm5vdCBiZSB6ZXJvLiIpOwogICAgICAgIH0KICAgICAgICAoYm9vbCBzdGF0dXMsKSA9IGNsaWVudC5kZWxlZ2F0ZWNhbGwocGF5bG9hZCk7CiAgICAgICAgcmVxdWlyZShzdGF0dXMsICJGb3J3YXJkZWQgY2FsbCBmYWlsZWQuIik7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.5</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Proxy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// @dev 由代理管理的客户合约的地址，即本合约的地址</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">client</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">client_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>client<span class="w"> </span><span class="o">=</span><span class="w"> </span>client_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 转发对 &quot;setOwner(address)&quot; 的调用，</span>
<span class="w">    </span><span class="c1">/// 该调用在对地址参数进行基本验证后由客户端执行。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">forward</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">calldata</span><span class="w"> </span>payload<span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>bytes4<span class="w"> </span>sig<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes4<span class="p">(</span>payload<span class="p">[</span><span class="o">:</span><span class="m m-Decimal">4</span><span class="p">]);</span>
<span class="w">        </span><span class="c1">// 由于截断行为，bytes4(payload)的表现是相同的。</span>
<span class="w">        </span><span class="c1">// bytes4 sig = bytes4(payload);</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>sig<span class="w"> </span><span class="o">==</span><span class="w"> </span>bytes4<span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="s2">&quot;setOwner(address)&quot;</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>abi<span class="p">.</span>decode<span class="p">(</span>payload<span class="p">[</span><span class="m m-Decimal">4</span><span class="o">:</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">));</span>
<span class="w">            </span><span class="kt">require</span><span class="p">(</span>owner<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;Address of owner cannot be zero.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">status</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>client<span class="p">.</span>delegatecall<span class="p">(</span>payload<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>status<span class="p">,</span><span class="w"> </span><span class="s2">&quot;Forwarded call failed.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="structs">
<span id="index-24"></span><span id="id34"></span><h4>结构体<a class="headerlink" href="#structs" title="此标题的永久链接"></a></h4>
<p>Solidity 提供了一种以结构形式定义新类型的方法，以下是一个结构体使用的示例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g5a6a5LmJ5LiA5Liq5YyF5ZCr5Lik5Liq5bGe5oCn55qE5paw57G75Z6L44CCCi8vIOWcqOWQiOe6puS5i+WkluWjsOaYjuS4gOS4que7k+aehO+8jAovLyDlj6/ku6XorqnlroPooqvlpJrkuKrlkIjnuqbmiYDlhbHkuqvjgIIKLy8g5Zyo6L+Z6YeM77yM6L+Z5bm25LiN5piv55yf55qE6ZyA6KaB44CCCnN0cnVjdCBGdW5kZXIgewogICAgYWRkcmVzcyBhZGRyOwogICAgdWludCBhbW91bnQ7Cn0KCmNvbnRyYWN0IENyb3dkRnVuZGluZyB7CiAgICAvLyDnu5PmnoTkvZPkuZ/lj6/ku6XooqvlrprkuYnlnKjlkIjnuqblhoXpg6jvvIzov5nkvb/lvpflroPku6zlj6rlnKjmnKzlkIjnuqblkozmtL7nlJ/lkIjnuqbkuK3lj6/op4HjgIIKICAgIHN0cnVjdCBDYW1wYWlnbiB7CiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5OwogICAgICAgIHVpbnQgZnVuZGluZ0dvYWw7CiAgICAgICAgdWludCBudW1GdW5kZXJzOwogICAgICAgIHVpbnQgYW1vdW50OwogICAgICAgIG1hcHBpbmcgKHVpbnQgPT4gRnVuZGVyKSBmdW5kZXJzOwogICAgfQoKICAgIHVpbnQgbnVtQ2FtcGFpZ25zOwogICAgbWFwcGluZyAodWludCA9PiBDYW1wYWlnbikgY2FtcGFpZ25zOwoKICAgIGZ1bmN0aW9uIG5ld0NhbXBhaWduKGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeSwgdWludCBnb2FsKSBwdWJsaWMgcmV0dXJucyAodWludCBjYW1wYWlnbklEKSB7CiAgICAgICAgY2FtcGFpZ25JRCA9IG51bUNhbXBhaWducysrOyAvLyBjYW1wYWlnbklEIOS9nOS4uuS4gOS4quWPmOmHj+i/lOWbngogICAgICAgIC8vIOaIkeS7rOS4jeiDveS9v+eUqCAiY2FtcGFpZ25zW2NhbXBhaWduSURdID0gQ2FtcGFpZ24oYmVuZWZpY2lhcnksIGdvYWwsIDAsIDApIgogICAgICAgIC8vIOWboOS4uuWPs+S+p+WIm+W7uuS6huS4gOS4quWGheWtmOe7k+aehCAiQ2FtcGFpZ24i77yM5YW25Lit5YyF5ZCr5LiA5Liq5pig5bCE44CCCiAgICAgICAgQ2FtcGFpZ24gc3RvcmFnZSBjID0gY2FtcGFpZ25zW2NhbXBhaWduSURdOwogICAgICAgIGMuYmVuZWZpY2lhcnkgPSBiZW5lZmljaWFyeTsKICAgICAgICBjLmZ1bmRpbmdHb2FsID0gZ29hbDsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250cmlidXRlKHVpbnQgY2FtcGFpZ25JRCkgcHVibGljIHBheWFibGUgewogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICAvLyDku6Xnu5nlrprnmoTlgLzliJ3lp4vljJbvvIzliJvlu7rkuIDkuKrmlrDnmoTkuLTml7YgbWVtb3J5IOe7k+aehOS9k++8jAogICAgICAgIC8vIOW5tuWwhuWFtuaLt+i0neWIsCBzdG9yYWdlIOS4reOAggogICAgICAgIC8vIOazqOaEj+aCqOS5n+WPr+S7peS9v+eUqCBGdW5kZXIobXNnLnNlbmRlciwgbXNnLnZhbHVlKSDmnaXliJ3lp4vljJbjgIIKICAgICAgICBjLmZ1bmRlcnNbYy5udW1GdW5kZXJzKytdID0gRnVuZGVyKHthZGRyOiBtc2cuc2VuZGVyLCBhbW91bnQ6IG1zZy52YWx1ZX0pOwogICAgICAgIGMuYW1vdW50ICs9IG1zZy52YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGVja0dvYWxSZWFjaGVkKHVpbnQgY2FtcGFpZ25JRCkgcHVibGljIHJldHVybnMgKGJvb2wgcmVhY2hlZCkgewogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICBpZiAoYy5hbW91bnQgPCBjLmZ1bmRpbmdHb2FsKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgdWludCBhbW91bnQgPSBjLmFtb3VudDsKICAgICAgICBjLmFtb3VudCA9IDA7CiAgICAgICAgYy5iZW5lZmljaWFyeS50cmFuc2ZlcihhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 定义一个包含两个属性的新类型。</span>
<span class="c1">// 在合约之外声明一个结构，</span>
<span class="c1">// 可以让它被多个合约所共享。</span>
<span class="c1">// 在这里，这并不是真的需要。</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">Funder</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">CrowdFunding</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 结构体也可以被定义在合约内部，这使得它们只在本合约和派生合约中可见。</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Campaign</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>beneficiary<span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">fundingGoal</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">numFunders</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">;</span>
<span class="w">        </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Funder<span class="p">)</span><span class="w"> </span>funders<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">numCampaigns</span><span class="p">;</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Campaign<span class="p">)</span><span class="w"> </span>campaigns<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">newCampaign</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>beneficiary<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">goal</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">campaignID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>campaignID<span class="w"> </span><span class="o">=</span><span class="w"> </span>numCampaigns<span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// campaignID 作为一个变量返回</span>
<span class="w">        </span><span class="c1">// 我们不能使用 &quot;campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)&quot;</span>
<span class="w">        </span><span class="c1">// 因为右侧创建了一个内存结构 &quot;Campaign&quot;，其中包含一个映射。</span>
<span class="w">        </span>Campaign<span class="w"> </span>storage<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>campaigns<span class="p">[</span>campaignID<span class="p">];</span>
<span class="w">        </span>c<span class="p">.</span>beneficiary<span class="w"> </span><span class="o">=</span><span class="w"> </span>beneficiary<span class="p">;</span>
<span class="w">        </span>c<span class="p">.</span>fundingGoal<span class="w"> </span><span class="o">=</span><span class="w"> </span>goal<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contribute</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">campaignID</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>Campaign<span class="w"> </span>storage<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>campaigns<span class="p">[</span>campaignID<span class="p">];</span>
<span class="w">        </span><span class="c1">// 以给定的值初始化，创建一个新的临时 memory 结构体，</span>
<span class="w">        </span><span class="c1">// 并将其拷贝到 storage 中。</span>
<span class="w">        </span><span class="c1">// 注意您也可以使用 Funder(msg.sender, msg.value) 来初始化。</span>
<span class="w">        </span>c<span class="p">.</span>funders<span class="p">[</span>c<span class="p">.</span>numFunders<span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>Funder<span class="p">({</span>addr<span class="o">:</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>amount<span class="o">:</span><span class="w"> </span><span class="k">msg.value</span><span class="p">});</span>
<span class="w">        </span>c<span class="p">.</span>amount<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">checkGoalReached</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">campaignID</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">reached</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>Campaign<span class="w"> </span>storage<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>campaigns<span class="p">[</span>campaignID<span class="p">];</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>c<span class="p">.</span>amount<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>c<span class="p">.</span>fundingGoal<span class="p">)</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>amount<span class="p">;</span>
<span class="w">        </span>c<span class="p">.</span>amount<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">        </span>c<span class="p">.</span>beneficiary<span class="p">.</span>transfer<span class="p">(</span>amount<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的合约并没有提供众筹合约的全部功能，
但它包含了理解结构体所需的基本概念。
结构类型可以在映射和数组内使用，
它们本身可以包含映射和数组。</p>
<p>结构体不可能包含其自身类型的成员，尽管结构本身可以是映射成员的值类型，
或者它可以包含其类型的动态大小的数组。
这一限制是必要的，因为结构的大小必须是有限的。</p>
<p>注意在所有的函数中，结构类型被分配到数据位置为 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 的局部变量。
这并不是拷贝结构体，而只是存储一个引用，
因此对本地变量成员的赋值实际上是写入状态。</p>
<p>当然，您也可以直接访问该结构的成员，
而不把它分配给本地变量，如 <code class="docutils literal notranslate"><span class="pre">campaigns[campaignID].amount</span> <span class="pre">=</span> <span class="pre">0</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Solidity 0.7.0 之前，包含仅有存储类型（例如映射）的成员的内存结构是允许的，
像上面例子中的 <code class="docutils literal notranslate"><span class="pre">campaigns[campaignID]</span> <span class="pre">=</span> <span class="pre">Campaign(beneficiary,</span> <span class="pre">goal,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> 这样的赋值是可以的，
只是会默默地跳过这些成员。</p>
</div>
</section>
</section>
<section id="mapping-types">
<span id="index-25"></span><span id="id35"></span><h3>映射类型<a class="headerlink" href="#mapping-types" title="此标题的永久链接"></a></h3>
<p>映射类型使用语法 <code class="docutils literal notranslate"><span class="pre">mapping(KeyType</span> <span class="pre">=&gt;</span> <span class="pre">ValueType)</span></code>，
映射类型的变量使用语法 <code class="docutils literal notranslate"><span class="pre">mapping(KeyType</span> <span class="pre">=&gt;</span> <span class="pre">ValueType)</span> <span class="pre">VariableName</span></code> 声明。
<code class="docutils literal notranslate"><span class="pre">KeyType</span></code> 可以是任何内置的值类型， <code class="docutils literal notranslate"><span class="pre">bytes</span></code>， <code class="docutils literal notranslate"><span class="pre">string</span></code>，或任何合约或枚举类型。
其他用户定义的或复杂的类型，如映射，结构体或数组类型是不允许的。
<code class="docutils literal notranslate"><span class="pre">ValueType</span></code> 可以是任何类型，包括映射，数组和结构体。</p>
<p>您可以把映射想象成 <a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>，
它实际上被初始化了，使每一个可能的键都存在，
并将其映射到字节形式全是零的值，一个类型的 <a class="reference internal" href="index.html#default-value"><span class="std std-ref">默认值</span></a>。
相似性到此为止，键数据不存储在映射中，而是它的 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 哈希值被用来查询。</p>
<p>正因为如此，映射没有长度，也没有被设置的键或值的概念，
因此，如果没有关于分配的键的额外信息，就不能被删除（见 <a class="reference internal" href="index.html#clearing-mappings"><span class="std std-ref">清除映射</span></a>）。</p>
<p>映射只能有一个 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 的数据位置，因此允许用于状态变量，
可作为函数中的存储引用类型，或作为库函数的参数。
但它们不能被用作公开可见的合约函数的参数或返回参数。
这些限制对于包含映射的数组和结构也是如此。</p>
<p>您可以把映射类型的状态变量标记为 <code class="docutils literal notranslate"><span class="pre">public</span></code>，
Solidit y会为您创建一个 <a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">getter</span></a> 函数。
<code class="docutils literal notranslate"><span class="pre">KeyType</span></code> 将成为 getter 函数的参数。
如果 <code class="docutils literal notranslate"><span class="pre">ValueType</span></code> 是一个值类型或一个结构，getter 返回 <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>。
如果 <code class="docutils literal notranslate"><span class="pre">ValueType</span></code> 是一个数组或映射，getter 对每个 <code class="docutils literal notranslate"><span class="pre">KeyType</span></code> 递归出一个参数。</p>
<p>在下面的例子中， <code class="docutils literal notranslate"><span class="pre">MappingExample</span></code> 合约定义了一个公共的 <code class="docutils literal notranslate"><span class="pre">balances</span></code> 映射，
键类型是 <code class="docutils literal notranslate"><span class="pre">address</span></code>，值类型是 <code class="docutils literal notranslate"><span class="pre">uint</span></code>，将一个Ethereum地址映射到一个无符号整数值。
由于 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 是一个值类型，getter 返回一个与该类型相匹配的值，
您可以在 <code class="docutils literal notranslate"><span class="pre">MappingUser</span></code> 合约中看到它返回指定地址对应的值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">MappingExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>balances<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">update</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newBalance</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>newBalance<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">MappingUser</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>MappingExample<span class="w"> </span>m<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>MappingExample<span class="p">();</span>
<span class="w">        </span>m<span class="p">.</span>update<span class="p">(</span><span class="m m-Decimal">100</span><span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>m<span class="p">.</span>balances<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面的例子是一个简化版本的
<a class="reference external" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC20 代币</a>。
<code class="docutils literal notranslate"><span class="pre">_allowances</span></code> 是一个映射类型在另一个映射类型中的例子。
下面的例子使用 <code class="docutils literal notranslate"><span class="pre">_allowances</span></code> 来记录别人允许从您的账户中提取的金额。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQyNTYpIHByaXZhdGUgX2JhbGFuY2VzOwogICAgbWFwcGluZyAoYWRkcmVzcyA9PiBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">MappingExample</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>_balances<span class="p">;</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">))</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>_allowances<span class="p">;</span>

<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>from<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">value</span><span class="p">);</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Approval</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>owner<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>spender<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">value</span><span class="p">);</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">allowance</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">spender</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>_allowances<span class="p">[</span>owner<span class="p">][</span>spender<span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferFrom</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">sender</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_allowances<span class="p">[</span>sender<span class="p">][</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>amount<span class="p">,</span><span class="w"> </span><span class="s2">&quot;ERC20: Allowance not high enough.&quot;</span><span class="p">);</span>
<span class="w">        </span>_allowances<span class="p">[</span>sender<span class="p">][</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>_transfer<span class="p">(</span>sender<span class="p">,</span><span class="w"> </span>recipient<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">approve</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">spender</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>spender<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;ERC20: approve to the zero address&quot;</span><span class="p">);</span>

<span class="w">        </span>_allowances<span class="p">[</span><span class="k">msg.sender</span><span class="p">][</span>spender<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>emit<span class="w"> </span>Approval<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>spender<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">_transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">sender</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>sender<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;ERC20: transfer from the zero address&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>recipient<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;ERC20: transfer to the zero address&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_balances<span class="p">[</span>sender<span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>amount<span class="p">,</span><span class="w"> </span><span class="s2">&quot;ERC20: Not enough funds.&quot;</span><span class="p">);</span>

<span class="w">        </span>_balances<span class="p">[</span>sender<span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>_balances<span class="p">[</span>recipient<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>emit<span class="w"> </span>Transfer<span class="p">(</span>sender<span class="p">,</span><span class="w"> </span>recipient<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="iterable-mappings">
<span id="index-26"></span><span id="id37"></span><h4>递归映射<a class="headerlink" href="#iterable-mappings" title="此标题的永久链接"></a></h4>
<p>您不能对映射进行递归调用，也就是说，您不能列举它们的键。
不过，可以在它们上层实现一个数据结构，并对其进行递归。例如，
下面的代码实现了一个 <code class="docutils literal notranslate"><span class="pre">IterableMapping</span></code> 库， 然后 <code class="docutils literal notranslate"><span class="pre">User</span></code> 合约将数据添加到该库中，
<code class="docutils literal notranslate"><span class="pre">sum</span></code> 函数对所有的值进行递归调用去累加这些值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCnN0cnVjdCBJbmRleFZhbHVlIHsgdWludCBrZXlJbmRleDsgdWludCB2YWx1ZTsgfQpzdHJ1Y3QgS2V5RmxhZyB7IHVpbnQga2V5OyBib29sIGRlbGV0ZWQ7IH0KCnN0cnVjdCBpdG1hcCB7CiAgICBtYXBwaW5nKHVpbnQgPT4gSW5kZXhWYWx1ZSkgZGF0YTsKICAgIEtleUZsYWdbXSBrZXlzOwogICAgdWludCBzaXplOwp9Cgp0eXBlIEl0ZXJhdG9yIGlzIHVpbnQ7CgpsaWJyYXJ5IEl0ZXJhYmxlTWFwcGluZyB7CiAgICBmdW5jdGlvbiBpbnNlcnQoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSwgdWludCB2YWx1ZSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCByZXBsYWNlZCkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBzZWxmLmRhdGFba2V5XS52YWx1ZSA9IHZhbHVlOwogICAgICAgIGlmIChrZXlJbmRleCA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGVsc2UgewogICAgICAgICAgICBrZXlJbmRleCA9IHNlbGYua2V5cy5sZW5ndGg7CiAgICAgICAgICAgIHNlbGYua2V5cy5wdXNoKCk7CiAgICAgICAgICAgIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID0ga2V5SW5kZXggKyAxOwogICAgICAgICAgICBzZWxmLmtleXNba2V5SW5kZXhdLmtleSA9IGtleTsKICAgICAgICAgICAgc2VsZi5zaXplKys7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXkpIGludGVybmFsIHJldHVybnMgKGJvb2wgc3VjY2VzcykgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBpZiAoa2V5SW5kZXggPT0gMCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGRlbGV0ZSBzZWxmLmRhdGFba2V5XTsKICAgICAgICBzZWxmLmtleXNba2V5SW5kZXggLSAxXS5kZWxldGVkID0gdHJ1ZTsKICAgICAgICBzZWxmLnNpemUgLS07CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID4gMDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlU3RhcnQoaXRtYXAgc3RvcmFnZSBzZWxmKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgMCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgSXRlcmF0b3IgaXRlcmF0b3IpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpIDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIEl0ZXJhdG9yIGl0ZXJhdG9yKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgSXRlcmF0b3IudW53cmFwKGl0ZXJhdG9yKSArIDEpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVHZXQoaXRtYXAgc3RvcmFnZSBzZWxmLCBJdGVyYXRvciBpdGVyYXRvcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50IGtleSwgdWludCB2YWx1ZSkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpOwogICAgICAgIGtleSA9IHNlbGYua2V5c1trZXlJbmRleF0ua2V5OwogICAgICAgIHZhbHVlID0gc2VsZi5kYXRhW2tleV0udmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JTa2lwRGVsZXRlZChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIHByaXZhdGUgdmlldyByZXR1cm5zIChJdGVyYXRvcikgewogICAgICAgIHdoaWxlIChrZXlJbmRleCA8IHNlbGYua2V5cy5sZW5ndGggJiYgc2VsZi5rZXlzW2tleUluZGV4XS5kZWxldGVkKQogICAgICAgICAgICBrZXlJbmRleCsrOwogICAgICAgIHJldHVybiBJdGVyYXRvci53cmFwKGtleUluZGV4KTsKICAgIH0KfQoKLy8g5aaC5L2V5L2/55SoCmNvbnRyYWN0IFVzZXIgewogICAgLy8g5Y+q5piv5LiA5Liq5L+d5a2Y5oiR5Lus5pWw5o2u55qE57uT5p6E5L2T44CCCiAgICBpdG1hcCBkYXRhOwogICAgLy8g5a+55pWw5o2u57G75Z6L5bqU55So5bqT5Ye95pWw44CCCiAgICB1c2luZyBJdGVyYWJsZU1hcHBpbmcgZm9yIGl0bWFwOwoKICAgIC8vIOaPkuWFpeS4gOS6m+aVsOaNrgogICAgZnVuY3Rpb24gaW5zZXJ0KHVpbnQgaywgdWludCB2KSBwdWJsaWMgcmV0dXJucyAodWludCBzaXplKSB7CiAgICAgICAgLy8g6L+Z5bCG6LCD55SoIEl0ZXJhYmxlTWFwcGluZy5pbnNlcnQoZGF0YSwgaywgdikKICAgICAgICBkYXRhLmluc2VydChrLCB2KTsKICAgICAgICAvLyDmiJHku6zku43nhLblj6/ku6Xorr/pl67nu5PmnoTkuK3nmoTmiJDlkZjvvIwKICAgICAgICAvLyDkvYbmiJHku6zlupTor6Xms6jmhI/kuI3opoHkubHliqjku5bku6zjgIIKICAgICAgICByZXR1cm4gZGF0YS5zaXplOwogICAgfQoKICAgIC8vIOiuoeeul+aJgOacieWtmOWCqOaVsOaNrueahOaAu+WSjOOAggogICAgZnVuY3Rpb24gc3VtKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCBzKSB7CiAgICAgICAgZm9yICgKICAgICAgICAgICAgSXRlcmF0b3IgaSA9IGRhdGEuaXRlcmF0ZVN0YXJ0KCk7CiAgICAgICAgICAgIGRhdGEuaXRlcmF0ZVZhbGlkKGkpOwogICAgICAgICAgICBpID0gZGF0YS5pdGVyYXRlTmV4dChpKQogICAgICAgICkgewogICAgICAgICAgICAoLCB1aW50IHZhbHVlKSA9IGRhdGEuaXRlcmF0ZUdldChpKTsKICAgICAgICAgICAgcyArPSB2YWx1ZTsKICAgICAgICB9CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.8</span><span class="p">;</span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">IndexValue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">KeyFlag</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">deleted</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">itmap</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>IndexValue<span class="p">)</span><span class="w"> </span>data<span class="p">;</span>
<span class="w">    </span>KeyFlag<span class="p">[]</span><span class="w"> </span>keys<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">size</span><span class="p">;</span>
<span class="p">}</span>

type<span class="w"> </span>Iterator<span class="w"> </span><span class="kt">is</span><span class="w"> </span><span class="kt">uint</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>IterableMapping<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">replaced</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="p">;</span>
<span class="w">        </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>value<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>keyIndex<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>keyIndex<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">.</span>length<span class="p">;</span>
<span class="w">            </span>self<span class="p">.</span>keys<span class="p">.</span>push<span class="p">();</span>
<span class="w">            </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="w"> </span><span class="o">=</span><span class="w"> </span>keyIndex<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">            </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="p">].</span>key<span class="w"> </span><span class="o">=</span><span class="w"> </span>key<span class="p">;</span>
<span class="w">            </span>self<span class="p">.</span>size<span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="p">;</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>keyIndex<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">        </span>delete<span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">];</span>
<span class="w">        </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">].</span>deleted<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span>self<span class="p">.</span>size<span class="w"> </span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contains</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateStart</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>Iterator<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>iteratorSkipDeleted<span class="p">(</span>self<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateValid</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span>Iterator<span class="w"> </span>iterator<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>Iterator<span class="p">.</span>unwrap<span class="p">(</span>iterator<span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">.</span>length<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateNext</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span>Iterator<span class="w"> </span>iterator<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>Iterator<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>iteratorSkipDeleted<span class="p">(</span>self<span class="p">,</span><span class="w"> </span>Iterator<span class="p">.</span>unwrap<span class="p">(</span>iterator<span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateGet</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span>Iterator<span class="w"> </span>iterator<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>Iterator<span class="p">.</span>unwrap<span class="p">(</span>iterator<span class="p">);</span>
<span class="w">        </span>key<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="p">].</span>key<span class="p">;</span>
<span class="w">        </span>value<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iteratorSkipDeleted</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>Iterator<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>keyIndex<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">.</span>length<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="p">].</span>deleted<span class="p">)</span>
<span class="w">            </span>keyIndex<span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>Iterator<span class="p">.</span>wrap<span class="p">(</span>keyIndex<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 如何使用</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">User</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 只是一个保存我们数据的结构体。</span>
<span class="w">    </span>itmap<span class="w"> </span>data<span class="p">;</span>
<span class="w">    </span><span class="c1">// 对数据类型应用库函数。</span>
<span class="w">    </span>using<span class="w"> </span>IterableMapping<span class="w"> </span><span class="kt">for</span><span class="w"> </span>itmap<span class="p">;</span>

<span class="w">    </span><span class="c1">// 插入一些数据</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">k</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这将调用 IterableMapping.insert(data, k, v)</span>
<span class="w">        </span>data<span class="p">.</span>insert<span class="p">(</span>k<span class="p">,</span><span class="w"> </span>v<span class="p">);</span>
<span class="w">        </span><span class="c1">// 我们仍然可以访问结构中的成员，</span>
<span class="w">        </span><span class="c1">// 但我们应该注意不要乱动他们。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>data<span class="p">.</span>size<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 计算所有存储数据的总和。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sum</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span>
<span class="w">            </span>Iterator<span class="w"> </span>i<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>iterateStart<span class="p">();</span>
<span class="w">            </span>data<span class="p">.</span>iterateValid<span class="p">(</span>i<span class="p">);</span>
<span class="w">            </span>i<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>iterateNext<span class="p">(</span>i<span class="p">)</span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">(,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>iterateGet<span class="p">(</span>i<span class="p">);</span>
<span class="w">            </span>s<span class="w"> </span><span class="o">+=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="index-27">
<span id="id38"></span><h3>运算符<a class="headerlink" href="#index-27" title="此标题的永久链接"></a></h3>
<p>即使两个操作数的类型不一样，也可以应用算术和位操作数。
例如，您可以计算 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">z</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>， <code class="docutils literal notranslate"><span class="pre">z</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">int32</span></code>。
在这种情况下，下面的机制将被用来确定计算操作的类型（这在溢出的情况下很重要）和操作结果的类型：</p>
<ol class="arabic simple">
<li><p>如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，</p></li>
<li><p>如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，</p></li>
<li><p>否则的话，该操作不被允许。</p></li>
</ol>
<p>如果其中一个操作数是 <a class="reference internal" href="#rational-literals"><span class="std std-ref">字面常数</span></a>，
它首先被转换为其 “移动类型（mobile type）”，也就是能容纳该值的最小类型
（相同位宽的无符号类型被认为比有符号类型 “小”）。
如果两者都是字面常数，那么运算的精度实际上是无限的，
因为表达式被转换到任何必要的精度，所以当结果被用于非字面类型时，没有任何损失。</p>
<p>操作符的结果类型与操作的类型相同，除了比较操作符，其结果总是 <code class="docutils literal notranslate"><span class="pre">bool</span></code>。</p>
<p>运算符 <code class="docutils literal notranslate"><span class="pre">**</span></code> （幂运算）， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 使用左边操作数的类型进行运算和以其作为结果。</p>
<section id="id39">
<h4>三元运算符<a class="headerlink" href="#id39" title="此标题的永久链接"></a></h4>
<p>三元运算符用于形式为 <code class="docutils literal notranslate"><span class="pre">&lt;条件表达式&gt;</span> <span class="pre">?</span> <span class="pre">&lt;true条件表达式&gt;</span> <span class="pre">:</span> <span class="pre">&lt;false条件表达式&gt;</span></code>。
它根据主要的 <code class="docutils literal notranslate"><span class="pre">&lt;条件表达式&gt;</span></code> 的评估结果，计算后两个给定表达式中的一个。
如果 <code class="docutils literal notranslate"><span class="pre">&lt;条件表达式&gt;</span></code> 评估为 <code class="docutils literal notranslate"><span class="pre">true</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">&lt;true条件表达式&gt;</span></code> 将被计算，否则 <code class="docutils literal notranslate"><span class="pre">&lt;false条件表达式&gt;</span></code> 被被计算。</p>
<p>三元运算符的结果没有有理数类型，即使它的操作数都是有理数字。
结果类型是由两个操作数的类型决定的，方法同上，如果需要的话，首先转换为它们的可移动计算的类型。</p>
<p>因此， <code class="docutils literal notranslate"><span class="pre">255</span> <span class="pre">+</span> <span class="pre">(true</span> <span class="pre">?</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">0)</span></code> 将由于算术溢出而恢复计算。
原因是 <code class="docutils literal notranslate"><span class="pre">(true</span> <span class="pre">?</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">0)</span></code> 是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 类型，这迫使加法也在 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 中进行，
而256超出了这个类型允许的范围。</p>
<p>另一个结果是，像 <code class="docutils literal notranslate"><span class="pre">1.5</span> <span class="pre">+</span> <span class="pre">1.5</span></code> 这样的表达式是有效的，但 <code class="docutils literal notranslate"><span class="pre">1.5</span> <span class="pre">+</span> <span class="pre">(true</span> <span class="pre">?</span> <span class="pre">1.5</span> <span class="pre">:</span> <span class="pre">2.5)</span></code> 却无效。
这是因为前者是一个以无限精度计算的有理表达式，只有它的最终值才是重要的。
后者涉及到将小数有理数转换为整数，这在目前是不允许的。</p>
</section>
<section id="index-28">
<span id="id40"></span><h4>复数和增量/减量运算符<a class="headerlink" href="#index-28" title="此标题的永久链接"></a></h4>
<p>如果 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是一个LValue（即是一个变量或者是可以被分配的东西），
下列运算符可以作为速记：</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">e</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">e</span></code>，运算符 <code class="docutils literal notranslate"><span class="pre">-=</span></code>， <code class="docutils literal notranslate"><span class="pre">*=</span></code>， <code class="docutils literal notranslate"><span class="pre">/=</span></code>， <code class="docutils literal notranslate"><span class="pre">%=</span></code>，
<code class="docutils literal notranslate"><span class="pre">|=</span></code>， <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>， <code class="docutils literal notranslate"><span class="pre">^=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> 都有相应的定义。
<code class="docutils literal notranslate"><span class="pre">a++</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a--</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">1</span></code> / <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-=</span> <span class="pre">1</span></code> 但是表达式本身仍然是以前的值 <code class="docutils literal notranslate"><span class="pre">a</span></code>。
相比之下， <code class="docutils literal notranslate"><span class="pre">--a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">++a</span></code> 对 <code class="docutils literal notranslate"><span class="pre">a</span></code> 有同样的作用，但返回改变后的值。</p>
</section>
<section id="delete">
<span id="index-29"></span><span id="id41"></span><h4>删除<a class="headerlink" href="#delete" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> 为该类型分配初始值 <code class="docutils literal notranslate"><span class="pre">a</span></code>。例如，对于整数来说，它相当于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0</span></code>，
但是它也可以用于数组，它指定一个长度为0的动态数组或者一个相同长度的静态数组，
所有元素都设置为初始值。 <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a[x]</span></code> 删除数组中索引为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的元素，
并保留所有其他元素和数组的长度不动。这特别意味着它在数组中留下一个缺口。
如果您打算删除项目，一个 <a class="reference internal" href="#mapping-types"><span class="std std-ref">映射类型</span></a> 可能是一个更好的选择。</p>
<p>对于结构体，则将结构体中的所有属性重置。换句话说，在 <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> 之后，
<code class="docutils literal notranslate"><span class="pre">a</span></code> 的值与 <code class="docutils literal notranslate"><span class="pre">a</span></code> 在没有赋值的情况下被声明是一样的，但有以下注意事项：</p>
<p><code class="docutils literal notranslate"><span class="pre">delete</span></code> 对映射类型没有影响（因为映射的键可能是任意的，通常是未知的）。
因此，如果您删除一个结构体，它将重置所有不是映射类型的成员，
同时也会递归到这些成员，除非它们是映射。
然而，单个键和它们所映射的内容可以被删除。
如果 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是一个映射，那么 <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a[x]</span></code> 将删除存储在 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值。</p>
<p>值得注意的是， <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> 的行为实际上是对 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的赋值，
也就是说，它在 <code class="docutils literal notranslate"><span class="pre">a</span></code> 中存储了一个新的对象。
当 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是引用变量时，这种区别是明显的。
它只会重置 <code class="docutils literal notranslate"><span class="pre">a</span></code> 本身，而不是它之前引用的值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIOWwhiB4IOiuvuS4uiAw77yM5bm25LiN5b2x5ZONZGF0YeWPmOmHjwogICAgICAgIGRlbGV0ZSBkYXRhOyAvLyDlsIYgZGF0YSDorr7kuLogMO+8jOW5tuS4jeW9seWTjSB4CiAgICAgICAgdWludFtdIHN0b3JhZ2UgeSA9IGRhdGFBcnJheTsKICAgICAgICBkZWxldGUgZGF0YUFycmF5OyAvLyDlsIYgZGF0YUFycmF5Lmxlbmd0aCDorr7kuLogMO+8jOS9hueUseS6jiB1aW50W10g5piv5LiA5Liq5aSN5p2C55qE5a+56LGh77yMCiAgICAgICAgLy8geSDkuZ/lsIblj5fliLDlvbHlk43vvIzlroPmmK/kuIDkuKrlrZjlgqjkvY3nva7mmK8gc3RvcmFnZSDnmoTlr7nosaHnmoTliKvlkI3jgIIKICAgICAgICAvLyDlj6bkuIDmlrnpnaLvvJoiZGVsZXRlIHkiIOaYr+mdnuazleeahO+8jOW8leeUqOS6hiBzdG9yYWdlIOWvueixoeeahOWxgOmDqOWPmOmHj+WPquiDveeUseW3suacieeahCBzdG9yYWdlIOWvueixoei1i+WAvOOAggogICAgICAgIGFzc2VydCh5Lmxlbmd0aCA9PSAwKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">DeleteExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>dataArray<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">;</span>
<span class="w">        </span>delete<span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 将 x 设为 0，并不影响data变量</span>
<span class="w">        </span>delete<span class="w"> </span>data<span class="p">;</span><span class="w"> </span><span class="c1">// 将 data 设为 0，并不影响 x</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span>dataArray<span class="p">;</span>
<span class="w">        </span>delete<span class="w"> </span>dataArray<span class="p">;</span><span class="w"> </span><span class="c1">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，</span>
<span class="w">        </span><span class="c1">// y 也将受到影响，它是一个存储位置是 storage 的对象的别名。</span>
<span class="w">        </span><span class="c1">// 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span>
<span class="w">        </span>assert<span class="p">(</span>y<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="order">
<span id="index-30"></span><span id="id42"></span><h4>运算符的优先顺序<a class="headerlink" href="#order" title="此标题的永久链接"></a></h4>
<p>以下是按评估顺序列出的操作符优先级。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 13%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>优先级</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>操作符</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>1</em></p></td>
<td><p>后置自增和自减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">++</span></code>， <code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>创建类型实例</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">&lt;类型名&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>数组元素</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;数组&gt;[&lt;索引&gt;]</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>访问成员</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;对象&gt;.&lt;成员名&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>函数调用</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;函数&gt;(&lt;参数...&gt;)</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>小括号</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(&lt;表达式&gt;)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>2</em></p></td>
<td><p>前置自增和自减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">++</span></code>， <code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>一元运算减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>一元操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">delete</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>逻辑非</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">!</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>按位非</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>3</em></p></td>
<td><p>乘方</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>4</em></p></td>
<td><p>乘、除和模运算</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>5</em></p></td>
<td><p>算术加和减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code>， <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>6</em></p></td>
<td><p>移位操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>7</em></p></td>
<td><p>按位与</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>8</em></p></td>
<td><p>按位异或</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>9</em></p></td>
<td><p>按位或</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>10</em></p></td>
<td><p>非等操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>11</em></p></td>
<td><p>等于操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>12</em></p></td>
<td><p>逻辑与</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>13</em></p></td>
<td><p>逻辑或</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>14</em></p></td>
<td><p>三元操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;判断条件&gt;</span> <span class="pre">?</span> <span class="pre">&lt;如果为真时执行的表达式&gt;</span> <span class="pre">:</span> <span class="pre">&lt;如果为假时执行的表达式&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>赋值操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code>， <code class="docutils literal notranslate"><span class="pre">|=</span></code>， <code class="docutils literal notranslate"><span class="pre">^=</span></code>， <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">+=</span></code>， <code class="docutils literal notranslate"><span class="pre">-=</span></code>， <code class="docutils literal notranslate"><span class="pre">*=</span></code>， <code class="docutils literal notranslate"><span class="pre">/=</span></code>， <code class="docutils literal notranslate"><span class="pre">%=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>15</em></p></td>
<td><p>逗号</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">,</span></code></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="types-conversion-elementary-types">
<span id="index-31"></span><span id="id43"></span><h3>基本类型之间的转换<a class="headerlink" href="#types-conversion-elementary-types" title="此标题的永久链接"></a></h3>
<section id="id44">
<h4>隐式转换<a class="headerlink" href="#id44" title="此标题的永久链接"></a></h4>
<p>在某些情况下，在赋值过程中，在向函数传递参数和应用运算符时，
编译器会自动应用隐式类型转换。一般来说，如果在语义上有意义，
并且不会丢失信息，那么值-类型之间的隐式转换是可能的。</p>
<p>例如， <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 可以转换为 <code class="docutils literal notranslate"><span class="pre">uint16</span></code>， <code class="docutils literal notranslate"><span class="pre">int128</span></code> 可以转换为 <code class="docutils literal notranslate"><span class="pre">int256</span></code>，
但是 <code class="docutils literal notranslate"><span class="pre">int8</span></code> 不能转换为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 不能容纳 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 这样的值。</p>
<p>如果一个运算符被应用于不同的类型，
编译器会尝试将其中一个操作数隐含地转换为另一个的类型（对于赋值也是如此）。
这意味着操作总是以其中一个操作数的类型进行。</p>
<p>关于哪些隐式转换是可能的，请参考关于类型本身的章节。</p>
<p>在下面的例子中， <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code>，即加法的操作数，没有相同的类型，
但是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 可以隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint16</span></code>，反之则不行。正因为如此，
<code class="docutils literal notranslate"><span class="pre">y</span></code> 被转换为 <code class="docutils literal notranslate"><span class="pre">z</span></code> 的类型，然后在 <code class="docutils literal notranslate"><span class="pre">uint16</span></code> 类型中进行加法。
结果表达式 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">z</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint16</span></code>。
因为它被分配到一个 <code class="docutils literal notranslate"><span class="pre">uint32</span></code> 类型的变量中，所以在加法后又进行了一次隐式转换。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span>
<span class="kt">uint16</span><span class="w"> </span><span class="nv">z</span><span class="p">;</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>y<span class="w"> </span><span class="o">+</span><span class="w"> </span>z<span class="p">;</span>
</pre></div>
</div>
</section>
<section id="id45">
<h4>显式转换<a class="headerlink" href="#id45" title="此标题的永久链接"></a></h4>
<p>如果编译器不允许隐式转换，但您确信转换会成功，
有时可以进行显式类型转换。
这可能会导致意想不到的行为，并使您绕过编译器的一些安全特性，
所以一定要测试结果是否是您想要的和期望的!</p>
<p>以下面的例子为例，将一个负的 <code class="docutils literal notranslate"><span class="pre">int</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">uint</span></code>：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w">  </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="m m-Decimal">3</span><span class="p">;</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint</span><span class="p">(</span>y<span class="p">);</span>
</pre></div>
</div>
<p>在这个代码片断的最后， <code class="docutils literal notranslate"><span class="pre">x</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">0xfffff..fd</span></code> 的值（64个十六进制字符），
这在256位的二进制补码中表示是-3。</p>
<p>如果一个整数被明确地转换为一个较小的类型，高阶位就会被切断：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiDnjrDlnKjkvJrmmK8gMHg1Njc4"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="p">;</span>
<span class="kt">uint16</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint16</span><span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x5678</span>
</pre></div>
</div>
<p>如果一个整数被明确地转换为一个更大的类型，它将在左边被填充（即在高阶的一端）。
转换的结果将与原整数比较相等：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDAwMDAxMjM0CmFzc2VydChhID09IGIpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32</span><span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x00001234</span>
assert<span class="p">(</span>a<span class="w"> </span><span class="o">==</span><span class="w"> </span>b<span class="p">);</span>
</pre></div>
</div>
<p>固定大小的字节类型在转换过程中的行为是不同的。
它们可以被认为是单个字节的序列，转换到一个较小的类型将切断序列：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEy"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span>
bytes1<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes1<span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x12</span>
</pre></div>
</div>
<p>如果一个固定大小的字节类型被明确地转换为一个更大的类型，它将在右边被填充。
访问固定索引的字节将导致转换前后的数值相同（如果索引仍在范围内）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEyMzQwMDAwCmFzc2VydChhWzBdID09IGJbMF0pOwphc3NlcnQoYVsxXSA9PSBiWzFdKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span>
bytes4<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes4<span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x12340000</span>
assert<span class="p">(</span>a<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>b<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]);</span>
assert<span class="p">(</span>a<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>b<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">]);</span>
</pre></div>
</div>
<p>于整数和固定大小的字节数组在截断或填充时表现不同，
只有在整数和固定大小的字节数组具有相同大小的情况下，才允许在两者之间进行显式转换。
如果您想在不同大小的整数和固定大小的字节数组之间进行转换，您必须使用中间转换，
使所需的截断和填充规则明确：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiIOWwhuS8muaYryAweDAwMDAxMjM0CnVpbnQzMiBjID0gdWludDMyKGJ5dGVzNChhKSk7IC8vIGMg5bCG5Lya5pivIDB4MTIzNDAwMDAKdWludDggZCA9IHVpbnQ4KHVpbnQxNihhKSk7IC8vIGQg5bCG5Lya5pivIDB4MzQKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUg5bCG5Lya5pivIDB4MTI="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint16</span><span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 将会是 0x00001234</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32</span><span class="p">(</span>bytes4<span class="p">(</span>a<span class="p">));</span><span class="w"> </span><span class="c1">// c 将会是 0x12340000</span>
<span class="kt">uint8</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint8</span><span class="p">(</span><span class="kt">uint16</span><span class="p">(</span>a<span class="p">));</span><span class="w"> </span><span class="c1">// d 将会是 0x34</span>
<span class="kt">uint8</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint8</span><span class="p">(</span>bytes1<span class="p">(</span>a<span class="p">));</span><span class="w"> </span><span class="c1">// e 将会是 0x12</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> calldata 切片可以明确转换为固定字节类型（ <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> /.../ <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>）。
如果数组比目标的固定字节类型长，在末端会发生截断的情况。如果数组比目标类型短，它将在末尾被填充零。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vIOWmguaenG3nmoTplb/luqblpKfkuo4xNu+8jOWwhuWPkeeUn+aIquaWreOAggogICAgICAgIGIgPSBieXRlczE2KHMpOyAgLy8g5Y+z6L656L+b6KGM5aGr5YWF77yM5omA5Lul57uT5p6c5pivICJhYmNkZWZnaFwwXDBcMFwwXDBcMFwwXDAiCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyDlj5HnlJ/miKrmlq0sIGIxIOebuOW9k+S6jiAiYWJjIgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIOWQjOagt+eUqDDov5vooYzloavlhYUKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.5</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;abcdefgh&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">calldata</span><span class="w"> </span>c<span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>m<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes16</span><span class="p">,</span><span class="w"> </span>bytes3<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>c<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">16</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bytes16</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes16</span><span class="p">(</span>m<span class="p">);</span><span class="w">  </span><span class="c1">// 如果m的长度大于16，将发生截断。</span>
<span class="w">        </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes16</span><span class="p">(</span>s<span class="p">);</span><span class="w">  </span><span class="c1">// 右边进行填充，所以结果是 &quot;abcdefgh\0\0\0\0\0\0\0\0&quot;</span>
<span class="w">        </span>bytes3<span class="w"> </span>b1<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes3<span class="p">(</span>s<span class="p">);</span><span class="w"> </span><span class="c1">// 发生截断, b1 相当于 &quot;abc&quot;</span>
<span class="w">        </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes16</span><span class="p">(</span>c<span class="p">[</span><span class="o">:</span><span class="m m-Decimal">8</span><span class="p">]);</span><span class="w">  </span><span class="c1">// 同样用0进行填充</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>b<span class="p">,</span><span class="w"> </span>b1<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="types-conversion-literals">
<span id="id46"></span><h3>字面常数和基本类型之间的转换<a class="headerlink" href="#types-conversion-literals" title="此标题的永久链接"></a></h3>
<section id="id47">
<h4>整数类型<a class="headerlink" href="#id47" title="此标题的永久链接"></a></h4>
<p>十进制和十六进制的数字字面常数可以隐含地转换为任何足够大的整数类型去表示它而不被截断：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDggYSA9IDEyOyAvLyDlj6/ooYwKdWludDMyIGIgPSAxMjM0OyAvLyDlj6/ooYwKdWludDE2IGMgPSAweDEyMzQ1NjsgLy8g5oql6ZSZLCDlm6DkuLrov5nlsIbkvJrmiKrmlq3miJAgMHgzNDU2"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
<span class="kt">uint16</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x123456</span><span class="p">;</span><span class="w"> </span><span class="c1">// 报错, 因为这将会截断成 0x3456</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.8.0版本之前，任何十进制或十六进制的数字字面常数都可以显式转换为整数类型。
从0.8.0开始，这种显式转换和隐式转换一样严格，也就是说，只有当字面意义符合所产生的范围时，才允许转换。</p>
</div>
</section>
<section id="id48">
<h4>固定大小的字节数组<a class="headerlink" href="#id48" title="此标题的永久链接"></a></h4>
<p>十进制数字字面常数不能被隐含地转换为固定大小的字节数组。
十六进制数字字面常数是可以的，但只有当十六进制数字的数量正好符合字节类型的大小时才可以。
但是有一个例外，数值为0的十进制和十六进制数字字面常数都可以被转换为任何固定大小的字节类型：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8g5LiN5YWB6K64CmJ5dGVzMiBiID0gMHgxMjsgLy8g5LiN5YWB6K64CmJ5dGVzMiBjID0gMHgxMjM7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IDB4MTIzNDsgLy8g5Y+v6KGMCmJ5dGVzMiBlID0gMHgwMDEyOyAvLyDlj6/ooYwKYnl0ZXM0IGYgPSAwOyAvLyDlj6/ooYwKYnl0ZXM0IGcgPSAweDA7IC8vIOWPr+ihjA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">54321</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x123</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>d<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes2<span class="w"> </span>e<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0012</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes4<span class="w"> </span>f<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes4<span class="w"> </span>g<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
</pre></div>
</div>
<p>字符串和十六进制字符串字面常数可以被隐含地转换为固定大小的字节数组，
如果它们的字符数与字节类型的大小相匹配：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIOWPr+ihjApieXRlczIgYiA9ICJ4eSI7IC8vIOWPr+ihjApieXRlczIgYyA9IGhleCIxMiI7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IGhleCIxMjMiOyAvLyDkuI3lhYHorrgKYnl0ZXMyIGUgPSAieCI7IC8vIOS4jeWFgeiuuApieXRlczIgZiA9ICJ4eXoiOyAvLyDkuI3lhYHorrg="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;1234&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes2<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;xy&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes2<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;12&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>d<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;123&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>e<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>f<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;xyz&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
</pre></div>
</div>
</section>
<section id="id49">
<h4>地址类型<a class="headerlink" href="#id49" title="此标题的永久链接"></a></h4>
<p>正如在 <a class="reference internal" href="#address-literals"><span class="std std-ref">地址字面常数（Address Literals）</span></a> 中所描述的那样，正确大小并通过校验测试的十六进制字是 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。
其他字面常数不能隐含地转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。</p>
<p>只允许从 <code class="docutils literal notranslate"><span class="pre">bytes20</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint160</span></code> 显式转换到 <code class="docutils literal notranslate"><span class="pre">address</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">a</span></code> 可以通过 <code class="docutils literal notranslate"><span class="pre">payable(a)</span></code> 显式转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.8.0 版本之前，可以显式地从任何整数类型（任何大小，有符号或无符号）转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 或 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型。
从 0.8.0 开始，只允许从 <code class="docutils literal notranslate"><span class="pre">uint160</span></code> 转换。</p>
</div>
</section>
</section>
</section>
<span id="document-units-and-global-variables"></span><section id="id1">
<h2>单位和全局变量<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<section id="ether">
<span id="index-0"></span><h3>以太币（Ether） 单位<a class="headerlink" href="#ether" title="此标题的永久链接"></a></h3>
<p>一个字面常数可以带一个后缀 <code class="docutils literal notranslate"><span class="pre">wei</span></code>， <code class="docutils literal notranslate"><span class="pre">gwei</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ether</span></code> 来指定一个以太币的数量，
其中没有后缀的以太数字被认为单位是wei。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YXNzZXJ0KDEgd2VpID09IDEpOwphc3NlcnQoMSBnd2VpID09IDFlOSk7CmFzc2VydCgxIGV0aGVyID09IDFlMTgpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>assert<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>wei<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>
assert<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>gwei<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="err">1</span>e9<span class="p">);</span>
assert<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="err">1</span>e18<span class="p">);</span>
</pre></div>
</div>
<p>单位后缀的唯一作用是乘以10的幂次方。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>0.7.0 版本中删除了 <code class="docutils literal notranslate"><span class="pre">finney</span></code> 和 <code class="docutils literal notranslate"><span class="pre">szabo</span></code> 这两个单位。</p>
</div>
</section>
<section id="index-1">
<span id="id2"></span><h3>时间单位<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>诸如 <code class="docutils literal notranslate"><span class="pre">seconds</span></code>， <code class="docutils literal notranslate"><span class="pre">minutes</span></code>， <code class="docutils literal notranslate"><span class="pre">hours</span></code>， <code class="docutils literal notranslate"><span class="pre">days</span></code> 和 <code class="docutils literal notranslate"><span class="pre">weeks</span></code> 等
后缀在字面常数后面，可以用来指定时间单位，其中秒是基本单位，单位的考虑方式很直白：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">seconds</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">minutes</span> <span class="pre">==</span> <span class="pre">60</span> <span class="pre">seconds</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">hours</span> <span class="pre">==</span> <span class="pre">60</span> <span class="pre">minutes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">days</span> <span class="pre">==</span> <span class="pre">24</span> <span class="pre">hours</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">weeks</span> <span class="pre">==</span> <span class="pre">7</span> <span class="pre">days</span></code></p></li>
</ul>
<p>如果您使用这些单位进行日历计算，请注意，由于 <a class="reference external" href="https://en.wikipedia.org/wiki/Leap_second">闰秒</a>
会造成不是每一年都等于365天，甚至不是每一天都有24小时，而且因为闰秒是无法预测的，
所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于上述原因，在 0.5.0 版本中删除了后缀 <code class="docutils literal notranslate"><span class="pre">years</span></code>。</p>
</div>
<p>这些后缀单位不能应用于变量。例如，
如果您想用时间单位（例如 days）来将输入变量换算为时间，您可以用以下方式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gZih1aW50IHN0YXJ0LCB1aW50IGRheXNBZnRlcikgcHVibGljIHsKICAgIGlmIChibG9jay50aW1lc3RhbXAgPj0gc3RhcnQgKyBkYXlzQWZ0ZXIgKiAxIGRheXMpIHsKICAgICAgLy8gLi4uCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">start</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">daysAfter</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>start<span class="w"> </span><span class="o">+</span><span class="w"> </span>daysAfter<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>days<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="special-variables-functions">
<span id="id4"></span><h3>特殊变量和函数<a class="headerlink" href="#special-variables-functions" title="此标题的永久链接"></a></h3>
<p>有一些特殊的变量和函数总是存在于全局命名空间，主要用于提供区块链的信息，或者是通用的工具函数。</p>
<section id="index-2">
<span id="id5"></span><h4>区块和交易属性<a class="headerlink" href="#index-2" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">blockhash(uint</span> <span class="pre">blockNumber)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: 当 <code class="docutils literal notranslate"><span class="pre">blocknumber</span></code> 是最近的256个区块之一时，给定区块的哈希值；否则返回0。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.basefee</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前区块的基本费用 （ <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.chainid</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前链的ID</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.coinbase</span></code> （ <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>）： 挖出当前区块的矿工地址</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.difficulty</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 挖出当前区块的矿工地址</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.gaslimit</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前区块 gas 限额</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.number</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前区块号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 自 unix epoch 起始到当前区块以秒计的时间戳</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gasleft()</span> <span class="pre">returns</span> <span class="pre">(uint256)</span></code>： 剩余的 gas</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.data</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">calldata</span></code>）： 完整的  calldata</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> （ <code class="docutils literal notranslate"><span class="pre">address</span></code>）： 消息发送者（当前调用）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.sig</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes4</span></code>）： calldata 的前 4 字节（也就是函数标识符）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.value</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 随消息发送的 wei 的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx.gasprice</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 随消息发送的 wei 的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx.origin</span></code> （ <code class="docutils literal notranslate"><span class="pre">address</span></code>）： 交易发起者（完全的调用链）</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于每一个 <strong>外部（external）</strong> 函数调用，
包括 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 在内所有 <code class="docutils literal notranslate"><span class="pre">msg</span></code> 成员的值都会变化。
这里包括对库函数的调用。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当合约在链下而不是在区块中包含的交易的背景下计算时，
您不应该认为 <code class="docutils literal notranslate"><span class="pre">block.*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tx.*</span></code> 是指任何特定区块或交易的值。
这些值是由执行合约的EVM实现提供的，可以是任意的。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>不要依赖 <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">blockhash</span></code> 产生随机数，除非您知道自己在做什么。</p>
<p>时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。
例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，
而如果他们没收到钱，还可以用一个不同的哈希重新尝试。</p>
<p>当前区块的时间戳必须严格大于最后一个区块的时间戳，
但这里唯一能确保的只是它会是在权威链上的两个连续区块的时间戳之间的数值。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>基于可扩展因素，区块哈希不是对所有区块都有效。
您仅仅可以访问最近 256 个区块的哈希，其余的哈希均为零。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>函数 <code class="docutils literal notranslate"><span class="pre">blockhash</span></code> 以前被称为 <code class="docutils literal notranslate"><span class="pre">block.blockhash</span></code>，
在 0.4.22 版本中被废弃，在 0.5.0 版本中被删除。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>函数 <code class="docutils literal notranslate"><span class="pre">gasleft</span></code> 的前身是 <code class="docutils literal notranslate"><span class="pre">msg.gas</span></code>，
在 0.4.21 版本中被弃用，在 0.5.0 版本中被删除。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.7.0 版本中，删除了别名 <code class="docutils literal notranslate"><span class="pre">now``（用于</span> <span class="pre">``block.timestamp</span></code>）。</p>
</div>
</section>
<section id="abi">
<span id="index-3"></span><h4>ABI编码和解码函数<a class="headerlink" href="#abi" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abi.decode(bytes</span> <span class="pre">memory</span> <span class="pre">encodedData,</span> <span class="pre">(...))</span> <span class="pre">returns</span> <span class="pre">(...)</span></code>: ABI-解码给定的数据，而类型在括号中作为第二个参数给出。例如： <code class="docutils literal notranslate"><span class="pre">(uint</span> <span class="pre">a,</span> <span class="pre">uint[2]</span> <span class="pre">memory</span> <span class="pre">b,</span> <span class="pre">bytes</span> <span class="pre">memory</span> <span class="pre">c)</span> <span class="pre">=</span> <span class="pre">abi.decode(data,</span> <span class="pre">(uint,</span> <span class="pre">uint[2],</span> <span class="pre">bytes))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encode(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对给定的参数进行ABI编码</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodePacked(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对给定参数执行 <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">紧打包编码</span></a>。 请注意，打包编码可能会有歧义!</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(bytes4</span> <span class="pre">selector,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： ABI-对给定参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeWithSignature(string</span> <span class="pre">memory</span> <span class="pre">signature,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 相当于 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(bytes4(keccak256(bytes(signature))),</span> <span class="pre">...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeCall(function</span> <span class="pre">functionPointer,</span> <span class="pre">(...))</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对 <code class="docutils literal notranslate"><span class="pre">函数指针</span></code> 的调用进行ABI编码，参数在元组中找到。执行全面的类型检查，确保类型与函数签名相符。结果相当于 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(functionPointer.selector,</span> <span class="pre">(...))</span></code>。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这些编码函数可用于制作外部函数调用的数据，而无需实际调用外部函数。
此外， <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encodePacked(a,</span> <span class="pre">b))</span></code> 是一种计算结构化数据的哈希值的方法
（但是要注意有可能使用不同的函数参数类型会制作出一个 &quot;哈希碰撞&quot;）。</p>
</div>
<p>更多详情请参考 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a> 和 <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">紧打包编码</span></a>。</p>
</section>
<section id="index-4">
<span id="id6"></span><h4>字节类型的成员<a class="headerlink" href="#index-4" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bytes.concat(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>: <a class="reference internal" href="index.html#bytes-concat"><span class="std std-ref">将可变数量的字节和byte1, ..., byte32参数串联成一个字节数组</span></a></p></li>
</ul>
</section>
<section id="index-5">
<span id="id7"></span><h4>字符串的成员<a class="headerlink" href="#index-5" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">string.concat(...)</span> <span class="pre">returns</span> <span class="pre">(string</span> <span class="pre">memory)</span></code>: <a class="reference internal" href="index.html#string-concat"><span class="std std-ref">将可变数量的字符串参数串联成一个字符串数组</span></a></p></li>
</ul>
</section>
<section id="index-6">
<span id="id8"></span><h4>错误处理<a class="headerlink" href="#index-6" title="此标题的永久链接"></a></h4>
<p>关于错误处理和何时使用哪个函数的更多细节，
请参见 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">assert 和 require</span></a> 的专门章节。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">assert(bool</span> <span class="pre">condition)</span></code></dt><dd><p>如果条件不满足，会导致异常，因此，状态变化会被恢复 - 用于内部错误。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">require(bool</span> <span class="pre">condition)</span></code></dt><dd><p>如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">require(bool</span> <span class="pre">condition,</span> <span class="pre">string</span> <span class="pre">memory</span> <span class="pre">message)</span></code></dt><dd><p>如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误，可以同时提供一个错误消息。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revert()</span></code></dt><dd><p>终止运行并恢复状态更改。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revert(string</span> <span class="pre">memory</span> <span class="pre">reason)</span></code></dt><dd><p>终止运行并恢复状态更改，可以同时提供一个解释性的字符串。</p>
</dd>
</dl>
</section>
<section id="mathematical-and-cryptographic-functions">
<span id="index-7"></span><span id="id9"></span><h4>数学和密码学函数<a class="headerlink" href="#mathematical-and-cryptographic-functions" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code></dt><dd><p>计算 <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code>，加法会在任意精度下执行，并且加法的结果即使超过 <code class="docutils literal notranslate"><span class="pre">2**256</span></code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> 的校验（assert）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mulmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code></dt><dd><p>计算 <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code>，乘法会在任意精度下执行，并且乘法的结果即使超过 <code class="docutils literal notranslate"><span class="pre">2**256</span></code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> 的校验（assert）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keccak256(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code></dt><dd><p>计算输入的 Keccak-256 哈希值。</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>以前 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 的别名叫 <code class="docutils literal notranslate"><span class="pre">sha3</span></code> ，在 0.5.0 版本中被删除。</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">sha256(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code></dt><dd><p>计算输入的 SHA-256 哈希值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ripemd160(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes20)</span></code></dt><dd><p>计算输入的 RIPEMD-160 哈希值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecrecover(bytes32</span> <span class="pre">hash,</span> <span class="pre">uint8</span> <span class="pre">v,</span> <span class="pre">bytes32</span> <span class="pre">r,</span> <span class="pre">bytes32</span> <span class="pre">s)</span> <span class="pre">returns</span> <span class="pre">(address)</span></code></dt><dd><p>利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。
函数参数对应于签名的 ECDSA 值：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> = 签名的前32字节</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> = 签名的第二个32字节</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> = 签名的最后1个字节</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">ecrecover</span></code> 返回一个 <code class="docutils literal notranslate"><span class="pre">address</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。
参见 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 进行转换，以备您需要向恢复的地址转移资金。</p>
<p>更多细节，请阅读 <a class="reference external" href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">使用示例</a>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果您使用 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>，请注意，一个有效的签名可以变成另一个有效的签名，而不需要知道相应的私钥。
在 Homestead 硬分叉中，这个问题对 _transaction_ 签名进行了修复
（见 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-2#specification">EIP-2</a>），
但 ecrecover 函数仍然没有改变。</p>
<p>这通常不是一个问题，除非您要求签名是唯一的，或者用它们来识别个体。
OpenZeppelin 有一个 <a class="reference external" href="https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA">ECDSA 辅助库</a>，
您可以用它作为 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code> 的包装，那样就没有这个问题。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当在 <em>私有区块链</em> 上运行 <code class="docutils literal notranslate"><span class="pre">sha256</span></code>， <code class="docutils literal notranslate"><span class="pre">ripemd160</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code> 时，您可能会遇到超出 gas（Out-of-Gas）的错误。这是因为这些功能是作为 “预编译合约” 实现的，只有在它们收到第一个消息后才真正存在（尽管它们的合约代码是硬编码的）。向不存在的合约发送消息的成本较高，因此执行时可能会遇到 Out-of-Gas 错误。这个问题的一个变通方法是，在您的实际合约中使用它们之前，先向每个合约发送 Wei（例如1）。这在主网和测试网上都没有问题。</p>
</div>
</section>
<section id="address-related">
<span id="index-8"></span><span id="id11"></span><h4>地址类型的成员<a class="headerlink" href="#address-related" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.balance</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint256</span></code> ）</dt><dd><p>以 Wei 为单位的 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 的余额。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.code</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> ）</dt><dd><p>在 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 的代码（可以是空的）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.codehash</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> ）</dt><dd><p><a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 的代码哈希值</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address</span> <span class="pre">payable&gt;.transfer(uint256</span> <span class="pre">amount)</span></code></dt><dd><p>向 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address</span> <span class="pre">payable&gt;.send(uint256</span> <span class="pre">amount)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code></dt><dd><p>向 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 发送数量为 amount 的 Wei，失败时返回 <code class="docutils literal notranslate"><span class="pre">false</span></code> 2300 gas 的矿工费用，不可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.call(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code></dt><dd><p>用给定的数据发出低级别的 <code class="docutils literal notranslate"><span class="pre">CALL</span></code>，返回是否成功的结果和数据，发送所有可用 gas，可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.delegatecall(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code></dt><dd><p>用给定的数据发出低级别的 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>，返回是否成功的结果和数据，发送所有可用 gas，可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.staticcall(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code></dt><dd><p>用给定的数据发出低级别的 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，返回是否成功的结果和数据，发送所有可用 gas，可调节。</p>
</dd>
</dl>
<p>更多信息，请参见 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 一节。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>您应该尽可能避免在执行另一个合约函数时使用 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>，因为它绕过了类型检查、函数存在性检查和参数打包。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），
转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，
总是检查 <code class="docutils literal notranslate"><span class="pre">send</span></code> 的返回值，使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 或者下面更好的方式： 用接收者提款的模式。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>由于 EVM 认为对一个不存在的合约的调用总是成功的，
Solidity 在执行外部调用时使用 <code class="docutils literal notranslate"><span class="pre">extcodesize</span></code> 操作码进行额外的检查。
这确保了即将被调用的合约要么实际存在（它包含代码），要么就会产生一个异常。</p>
<p>对地址而不是合约实例进行低级调用
（即 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>, <code class="docutils literal notranslate"><span class="pre">.delegatecall()</span></code>, <code class="docutils literal notranslate"><span class="pre">.staticcall()</span></code>, <code class="docutils literal notranslate"><span class="pre">.send()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.transfer()</span></code>）
<strong>不包括</strong> 这种检查，这使得它们在gas方面更便宜，但也更不安全。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.5.0 版本之前，Solidity 允许地址成员被合约实例访问，例如 <code class="docutils literal notranslate"><span class="pre">this.balance</span></code>。
现在这被禁止了，必须做一个明确的地址转换。 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果状态变量是通过低级别的委托调用来访问的，那么两个合约的存储布局必须一致，
以便被调用的合约能够正确地通过名称来访问调用合约的存储变量。
当然，如果存储指针作为函数参数被传递的话，情况就不是这样了，就像高层库的情况一样。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.5.0 版本之前， <code class="docutils literal notranslate"><span class="pre">.call</span></code>, <code class="docutils literal notranslate"><span class="pre">.delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.staticcall</span></code> 只返回成功状况，
不返回数据。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.5.0 版本之前，有一个名为 <code class="docutils literal notranslate"><span class="pre">callcode</span></code> 的成员，其语义与 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 相似但略有不同。</p>
</div>
</section>
<section id="index-9">
<span id="id12"></span><h4>合约相关<a class="headerlink" href="#index-9" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">this</span></code> （当前合约类型）</dt><dd><p>当前合约，可以明确转换为 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">selfdestruct(address</span> <span class="pre">payable</span> <span class="pre">recipient)</span></code></dt><dd><p>销毁当前合约，将其资金发送到给定的 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 并结束执行。
注意， <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 有一些从EVM继承的特殊性：</p>
<ul class="simple">
<li><p>接收合约的接收函数不会被执行。</p></li>
<li><p>合约只有在交易结束时才真正被销毁， 任何一个 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 可能会 &quot;恢复&quot; 销毁。</p></li>
</ul>
</dd>
</dl>
<p>此外，当前合约的所有函数都可以直接调用，包括当前函数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 0.5.0 版本之前，有一个叫做 <code class="docutils literal notranslate"><span class="pre">suicide</span></code> 的函数，其语义与 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 相同。</p>
</div>
</section>
<section id="meta-type">
<span id="index-10"></span><span id="id13"></span><h4>类型信息<a class="headerlink" href="#meta-type" title="此标题的永久链接"></a></h4>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">type(X)</span></code> 可以用来检索关于 <code class="docutils literal notranslate"><span class="pre">X</span></code> 类型的信息。
目前，对这一功能的支持是有限的（ <code class="docutils literal notranslate"><span class="pre">X</span></code> 可以是合约类型或整数型），但在未来可能会扩展。</p>
<p>以下是合约类型 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的可用属性：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type(C).name</span></code></dt><dd><p>合约的名称。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type(C).creationCode</span></code></dt><dd><p>内存字节数组，包含合约的创建字节码。
可以在内联程序中用来建立自定义的创建程序，
特别是通过使用 <code class="docutils literal notranslate"><span class="pre">create2</span></code> 操作码。
这个属性 <strong>不能</strong> 在合约本身或任何派生合约中被访问。
它会导致字节码被包含在调用站点的字节码中，因此像这样的循环引用是不可能的。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type(C).runtimeCode</span></code></dt><dd><p>内存字节数组，包含合约运行时的字节码。
通常是由 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的构造函数部署的代码。
如果 <code class="docutils literal notranslate"><span class="pre">C</span></code> 有一个使用内联汇编的构造函数，这可能与实际部署的字节码不同。
还要注意的是，库合约在部署时修改其运行时字节码，以防止常规调用。
与 <code class="docutils literal notranslate"><span class="pre">.creationCode</span></code> 相同的限制也适用于这个属性。</p>
</dd>
</dl>
<p>除了上述属性外，以下属性对接口类型 <code class="docutils literal notranslate"><span class="pre">I</span></code> 可用：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type(I).interfaceId</span></code>:</dt><dd><p>一个 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 值，是包含给定接口 <code class="docutils literal notranslate"><span class="pre">I</span></code> 的 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-165">EIP-165</a> 接口标识符。
这个标识符被定义为接口本身定义的所有函数选择器的 <code class="docutils literal notranslate"><span class="pre">XOR</span></code>，不包括所有继承的函数。</p>
</dd>
</dl>
<p>以下属性可用于整数类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type(T).min</span></code></dt><dd><p>类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 所能代表的最小值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type(T).max</span></code></dt><dd><p>类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 所能代表的最大值。</p>
</dd>
</dl>
</section>
</section>
<section id="id14">
<h3>保留关键词<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h3>
<p>这些关键字在 Solidity 中是保留的。它们在将来可能成为语法的一部分：</p>
<p><code class="docutils literal notranslate"><span class="pre">after</span></code>， <code class="docutils literal notranslate"><span class="pre">alias</span></code>， <code class="docutils literal notranslate"><span class="pre">apply</span></code>， <code class="docutils literal notranslate"><span class="pre">auto</span></code>， <code class="docutils literal notranslate"><span class="pre">byte</span></code>， <code class="docutils literal notranslate"><span class="pre">case</span></code>， <code class="docutils literal notranslate"><span class="pre">copyof</span></code>， <code class="docutils literal notranslate"><span class="pre">default</span></code>，
<code class="docutils literal notranslate"><span class="pre">define</span></code>， <code class="docutils literal notranslate"><span class="pre">final</span></code>， <code class="docutils literal notranslate"><span class="pre">implements</span></code>， <code class="docutils literal notranslate"><span class="pre">in</span></code>， <code class="docutils literal notranslate"><span class="pre">inline</span></code>， <code class="docutils literal notranslate"><span class="pre">let</span></code>， <code class="docutils literal notranslate"><span class="pre">macro</span></code>， <code class="docutils literal notranslate"><span class="pre">match</span></code>，
<code class="docutils literal notranslate"><span class="pre">mutable</span></code>， <code class="docutils literal notranslate"><span class="pre">null</span></code>， <code class="docutils literal notranslate"><span class="pre">of</span></code>， <code class="docutils literal notranslate"><span class="pre">partial</span></code>， <code class="docutils literal notranslate"><span class="pre">promise</span></code>， <code class="docutils literal notranslate"><span class="pre">reference</span></code>， <code class="docutils literal notranslate"><span class="pre">relocatable</span></code>，
<code class="docutils literal notranslate"><span class="pre">sealed</span></code>， <code class="docutils literal notranslate"><span class="pre">sizeof</span></code>， <code class="docutils literal notranslate"><span class="pre">static</span></code>， <code class="docutils literal notranslate"><span class="pre">supports</span></code>， <code class="docutils literal notranslate"><span class="pre">switch</span></code>， <code class="docutils literal notranslate"><span class="pre">typedef</span></code>， <code class="docutils literal notranslate"><span class="pre">typeof</span></code>，
<code class="docutils literal notranslate"><span class="pre">var</span></code>。</p>
</section>
</section>
<span id="document-control-structures"></span><section id="id1">
<h2>表达式和控制结构<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<span class="target" id="index-0"></span><section id="index-1">
<span id="id2"></span><h3>控制结构<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>大多数从大括号语言中知道的控制结构都可以在Solidity中使用：</p>
<p>有： <code class="docutils literal notranslate"><span class="pre">if</span></code>， <code class="docutils literal notranslate"><span class="pre">else</span></code>，  <code class="docutils literal notranslate"><span class="pre">while</span></code>， <code class="docutils literal notranslate"><span class="pre">do</span></code>， <code class="docutils literal notranslate"><span class="pre">for</span></code>， <code class="docutils literal notranslate"><span class="pre">break</span></code>， <code class="docutils literal notranslate"><span class="pre">continue</span></code>， <code class="docutils literal notranslate"><span class="pre">return</span></code>，
这些在 C 或者 JavaScript 中表达相同语义的关键词。</p>
<p>Solidity也支持 <code class="docutils literal notranslate"><span class="pre">try</span></code> / <code class="docutils literal notranslate"><span class="pre">catch</span></code> 形式的语句的异常处理，
但只适用于 <a class="reference internal" href="#external-function-calls"><span class="std std-ref">外部函数调用</span></a> 和合约创建调用。
可以使用 <a class="reference internal" href="#revert-statement"><span class="std std-ref">恢复状态</span></a> 来创建错误。</p>
<p>条件句 <em>不能</em> 省略括号，但单句体周围可以省略大括号。</p>
<p>请注意，没有像C和JavaScript那样从非布尔类型到布尔类型的类型转换，
所以 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(1)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 在Solidity <em>不是</em> 有效的。</p>
</section>
<section id="function-calls">
<span id="index-2"></span><span id="id3"></span><h3>函数调用<a class="headerlink" href="#function-calls" title="此标题的永久链接"></a></h3>
<section id="internal-function-calls">
<span id="id4"></span><h4>内部函数调用<a class="headerlink" href="#internal-function-calls" title="此标题的永久链接"></a></h4>
<p>当前合约中的函数可以直接（“从内部”）调用，也可以递归调用，就像下边这个荒谬的例子一样：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCi8vIOi/meS8muacieS4gOS4quitpuWRigpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGcodWludCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHJldCkgeyByZXR1cm4gYSArIGYoKTsgfQogICAgZnVuY3Rpb24gZigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCByZXQpIHsgcmV0dXJuIGcoNykgKyBmKCk7IH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 这会有一个警告</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>f<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>g<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>f<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这些函数调用在EVM内部被转化为简单的跳转。
这样做的效果是，当前的内存不会被清空，也就是说，
将内存引用传递给内部调用的函数是非常有效的。
但只有同一合约实例的函数可以被内部调用。</p>
<p>您还是应该避免过度的递归调用，因为每个内部函数的调用都会占用至少一个堆栈槽，而可用的堆栈槽只有1024个。</p>
</section>
<section id="external-function-calls">
<span id="id5"></span><h4>外部函数调用<a class="headerlink" href="#external-function-calls" title="此标题的永久链接"></a></h4>
<p>函数也可以使用 <code class="docutils literal notranslate"><span class="pre">this.g(8);</span></code> 和 <code class="docutils literal notranslate"><span class="pre">c.g(2);</span></code> 符号来调用，
其中 <code class="docutils literal notranslate"><span class="pre">c</span></code> 是一个合约实例， <code class="docutils literal notranslate"><span class="pre">g</span></code> 是属于 <code class="docutils literal notranslate"><span class="pre">c</span></code> 的函数。
通过这两种方式调用函数 <code class="docutils literal notranslate"><span class="pre">g</span></code> 会导致它被 “外部” 调用，
使用消息调用而不是直接通过跳转。
请注意，对 <code class="docutils literal notranslate"><span class="pre">this</span></code> 的函数调用不能在构造函数中使用，因为实际的合约还没有被创建。</p>
<p>其他合约的函数必须被外部调用。对于一个外部调用，
所有的函数参数都必须被拷贝到内存中。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>从一个合约到另一个合约的函数调用并不创建自己的交易，它是作为整个交易的一部分的消息调用。</p>
</div>
<p>当调用其他合约的函数时，您可以用特殊的选项 <code class="docutils literal notranslate"><span class="pre">{value:</span> <span class="pre">10,</span> <span class="pre">gas:</span> <span class="pre">10000}</span></code> 指定随调用发送的Wei或气体（gas）数量。
请注意，不鼓励明确指定气体值，因为操作码的气体成本可能在未来发生变化。
您发送给合约的任何Wei都会被添加到该合约的总余额中：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgSW5mb0ZlZWQgewogICAgZnVuY3Rpb24gaW5mbygpIHB1YmxpYyBwYXlhYmxlIHJldHVybnMgKHVpbnQgcmV0KSB7IHJldHVybiA0MjsgfQp9Cgpjb250cmFjdCBDb25zdW1lciB7CiAgICBJbmZvRmVlZCBmZWVkOwogICAgZnVuY3Rpb24gc2V0RmVlZChJbmZvRmVlZCBhZGRyKSBwdWJsaWMgeyBmZWVkID0gYWRkcjsgfQogICAgZnVuY3Rpb24gY2FsbEZlZWQoKSBwdWJsaWMgeyBmZWVkLmluZm97dmFsdWU6IDEwLCBnYXM6IDgwMH0oKTsgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">InfoFeed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">info</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Consumer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>InfoFeed<span class="w"> </span>feed<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setFeed</span><span class="p">(</span>InfoFeed<span class="w"> </span>addr<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>feed<span class="w"> </span><span class="o">=</span><span class="w"> </span>addr<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callFeed</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>feed<span class="p">.</span>info<span class="p">{</span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">,</span><span class="w"> </span>gas<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">800</span><span class="p">}();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您需要对 <code class="docutils literal notranslate"><span class="pre">info</span></code> 函数使用修饰符 <code class="docutils literal notranslate"><span class="pre">payable</span></code>，
因为不这样的话， <code class="docutils literal notranslate"><span class="pre">value</span></code> 选项则不可用。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>注意 <code class="docutils literal notranslate"><span class="pre">feed.info{value:</span> <span class="pre">10,</span> <span class="pre">gas:</span> <span class="pre">800}</span></code> 只在本地设置 <code class="docutils literal notranslate"><span class="pre">value</span></code> 和随函数调用发送的 <code class="docutils literal notranslate"><span class="pre">gas</span></code> 数量，
最后的括号执行实际调用。所以 <code class="docutils literal notranslate"><span class="pre">feed.info{value:</span> <span class="pre">10,</span> <span class="pre">gas:</span> <span class="pre">800}</span></code> 不会调用函数，
<code class="docutils literal notranslate"><span class="pre">value</span></code> 和 <code class="docutils literal notranslate"><span class="pre">gas</span></code> 的设置也会丢失，
只有 <code class="docutils literal notranslate"><span class="pre">feed.info{value:</span> <span class="pre">10,</span> <span class="pre">gas:</span> <span class="pre">800}()</span></code> 执行了函数调用。</p>
</div>
<p>由于EVM认为对一个不存在的合约的调用总是成功的，
Solidity使用 <code class="docutils literal notranslate"><span class="pre">extcodesize</span></code> 操作码来检查即将被调用的合约是否真的存在（它包含代码），
如果不存在就会引起异常。如果返回数据将在调用后被解码，
则跳过该检查，因此ABI解码器将捕获不存在的合约的情况。</p>
<p>请注意，这个检查在 <a class="reference internal" href="index.html#address-related"><span class="std std-ref">低级调用</span></a> 的情况下不执行，
这些调用是对地址而不是合约实例进行操作。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在对 <a class="reference internal" href="index.html#precompiledcontracts"><span class="std std-ref">预编译合约</span></a> 使用高级调用时要小心，
因为根据上述逻辑，编译器认为它们不存在，即使它们执行代码并可以返回数据。</p>
</div>
<p>如果被调用的合约本身抛出异常或超出了gas值，函数调用也会引起异常。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>与另一个合约的任何互动都会带来潜在的危险，
特别是当合约的源代码事先不知道的时候。
当前的合约将控制权交给了被调用的合约，而这有可能做任何事情。
即使被调用的合约继承自一个已知的父合约，
继承的合约也只需要有一个正确的接口。
然而，合约的实现完全可以是任意的，因此这会带来危险。
此外，要做好准备，以防它调用到您系统中的其他合约，
甚至在第一次调用返回之前就回到调用合约中。
这意味着被调用的合约可以通过这个函数改变调用合约的状态变量。
编写您的函数时，例如，对外部函数的调用发生在对您的合约中的状态变量的任何改变之后，
这样您的合约就不会受到重入性漏洞的攻击。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Solidity 0.6.2 之前，指定以太值和气体值的推荐方法是
使用 <code class="docutils literal notranslate"><span class="pre">f.value(x).gas(g)()</span></code>。这在Solidity 0.6.2中被废弃，
并且从Solidity 0.7.0开始不再支持。</p>
</div>
</section>
<section id="id6">
<h4>带命名参数的函数调用<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<p>函数调用参数可以用名字来表示，如果用 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code> 括起来的话，
可以用任何顺序，如下面的例子所示。
参数列表在名称上必须与函数声明中的参数列表相一致，但可以有任意的顺序。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBtYXBwaW5nKHVpbnQgPT4gdWludCkgZGF0YTsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICBzZXQoe3ZhbHVlOiAyLCBrZXk6IDN9KTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCBrZXksIHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7CiAgICB9Cgp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>data<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>set<span class="p">({</span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">,</span><span class="w"> </span>key<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">set</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>data<span class="p">[</span>key<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id7">
<h4>函数定义中省略的名称<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>函数声明中的参数和返回值的名称可以省略。
那些名字被省略的参数仍然会出现在堆栈中，但是无法通过名字访问。
省略的返回值名称仍然可以通过使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句向调用者返回一个值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8g55yB55Wl5Y+C5pWw5ZCN56ewCiAgICBmdW5jdGlvbiBmdW5jKHVpbnQgaywgdWludCkgcHVibGljIHB1cmUgcmV0dXJucyh1aW50KSB7CiAgICAgICAgcmV0dXJuIGs7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 省略参数名称</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">func</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">k</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>k<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="new">
<span id="creating-contracts"></span><span id="index-3"></span><h3>通过 <code class="docutils literal notranslate"><span class="pre">new</span></code> 创建合约<a class="headerlink" href="#new" title="此标题的永久链接"></a></h3>
<p>一个合约可以使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 关键字创建其他合约。
待创建合约的完整代码必须在创建的合约被编译时知道，
所以递归的创建依赖是不可能的。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBEIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IGEpIHBheWFibGUgewogICAgICAgIHggPSBhOwogICAgfQp9Cgpjb250cmFjdCBDIHsKICAgIEQgZCA9IG5ldyBEKDQpOyAvLyDlsIbkvZzkuLrlkIjnuqYgQyDmnoTpgKDlh73mlbDnmoTkuIDpg6jliIbmiafooYwKCiAgICBmdW5jdGlvbiBjcmVhdGVEKHVpbnQgYXJnKSBwdWJsaWMgewogICAgICAgIEQgbmV3RCA9IG5ldyBEKGFyZyk7CiAgICAgICAgbmV3RC54KCk7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlQW5kRW5kb3dEKHVpbnQgYXJnLCB1aW50IGFtb3VudCkgcHVibGljIHBheWFibGUgewogICAgICAgIC8vIOmaj+WQiOe6pueahOWIm+W7uuWPkemAgSBldGhlcgogICAgICAgIEQgbmV3RCA9IG5ldyBEe3ZhbHVlOiBhbW91bnR9KGFyZyk7CiAgICAgICAgbmV3RC54KCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>D<span class="w"> </span>d<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>D<span class="p">(</span><span class="m m-Decimal">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将作为合约 C 构造函数的一部分执行</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createD</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>D<span class="w"> </span>newD<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>D<span class="p">(</span>arg<span class="p">);</span>
<span class="w">        </span>newD<span class="p">.</span>x<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createAndEndowD</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 随合约的创建发送 ether</span>
<span class="w">        </span>D<span class="w"> </span>newD<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>D<span class="p">{</span>value<span class="o">:</span><span class="w"> </span>amount<span class="p">}(</span>arg<span class="p">);</span>
<span class="w">        </span>newD<span class="p">.</span>x<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>正如在例子中所看到的，在使用 <code class="docutils literal notranslate"><span class="pre">value</span></code> 选项创建 <code class="docutils literal notranslate"><span class="pre">D</span></code> 的实例时，
可以发送以太，但不可能限制气体的数量。
如果创建失败（由于堆栈耗尽，没有足够的余额或其他问题），会抛出一个异常。</p>
<section id="create2">
<h4>加盐合约创建 / create2<a class="headerlink" href="#create2" title="此标题的永久链接"></a></h4>
<p>当创建一个合约时，合约的地址是由创建合约的地址和一个计数器计算出来的，
这个计数器在每次创建合约时都会增加。</p>
<p>如果您指定了选项 <code class="docutils literal notranslate"><span class="pre">salt</span></code> （一个32字节的值），
那么合约的创建将使用一种不同的机制来得出新合约的地址。</p>
<p>它将从创建合约的地址、给定的盐值、创建合约的（创建）字节码和构造函数参数中计算出地址。</p>
<p>特别的是，计数器（“nonce”）没有被使用。这使得创建合约时有更多的灵活性。
您能够在新合约创建之前得出它的地址。此外，在创建合约的同时创建其他合约的情况下，
您也可以依赖这个地址。</p>
<p>这里的主要用例是做为链外互动的评判的合约，
只有在有争议的时候才需要创建。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBEIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IGEpIHsKICAgICAgICB4ID0gYTsKICAgIH0KfQoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBjcmVhdGVEU2FsdGVkKGJ5dGVzMzIgc2FsdCwgdWludCBhcmcpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z5Liq5aSN5p2C55qE6KGo6L6+5byP5Y+q5piv5ZGK6K+J5oKo5aaC5L2V6aKE5YWI6K6h566X5Ye65Zyw5Z2A44CCCiAgICAgICAgLy8g5a6D5Y+q5piv55So5LqO6K+05piO6Zeu6aKY44CCCiAgICAgICAgLy8g5a6e6ZmF5LiK5oKo5Y+q6ZyA6KaBIGBgbmV3IER7c2FsdDogc2FsdH0oYXJnKWBg44CCCiAgICAgICAgYWRkcmVzcyBwcmVkaWN0ZWRBZGRyZXNzID0gYWRkcmVzcyh1aW50MTYwKHVpbnQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoCiAgICAgICAgICAgIGJ5dGVzMSgweGZmKSwKICAgICAgICAgICAgYWRkcmVzcyh0aGlzKSwKICAgICAgICAgICAgc2FsdCwKICAgICAgICAgICAga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoCiAgICAgICAgICAgICAgICB0eXBlKEQpLmNyZWF0aW9uQ29kZSwKICAgICAgICAgICAgICAgIGFiaS5lbmNvZGUoYXJnKQogICAgICAgICAgICApKQogICAgICAgICkpKSkpOwoKICAgICAgICBEIGQgPSBuZXcgRHtzYWx0OiBzYWx0fShhcmcpOwogICAgICAgIHJlcXVpcmUoYWRkcmVzcyhkKSA9PSBwcmVkaWN0ZWRBZGRyZXNzKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createDSalted</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">salt</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这个复杂的表达式只是告诉您如何预先计算出地址。</span>
<span class="w">        </span><span class="c1">// 它只是用于说明问题。</span>
<span class="w">        </span><span class="c1">// 实际上您只需要 ``new D{salt: salt}(arg)``。</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">predictedAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">uint160</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span>
<span class="w">            </span>bytes1<span class="p">(</span><span class="mh">0xff</span><span class="p">),</span>
<span class="w">            </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">),</span>
<span class="w">            </span>salt<span class="p">,</span>
<span class="w">            </span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span>
<span class="w">                </span>type<span class="p">(</span>D<span class="p">).</span>creationCode<span class="p">,</span>
<span class="w">                </span>abi<span class="p">.</span>encode<span class="p">(</span>arg<span class="p">)</span>
<span class="w">            </span><span class="p">))</span>
<span class="w">        </span><span class="p">)))));</span>

<span class="w">        </span>D<span class="w"> </span>d<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>D<span class="p">{</span>salt<span class="o">:</span><span class="w"> </span>salt<span class="p">}(</span>arg<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span>d<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>predictedAddress<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在用加盐方式创建合约时，有一些特殊性。一个合约可以在被销毁后在同一地址重新创建。
然而，新创建的合约有可能具有不同的部署字节码，
即使创建字节码是相同的（这是一个要求，否则地址会改变）。
这是由于构造函数可以查询在两次创建之间可能发生变化的外部状态，
并在存储之前将其纳入部署字节码。</p>
</div>
</section>
</section>
<section id="id8">
<h3>表达式计算顺序<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h3>
<p>表达式的计算顺序不是特定的（更准确地说，
表达式树中某节点的字节点间的计算顺序不是特定的，但它们的结算肯定会在节点自己的结算之前）。
该规则只能保证语句按顺序执行，并对布尔表达式进行短路处理。</p>
</section>
<section id="index-4">
<span id="id9"></span><h3>赋值<a class="headerlink" href="#index-4" title="此标题的永久链接"></a></h3>
<section id="index-5">
<span id="id10"></span><h4>解构赋值和返回多个值<a class="headerlink" href="#index-5" title="此标题的永久链接"></a></h4>
<p>Solidity 内部允许元组 (tuple) 类型，也就是一个在编译时元素数量固定的对象列表，
列表中的元素可以是不同类型的对象。这些元组可以用来同时返回多个数值，
也可以用它们来同时赋值给多个新声明的变量或者既存的变量（或通常的 LValues）：</p>
<p>在Solidity中，元组不是适当的类型，它们只能被用来构建表达式的语法分组。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IGluZGV4OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50LCBib29sLCB1aW50KSB7CiAgICAgICAgcmV0dXJuICg3LCB0cnVlLCAyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICAvLyDnlKjnsbvlnovlo7DmmI7nmoTlj5jph4/vvIzlubbku47ov5Tlm57nmoTlhYPnu4TkuK3liIbphY3vvIwKICAgICAgICAvLyDkuI3mmK/miYDmnInnmoTlhYPntKDpg73lv4XpobvooqvmjIflrprvvIjkvYbmlbDph4/lv4XpobvljLnphY3vvInjgIIKICAgICAgICAodWludCB4LCAsIHVpbnQgeSkgPSBmKCk7CiAgICAgICAgLy8g5Lqk5o2i5pWw5YC855qE5bi46KeB5oqA5benIC0tIOWvuemdnuaVsOWAvOWtmOWCqOexu+Wei+S4jei1t+S9nOeUqOOAggogICAgICAgICh4LCB5KSA9ICh5LCB4KTsKICAgICAgICAvLyDlhYPntKDlj6/ku6XkuI3kvb/nlKjvvIjkuZ/pgILnlKjkuo7lj5jph4/lo7DmmI7vvInjgIIKICAgICAgICAoaW5kZXgsICwgKSA9IGYoKTsgLy8g5bCGaW5kZXjorr7nva7kuLogNwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">index</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span><span class="m m-Decimal">7</span><span class="p">,</span><span class="w"> </span><span class="kt">true</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 用类型声明的变量，并从返回的元组中分配，</span>
<span class="w">        </span><span class="c1">// 不是所有的元素都必须被指定（但数量必须匹配）。</span>
<span class="w">        </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">();</span>
<span class="w">        </span><span class="c1">// 交换数值的常见技巧 -- 对非数值存储类型不起作用。</span>
<span class="w">        </span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>y<span class="p">,</span><span class="w"> </span>x<span class="p">);</span>
<span class="w">        </span><span class="c1">// 元素可以不使用（也适用于变量声明）。</span>
<span class="w">        </span><span class="p">(</span>index<span class="p">,</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">();</span><span class="w"> </span><span class="c1">// 将index设置为 7</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>不可能混合使用声明和非声明变量赋值。
例如，下面的方法是无效的。 <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">uint</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">2);</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.5.0版本之前，给具有更少元素数的元组赋值都是可能的，
要么在左边填充，要么在右边填充（无论哪个是空的）。
现在这是不允许的，所以两边必须有相同数量的元素。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>当涉及到引用类型时，在同时向多个变量赋值时要小心，因为这可能导致意外的复制行为。</p>
</div>
</section>
<section id="id11">
<h4>数组和结构体的复杂情况<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>对于像数组和结构体这样的非值类型，包括 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code>，赋值的语义更为复杂，
详见 <a class="reference internal" href="index.html#data-location-assignment"><span class="std std-ref">数据位置和赋值行为</span></a>。</p>
<p>在下面的例子中，调用 <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> 对 <code class="docutils literal notranslate"><span class="pre">x</span></code> 没有影响，
因为它在内存中创建了一个独立的存储值的副本。然而， <code class="docutils literal notranslate"><span class="pre">h(x)</span></code> 成功地修改了 <code class="docutils literal notranslate"><span class="pre">x</span></code>，
因为传递了一个引用而不是一个拷贝。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludFsyMF0geDsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICBnKHgpOwogICAgICAgIGgoeCk7CiAgICB9CgogICAgZnVuY3Rpb24gZyh1aW50WzIwXSBtZW1vcnkgeSkgaW50ZXJuYWwgcHVyZSB7CiAgICAgICAgeVsyXSA9IDM7CiAgICB9CgogICAgZnVuY3Rpb24gaCh1aW50WzIwXSBzdG9yYWdlIHkpIGludGVybmFsIHsKICAgICAgICB5WzNdID0gNDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">20</span><span class="p">]</span><span class="w"> </span>x<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>g<span class="p">(</span>x<span class="p">);</span>
<span class="w">        </span>h<span class="p">(</span>x<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">20</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>y<span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">20</span><span class="p">]</span><span class="w"> </span>storage<span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>y<span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="default-value">
<span id="index-6"></span><span id="id12"></span><h3>作用域和声明<a class="headerlink" href="#default-value" title="此标题的永久链接"></a></h3>
<p>一个被声明的变量将有一个初始默认值，其字节表示为所有的零。
变量的 &quot;默认值&quot; 是任何类型的典型 &quot;零状态&quot;。
例如， <code class="docutils literal notranslate"><span class="pre">bool</span></code> 的默认值是 <code class="docutils literal notranslate"><span class="pre">false</span></code>。
<code class="docutils literal notranslate"><span class="pre">uint</span></code> 或 <code class="docutils literal notranslate"><span class="pre">int</span></code> 类型的默认值是 <code class="docutils literal notranslate"><span class="pre">0</span></code>。
对于静态大小的数组和 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> 到 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>，
每个单独的元素将被初始化为与其类型相应的默认值。
对于动态大小的数组， <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code>，默认值是一个空数组或字符串。
对于 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 类型，默认值是其第一个成员。</p>
<p>Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）：
变量将会从它们被声明之后可见，直到一对 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code> 块的结束。
这一规则有个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。</p>
<p>类似于参数的变量（函数参数、修改器参数、捕获（catch）参数......）
在后面的代码块中是可见的--对于函数和修改器参数，在函数/修改器的主体中，
对于捕获参数，在捕获块中。</p>
<p>在代码块之外声明的变量，例如函数、合约、用户定义的类型等，
甚至在声明之前就已经可见。
这意味着您可以在声明之前使用状态变量，并递归地调用函数。</p>
<p>因此，下面的例子在编译时不会出现警告，因为这两个变量的名字虽然相同，但作用域不同。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG1pbmltYWxTY29waW5nKCkgcHVyZSBwdWJsaWMgewogICAgICAgIHsKICAgICAgICAgICAgdWludCBzYW1lOwogICAgICAgICAgICBzYW1lID0gMTsKICAgICAgICB9CgogICAgICAgIHsKICAgICAgICAgICAgdWludCBzYW1lOwogICAgICAgICAgICBzYW1lID0gMzsKICAgICAgICB9CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">minimalScoping</span><span class="p">()</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">same</span><span class="p">;</span>
<span class="w">            </span>same<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">same</span><span class="p">;</span>
<span class="w">            </span>same<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>作为 C99 作用域规则的特例，请注意在下边的例子里，
第一次对 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的赋值实际上将赋给外层变量而不是内层变量。
在任何情况下，您都会得到一个关于外部变量被影射（译者注：就是说被在内部作用域中由一个同名变量所替代）的警告。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrorablkYrkv6Hmga8KY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVyZSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIHVpbnQgeCA9IDE7CiAgICAgICAgewogICAgICAgICAgICB4ID0gMjsgLy8gdGhpcyB3aWxsIGFzc2lnbiB0byB0aGUgb3V0ZXIgdmFyaWFibGUKICAgICAgICAgICAgdWludCB4OwogICAgICAgIH0KICAgICAgICByZXR1cm4geDsgLy8geCBoYXMgdmFsdWUgMgogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="c1">// 这将报告一个警告信息</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will assign to the outer variable</span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// x has value 2</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在0.5.0版本之前，Solidity遵循与JavaScript相同的作用域规则，
也就是说，在一个函数中的任何地方声明的变量都会在整个函数的作用域中，不管它是在哪里声明。
下面的例子显示了一个曾经可以编译的代码片段，但从0.5.0版本开始导致了一个错误。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwovLyDov5nlsIbml6Dms5XnvJbor5EKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVyZSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIHggPSAyOwogICAgICAgIHVpbnQgeDsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="c1">// 这将无法编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="unchecked">
<span id="index-7"></span><span id="id13"></span><h3>检查或不检查的算术<a class="headerlink" href="#unchecked" title="此标题的永久链接"></a></h3>
<p>上溢或下溢是指算术运算的结果值，当对一个不受限制的整数执行时，超出了结果类型的范围。</p>
<p>在Solidity 0.8.0之前，算术运算总是在下溢或上溢的情况下被包起来，
这导致广泛使用引入额外检查的库。</p>
<p>从Solidity 0.8.0开始，在默认情况下所有的算术运算都会在上溢和下溢时还原，
从而使这些库的使用变得没有必要。</p>
<p>为了获得以前的行为，可以使用一个 <code class="docutils literal notranslate"><span class="pre">未检查（unchecked）</span></code> 区块。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdXJlIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgLy8g6L+Z5Liq5YeP5rOV5bCG5Zyo5LiL5rqi5pe26KKr5YyF6LW35p2l44CCCiAgICAgICAgdW5jaGVja2VkIHsgcmV0dXJuIGEgLSBiOyB9CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnQgYSwgdWludCBiKSBwdXJlIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgLy8g6L+Z5Liq5YeP5rOV5Zyo5LiL5rqi5pe25bCG6KKr6L+Y5Y6f44CCCiAgICAgICAgcmV0dXJuIGEgLSBiOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这个减法将在下溢时被包起来。</span>
<span class="w">        </span>unchecked<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">-</span><span class="w"> </span>b<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这个减法在下溢时将被还原。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">-</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>调用 <code class="docutils literal notranslate"><span class="pre">f(2,</span> <span class="pre">3)</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">2**256-1</span></code>，而 <code class="docutils literal notranslate"><span class="pre">g(2,</span> <span class="pre">3)</span></code> 将导致一个失败的断言。</p>
<p><code class="docutils literal notranslate"><span class="pre">unchecked</span></code> 代码块可以在代码块内的任何地方使用，但不能替代代码块。
它也不能被嵌套。</p>
<p>该设置只影响到在语法上位于代码块内的语句。
从 <code class="docutils literal notranslate"><span class="pre">unchecked</span></code> 代码块内调用的函数不继承该属性。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为了避免歧义，您不能在一个 <code class="docutils literal notranslate"><span class="pre">unchecked</span></code> 代码块内使用 <code class="docutils literal notranslate"><span class="pre">_;</span></code>。</p>
</div>
<p>以下运算符在上溢或下溢时将导致一个失败的断言，
如果在一个未检查的代码块内使用，将被包裹而不会出现错误。</p>
<p><code class="docutils literal notranslate"><span class="pre">++</span></code>， <code class="docutils literal notranslate"><span class="pre">--</span></code>， <code class="docutils literal notranslate"><span class="pre">+</span></code>， 二进制 <code class="docutils literal notranslate"><span class="pre">-</span></code>， 单进制 <code class="docutils literal notranslate"><span class="pre">-</span></code>， <code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code>， <code class="docutils literal notranslate"><span class="pre">**</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">+=</span></code>， <code class="docutils literal notranslate"><span class="pre">-=</span></code>， <code class="docutils literal notranslate"><span class="pre">*=</span></code>， <code class="docutils literal notranslate"><span class="pre">/=</span></code>， <code class="docutils literal notranslate"><span class="pre">%=</span></code></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>不能使用 <code class="docutils literal notranslate"><span class="pre">unchecked</span></code> 代码块来禁止检查除以0或对0取余数。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>位操作符不执行上溢或下溢检查。
这在使用位操作符移位（ <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>）来代替整数除法和2的幂次方时尤其明显。
例如 <code class="docutils literal notranslate"><span class="pre">type(uint256).max</span> <span class="pre">&lt;&lt;</span> <span class="pre">3</span></code> 不会恢复操作，尽管 <code class="docutils literal notranslate"><span class="pre">type(uint256).max</span> <span class="pre">*</span> <span class="pre">8</span></code> 会恢复操作。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">type(int).min;</span> <span class="pre">-x;</span></code> 中的第二条语句将导致溢出，
因为负数范围可以比正数范围多容纳一个值。</p>
</div>
<p>明确的类型转换将总是截断，并且永远不会导致失败的断言，但从整数到枚举类型的转换除外。</p>
</section>
<section id="assert-require-revert-and-exceptions">
<span id="assert-and-require"></span><span id="index-8"></span><h3>错误处理：Assert, Require, Revert and Exceptions<a class="headerlink" href="#assert-require-revert-and-exceptions" title="此标题的永久链接"></a></h3>
<p>Solidity 使用状态恢复异常来处理错误。
这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，
并且还向调用者标记错误。</p>
<p>当异常发生在子调用中时，它们会自动 &quot;冒泡&quot;（也就是说，异常被重新抛出），
除非它们被 <code class="docutils literal notranslate"><span class="pre">try/catch</span></code> 语句捕获。这个规则的例外是 <code class="docutils literal notranslate"><span class="pre">send</span></code>
和低级函数 <code class="docutils literal notranslate"><span class="pre">call</span></code>， <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code>：
它们在发生异常时返回 <code class="docutils literal notranslate"><span class="pre">false</span></code> 作为第一个返回值而不是 &quot;冒泡&quot;。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果被调用的账户不存在，低级函数 <code class="docutils literal notranslate"><span class="pre">call</span></code>， <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code>
的第一个返回值为 <code class="docutils literal notranslate"><span class="pre">true</span></code>，这是EVM设计的一部分。
如果需要的话，必须在调用之前检查账户是否存在。</p>
</div>
<p>异常可以包含错误数据，以 <a class="reference internal" href="index.html#errors"><span class="std std-ref">错误实例</span></a> 的形式传回给调用者。
内置的错误 <code class="docutils literal notranslate"><span class="pre">Error(string)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Panic(uint256)</span></code> 被特殊函数使用，
解释如下。 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 用于 &quot;常规&quot; 错误条件，而 <code class="docutils literal notranslate"><span class="pre">Panic</span></code> 用于在无错误代码中不应该出现的错误。</p>
<section id="assert-panic-require-error">
<h4>通过 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 引起Panic异常和通过 <code class="docutils literal notranslate"><span class="pre">require</span></code> 引起Error异常<a class="headerlink" href="#assert-panic-require-error" title="此标题的永久链接"></a></h4>
<p>快捷函数 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 和 <code class="docutils literal notranslate"><span class="pre">require</span></code> 可以用来检查条件，如果不符合条件就抛出一个异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">assert</span></code> 函数创建了一个 <code class="docutils literal notranslate"><span class="pre">Panic(uint256)</span></code> 类型的错误。
在某些情况下，编译器也会产生同样的错误，如下所述。</p>
<p>Assert应该只用于测试内部错误，以及检查不变量。
正确运行的代码不应该创建一个Panic异常，甚至在无效的外部输入时也不应该。
如果发生这种情况，那么您的合约中就有一个错误，您应该修复它。
语言分析工具可以评估您的合约，以确定会导致Panic异常的条件和函数调用。</p>
<p>在下列情况下会产生一个Panic异常。
与错误数据一起提供的错误代码表明Panic异常的种类。</p>
<ol class="arabic simple">
<li><p>0x00： 用于一般的编译器插入Panic异常的情况。</p></li>
<li><p>0x01： 如果您带参数调用 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 时结果是false。</p></li>
<li><p>0x11： 如果一个算术运算在一个 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 代码块之外导致下溢或上溢。</p></li>
<li><p>0x12： 如果您对0做除法或者取余（例如 <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">0</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">23</span> <span class="pre">%</span> <span class="pre">0</span></code> ）。</p></li>
<li><p>0x21： 如果您把一个太大的或负数的值转换成一个枚举类型。</p></li>
<li><p>0x22： 如果您访问一个编码不正确的存储字节数组。</p></li>
<li><p>0x31： 如果您在一个空数组上调用 <code class="docutils literal notranslate"><span class="pre">.pop()</span></code>。</p></li>
<li><p>0x32： 如果您访问一个数组， <code class="docutils literal notranslate"><span class="pre">bytesN</span></code> 或一个数组切片索引超出数组长度或负索引（即 <code class="docutils literal notranslate"><span class="pre">x[i]</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">x.length</span></code> 或 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> ）。</p></li>
<li><p>0x41： 如果您分配了太多的内存空间或创建了一个太大的数组。</p></li>
<li><p>0x51： 如果您调用一个零初始化的内部函数类型的变量。</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">require</span></code> 函数要么创造一个没有任何数据的错误，
要么创造一个 <code class="docutils literal notranslate"><span class="pre">Error(string)</span></code> 类型的错误。
它应该被用来确保在执行之前无法检测到的有效条件。
这包括对输入的条件或调用外部合约的返回值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>目前不能将自定义错误与 <code class="docutils literal notranslate"><span class="pre">require</span></code> 结合使用。
请使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(!condition)</span> <span class="pre">revert</span> <span class="pre">CustomError();</span></code> 代替。</p>
</div>
<p>在下列情况下，编译器会产生一个 <code class="docutils literal notranslate"><span class="pre">Error(string)</span></code> 异常（或者没有数据的异常）。</p>
<ol class="arabic simple">
<li><p>调用 <code class="docutils literal notranslate"><span class="pre">require(x)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p></li>
<li><p>如果您使用 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">revert(&quot;错误描述&quot;)</span></code>。</p></li>
<li><p>如果您执行一个外部函数调用，目标是一个不包含代码的合约。</p></li>
<li><p>如果您的合约通过一个没有 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 修饰符的公开函数（包括构造函数和备用函数）接收以太。</p></li>
<li><p>如果您的合约通过一个公共的getter函数接收以太。</p></li>
</ol>
<p>对于以下情况，来自外部调用的错误数据（如果提供的话）会被转发。
这意味着它既可以引起 <cite>Error</cite> 异常，也可以引起 <cite>Panic</cite> 异常（或提供的其他什么错误）。</p>
<ol class="arabic simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">.transfer()</span></code> 失败。</p></li>
<li><p>如果您通过消息调用一个函数，但它不能正常完成
（即，耗尽了气体，没有匹配的函数，或自己抛出一个异常），
除非使用低级操作 <code class="docutils literal notranslate"><span class="pre">call</span></code>， <code class="docutils literal notranslate"><span class="pre">send</span></code>， <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>， <code class="docutils literal notranslate"><span class="pre">callcode</span></code>
或 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code>。低级操作从不抛出异常，但通过返回 <code class="docutils literal notranslate"><span class="pre">false</span></code> 表示失败。</p></li>
<li><p>如果您使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 关键字创建一个合约，
但合约创建 <a class="reference internal" href="#creating-contracts"><span class="std std-ref">没有正常完成</span></a>。</p></li>
</ol>
<p>您可以选择为 <code class="docutils literal notranslate"><span class="pre">require</span></code> 提供一个信息字符串，但不能为 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 提供。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您没有给 <code class="docutils literal notranslate"><span class="pre">require</span></code> 提供一个字符串参数，它将以空的错误数据进行还原，
甚至不包括错误选择器。</p>
</div>
<p>下面的例子显示了如何使用 <code class="docutils literal notranslate"><span class="pre">require</span></code> 来检查输入的条件
和 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 进行内部错误检查。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgU2hhcmVyIHsKICAgIGZ1bmN0aW9uIHNlbmRIYWxmKGFkZHJlc3MgcGF5YWJsZSBhZGRyKSBwdWJsaWMgcGF5YWJsZSByZXR1cm5zICh1aW50IGJhbGFuY2UpIHsKICAgICAgICByZXF1aXJlKG1zZy52YWx1ZSAlIDIgPT0gMCwgIkV2ZW4gdmFsdWUgcmVxdWlyZWQuIik7CiAgICAgICAgdWludCBiYWxhbmNlQmVmb3JlVHJhbnNmZXIgPSBhZGRyZXNzKHRoaXMpLmJhbGFuY2U7CiAgICAgICAgYWRkci50cmFuc2Zlcihtc2cudmFsdWUgLyAyKTsKICAgICAgICAvLyDnlLHkuo7ovazotKblpLHotKXlkI7mipvlh7rlvILluLjlubbkuJTkuI3og73lnKjov5nph4zlm57osIPvvIwKICAgICAgICAvLyDlm6DmraTmiJHku6zlupTor6XmsqHmnInlip7ms5Xku43nhLbmnInkuIDljYrnmoTpkrHjgIIKICAgICAgICBhc3NlcnQoYWRkcmVzcyh0aGlzKS5iYWxhbmNlID09IGJhbGFuY2VCZWZvcmVUcmFuc2ZlciAtIG1zZy52YWx1ZSAvIDIpOwogICAgICAgIHJldHVybiBhZGRyZXNzKHRoaXMpLmJhbGFuY2U7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Sharer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sendHalf</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>addr<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Even value required.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">balanceBeforeTransfer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">).</span>balance<span class="p">;</span>
<span class="w">        </span>addr<span class="p">.</span>transfer<span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 由于转账失败后抛出异常并且不能在这里回调，</span>
<span class="w">        </span><span class="c1">// 因此我们应该没有办法仍然有一半的钱。</span>
<span class="w">        </span>assert<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">).</span>balance<span class="w"> </span><span class="o">==</span><span class="w"> </span>balanceBeforeTransfer<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">msg.value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">).</span>balance<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在内部， Solidity 会执行恢复操作（指令 <code class="docutils literal notranslate"><span class="pre">0xfd</span></code> ）。
这会导致 EVM 恢复对状态所做的所有更改。恢复的原因是不能继续安全地执行，
因为没有实现预期的效果，还因为我们想保留交易的原子性，
所以最安全的做法是恢复所有更改并使整个交易（或至少是调用）不产生效果。</p>
<p>在这两种情况下，调用者可以使用 <code class="docutils literal notranslate"><span class="pre">try</span></code>/ <code class="docutils literal notranslate"><span class="pre">catch</span></code> 对这种失败做出处理，
但被调用者的变化将总是被恢复。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在Solidity 0.8.0之前，Panic异常曾使用 <code class="docutils literal notranslate"><span class="pre">invalid</span></code> 操作码，
它消耗了所有可用于调用的气体。在Metropolis发布之前，
使用 <code class="docutils literal notranslate"><span class="pre">require</span></code> 的异常会消耗所有气体。</p>
</div>
</section>
<section id="revert">
<span id="revert-statement"></span><h4><code class="docutils literal notranslate"><span class="pre">revert</span></code><a class="headerlink" href="#revert" title="此标题的永久链接"></a></h4>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 语句和 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 函数来触发直接恢复。</p>
<p><code class="docutils literal notranslate"><span class="pre">revert</span></code> 语句将一个自定义的错误作为直接参数，没有括号：</p>
<blockquote>
<div><p>revert CustomError(arg1, arg2);</p>
</div></blockquote>
<p>出于向后兼容的原因，还有一个 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 函数，
它使用圆括号并接受一个字符串：</p>
<blockquote>
<div><p>revert();
revert(&quot;description&quot;);</p>
</div></blockquote>
<p>错误数据将被传回给调用者，可以在那里捕获。
使用 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 会导致没有任何错误数据的还原，
而 <code class="docutils literal notranslate"><span class="pre">revert(&quot;description&quot;)</span></code> 将创建一个 <code class="docutils literal notranslate"><span class="pre">Error(string)</span></code> 错误。</p>
<p>使用一个自定义的错误实例通常会比字符串描述便宜得多，
因为您可以使用错误的名称来描述它，它的编码只有四个字节。
可以通过NatSpec提供更长的描述，这不会产生任何费用。</p>
<p>下面的例子显示了如何将一个错误字符串和一个自定义的错误实例
与 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 和相应的 <code class="docutils literal notranslate"><span class="pre">require</span></code> 一起使用。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFZlbmRpbmdNYWNoaW5lIHsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBlcnJvciBVbmF1dGhvcml6ZWQoKTsKICAgIGZ1bmN0aW9uIGJ1eSh1aW50IGFtb3VudCkgcHVibGljIHBheWFibGUgewogICAgICAgIGlmIChhbW91bnQgPiBtc2cudmFsdWUgLyAyIGV0aGVyKQogICAgICAgICAgICByZXZlcnQoIk5vdCBlbm91Z2ggRXRoZXIgcHJvdmlkZWQuIik7CiAgICAgICAgLy8g5Y+m5LiA56eN5pa55rOV77yaCiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgYW1vdW50IDw9IG1zZy52YWx1ZSAvIDIgZXRoZXIsCiAgICAgICAgICAgICJOb3QgZW5vdWdoIEV0aGVyIHByb3ZpZGVkLiIKICAgICAgICApOwogICAgICAgIC8vIOaJp+ihjOi0reS5sOOAggogICAgfQogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBwdWJsaWMgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKQogICAgICAgICAgICByZXZlcnQgVW5hdXRob3JpemVkKCk7CgogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYWRkcmVzcyh0aGlzKS5iYWxhbmNlKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">VendingMachine</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span>
<span class="w">    </span>error<span class="w"> </span>Unauthorized<span class="p">();</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">buy</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>amount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">msg.value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span>ether<span class="p">)</span>
<span class="w">            </span>revert<span class="p">(</span><span class="s2">&quot;Not enough Ether provided.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 另一种方法：</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span>amount<span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">msg.value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span>ether<span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;Not enough Ether provided.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 执行购买。</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>owner<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>Unauthorized<span class="p">();</span>

<span class="w">        </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">).</span>balance<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(!condition)</span> <span class="pre">revert(...);</span></code> 和 <code class="docutils literal notranslate"><span class="pre">require(condition,</span> <span class="pre">...);</span></code> 这两种方式是等价的，
只要 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 和 <code class="docutils literal notranslate"><span class="pre">require</span></code> 的参数没有副作用，比如说它们只是字符串。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">require</span></code> 函数和其他函数一样。这意味着在执行函数本身之前，所有参数都会被评估。
特别是，在 <code class="docutils literal notranslate"><span class="pre">require(condition,</span> <span class="pre">f())</span></code> 中，即使 <code class="docutils literal notranslate"><span class="pre">condition</span></code> 为真，
函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 也被执行。</p>
</div>
<p>提供的字符串是 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI编码</span></a> 之后的，就像调用一个函数 <code class="docutils literal notranslate"><span class="pre">Error(string)</span></code> 一样。
在上面的例子中， <code class="docutils literal notranslate"><span class="pre">revert(&quot;Not</span> <span class="pre">enough</span> <span class="pre">Ether</span> <span class="pre">provided.&quot;);</span></code> 返回以下十六进制作为错误返回数据：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=MHgwOGMzNzlhMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZykg55qE5Ye95pWw6YCJ5oup5ZmoCjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMCAvLyDmlbDmja7nmoTlgY/np7vph4/vvIgzMu+8iQoweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWEgLy8g5a2X56ym5Liy6ZW/5bqm77yIMjbvvIkKMHg0ZTZmNzQyMDY1NmU2Zjc1Njc2ODIwNDU3NDY4NjU3MjIwNzA3MjZmNzY2OTY0NjU2NDJlMDAwMDAwMDAwMDAwIC8vIOWtl+espuS4suaVsOaNru+8iCJOb3QgZW5vdWdoIEV0aGVyIHByb3ZpZGVkLiIg55qEIEFTQ0lJIOe8luegge+8jDI25a2X6IqC77yJ"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="mh">0x08c379a0</span>                                                         <span class="c1">// Error(string) 的函数选择器</span>
<span class="mh">0x0000000000000000000000000000000000000000000000000000000000000020</span> <span class="c1">// 数据的偏移量（32）</span>
<span class="mh">0x000000000000000000000000000000000000000000000000000000000000001a</span> <span class="c1">// 字符串长度（26）</span>
<span class="mh">0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000</span> <span class="c1">// 字符串数据（&quot;Not enough Ether provided.&quot; 的 ASCII 编码，26字节）</span>
</pre></div>
</div>
<p>调用者可以使用 <code class="docutils literal notranslate"><span class="pre">try</span></code> / <code class="docutils literal notranslate"><span class="pre">catch</span></code> 检索所提供的消息，如下所示。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>以前有一个叫 <code class="docutils literal notranslate"><span class="pre">throw</span></code> 的关键字，其语义与 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 相同，
在0.4.13版本中被弃用，在0.5.0版本中被删除。</p>
</div>
</section>
<section id="try-catch">
<span id="id14"></span><h4><code class="docutils literal notranslate"><span class="pre">try</span></code> / <code class="docutils literal notranslate"><span class="pre">catch</span></code><a class="headerlink" href="#try-catch" title="此标题的永久链接"></a></h4>
<p>外部调用的失败可以用 try/catch 语句来捕获，如下所示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CgppbnRlcmZhY2UgRGF0YUZlZWQgeyBmdW5jdGlvbiBnZXREYXRhKGFkZHJlc3MgdG9rZW4pIGV4dGVybmFsIHJldHVybnMgKHVpbnQgdmFsdWUpOyB9Cgpjb250cmFjdCBGZWVkQ29uc3VtZXIgewogICAgRGF0YUZlZWQgZmVlZDsKICAgIHVpbnQgZXJyb3JDb3VudDsKICAgIGZ1bmN0aW9uIHJhdGUoYWRkcmVzcyB0b2tlbikgcHVibGljIHJldHVybnMgKHVpbnQgdmFsdWUsIGJvb2wgc3VjY2VzcykgewogICAgICAgIC8vIOWmguaenOaciTEw5Liq5Lul5LiK55qE6ZSZ6K+v77yM5bCx5rC45LmF5YGc55So6K+l5py65Yi244CCCiAgICAgICAgcmVxdWlyZShlcnJvckNvdW50IDwgMTApOwogICAgICAgIHRyeSBmZWVkLmdldERhdGEodG9rZW4pIHJldHVybnMgKHVpbnQgdikgewogICAgICAgICAgICByZXR1cm4gKHYsIHRydWUpOwogICAgICAgIH0gY2F0Y2ggRXJyb3Ioc3RyaW5nIG1lbW9yeSAvKnJlYXNvbiovKSB7CiAgICAgICAgICAgIC8vIOWmguaenOWcqGdldERhdGHkuK3osIPnlKhyZXZlcnTvvIwKICAgICAgICAgICAgLy8g5bm25LiU5o+Q5L6b5LqG5LiA5Liq5Y6f5Zug5a2X56ym5Liy77yMCiAgICAgICAgICAgIC8vIOWImeaJp+ihjOivpeWRveS7pOOAggogICAgICAgICAgICBlcnJvckNvdW50Kys7CiAgICAgICAgICAgIHJldHVybiAoMCwgZmFsc2UpOwogICAgICAgIH0gY2F0Y2ggUGFuaWModWludCAvKmVycm9yQ29kZSovKSB7CiAgICAgICAgICAgIC8vIOWcqOWPkeeUn1Bhbmlj5byC5bi455qE5oOF5Ya15LiL5omn6KGM77yMCiAgICAgICAgICAgIC8vIOWNs+WHuueOsOS4pemHjeeahOmUmeivr++8jOWmgumZpOS7pembtuaIlua6ouWHuuOAggogICAgICAgICAgICAvLyDplJnor6/ku6PnoIHlj6/ku6XnlKjmnaXnoa7lrprplJnor6/nmoTnp43nsbvjgIIKICAgICAgICAgICAgZXJyb3JDb3VudCsrOwogICAgICAgICAgICByZXR1cm4gKDAsIGZhbHNlKTsKICAgICAgICB9IGNhdGNoIChieXRlcyBtZW1vcnkgLypsb3dMZXZlbERhdGEqLykgewogICAgICAgICAgICAvLyDlnKjkvb/nlKhyZXZlcnQoKeeahOaDheWGteS4i++8jOS8muaJp+ihjOi/meS4quWRveS7pOOAggogICAgICAgICAgICBlcnJvckNvdW50Kys7CiAgICAgICAgICAgIHJldHVybiAoMCwgZmFsc2UpOwogICAgICAgIH0KICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.1</span><span class="p">;</span>

interface<span class="w"> </span>DataFeed<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">function</span><span class="w"> </span><span class="nv">getData</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">token</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">FeedConsumer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>DataFeed<span class="w"> </span>feed<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">errorCount</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">rate</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">token</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 如果有10个以上的错误，就永久停用该机制。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>errorCount<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">);</span>
<span class="w">        </span>try<span class="w"> </span>feed<span class="p">.</span>getData<span class="p">(</span>token<span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>v<span class="p">,</span><span class="w"> </span><span class="kt">true</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>catch<span class="w"> </span>Error<span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span><span class="cm">/*reason*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 如果在getData中调用revert，</span>
<span class="w">            </span><span class="c1">// 并且提供了一个原因字符串，</span>
<span class="w">            </span><span class="c1">// 则执行该命令。</span>
<span class="w">            </span>errorCount<span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="kt">false</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>catch<span class="w"> </span>Panic<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="cm">/*errorCode*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 在发生Panic异常的情况下执行，</span>
<span class="w">            </span><span class="c1">// 即出现严重的错误，如除以零或溢出。</span>
<span class="w">            </span><span class="c1">// 错误代码可以用来确定错误的种类。</span>
<span class="w">            </span>errorCount<span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="kt">false</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>catch<span class="w"> </span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span><span class="cm">/*lowLevelData*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 在使用revert()的情况下，会执行这个命令。</span>
<span class="w">            </span>errorCount<span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="kt">false</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">try</span></code> 关键字后面必须有一个表达式，代表外部函数调用或合约建（ <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">ContractName()</span></code> ）。
表达式中的错误不会被捕获（例如，如果它是一个复杂的表达式，也涉及到内部函数调用），
只有外部调用本身发生恢复。
接下来的 <code class="docutils literal notranslate"><span class="pre">returns</span></code> 部分（是可选的）声明了与外部调用返回的类型相匹配的返回变量。
如果没有错误，这些变量将被分配，合约执行将在第一个成功代码块内继续。
如果到达成功代码块的末端，则在 <code class="docutils literal notranslate"><span class="pre">catch</span></code> 块之后继续执行。</p>
<p>Solidity 根据错误的类型，支持不同种类的捕获块：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">Error(string</span> <span class="pre">memory</span> <span class="pre">reason)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>： 这个catch子句会被执行，
如果错误是由 <code class="docutils literal notranslate"><span class="pre">revert(&quot;reasonString&quot;)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">require(false,</span> <span class="pre">&quot;reasonString&quot;)</span></code> 造成的
（或内部错误造成的）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">Panic(uint</span> <span class="pre">errorCode)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>： 如果错误是由Panic异常引起的，
例如由失败的 <code class="docutils literal notranslate"><span class="pre">assert</span></code>、除以0、无效的数组访问、算术溢出和其他原因引起的，这个catch子句将被运行。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">(bytes</span> <span class="pre">memory</span> <span class="pre">lowLevelData)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>： 如果错误签名与其他子句不匹配，
或者在解码错误信息时出现了错误，或者没有与异常一起提供错误数据，
那么这个子句就会被执行。在这种情况下，声明的变量提供了对低级错误数据的访问。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>： 如果您对错误数据不感兴趣，您可以直接使用
<code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> （甚至作为唯一的catch子句）来代替前面的子句。</p></li>
</ul>
<p>计划在未来支持其他类型的错误数据。字符串 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Panic</span></code> 目前是按原样解析的，不作为标识符处理。</p>
<p>为了捕捉所有的错误情况，您至少要有 <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">{</span> <span class="pre">...}</span></code> 或 <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">(bytes</span> <span class="pre">memory</span> <span class="pre">lowLevelData)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 子句。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">returns</span></code> 和 <code class="docutils literal notranslate"><span class="pre">catch</span></code> 子句中声明的变量只在后面的代码块中有作用域。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果在 try/catch 语句内部的返回数据解码过程中发生错误，
这将导致当前执行的合约出现异常，正因为如此，它不会在catch子句中被捕获。
如果在 <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">Error(string</span> <span class="pre">memory</span> <span class="pre">reason)</span></code> 的解码过程中出现错误，
并且有一个低级的catch子句，那么这个错误就会在那里被捕获。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果执行到一个catch代码块，那么外部调用的状态改变效果已经被恢复。
如果执行到了成功代码块，那么这些影响就没有被还原。
如果影响已经被还原，那么执行要么在catch代码块中继续，
要么try/catch语句的执行本身被还原（例如由于上面提到的解码失败或者由于没有提供低级别的catch子句）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>调用失败背后的原因可能是多方面的。不要认为错误信息是直接来自被调用的合约：
错误可能发生在调用链的更深处，被调用的合约只是转发了它。
另外，这可能是由于消耗完气体值的情况，而不是故意的错误状况。
调用方总是保留调用中至少1/64的气体值，
因此，即使被调用合约没有气体了，调用方仍然有一些气体。</p>
</div>
</section>
</section>
</section>
<span id="document-contracts"></span><section id="contracts">
<span id="index-0"></span><span id="id1"></span><h2>合约<a class="headerlink" href="#contracts" title="此标题的永久链接"></a></h2>
<p>Solidity中的合约类似于面向对象语言中的类。
它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。
在不同的合约（实例）上调用一个函数将执行一个EVM函数调用，
从而切换上下文，使调用合约中的状态变量无法访问。
一个合约和它的函数需要被调用才会发生。
在以太坊中没有 &quot;cron&quot; 的概念，在特定的事件中自动调用一个函数。</p>
<section id="index-1">
<span id="id2"></span><h3>创建合约<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>可以通过以太坊交易 “从外部” 或从 Solidity 合约内部创建合约。</p>
<p>集成开发环境，如 <a class="reference external" href="https://remix.ethereum.org/">Remix</a>，使用UI元素使创建过程无缝化。</p>
<p>在以太坊上以编程方式创建合约的一种方法是通过JavaScript API <a class="reference external" href="https://github.com/ethereum/web3.js">web3.js</a>。
它有一个名为 <a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> 的函数，
以方便创建合约。</p>
<p>当一个合约被创建时，它的 <a class="reference internal" href="#constructor"><span class="std std-ref">构造函数（constructor）</span></a>
（一个用 <code class="docutils literal notranslate"><span class="pre">constructor</span></code> 关键字声明的函数）被执行一次。</p>
<p>构造函数是可选的。但是只允许有一个构造函数，这意味着不支持重载。</p>
<p>构造函数执行完毕后，合约的最终代码被存储在区块链上。
这段代码包括所有公开和外部函数，以及所有通过函数调用可从那里到达的函数。
部署的代码不包括构造函数代码或只从构造函数调用的内部函数。</p>
<p id="index-2">在内部，构造函数参数在合约代码之后通过 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI编码</span></a> 传递，
但是如果您使用 <code class="docutils literal notranslate"><span class="pre">web3.js</span></code> 则不必关心这个问题。</p>
<p>如果一个合约想创建另一个合约，创建者必须知道所创建合约的源代码（和二进制）。
这意味着，循环的创建依赖是不可能的。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIOaYr+WmguS4i+WumuS5ieeahOWQiOe6puexu+Wei+OAggogICAgLy8g5LiN5Yib5bu65paw5ZCI57qm55qE6K+d77yM5Lmf5Y+v5Lul5byV55So5a6D44CCCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8g6L+Z5piv5rOo5YaMIGNyZWF0b3Ig5ZKM6K6+572u5ZCN56ew55qE5p6E6YCg5Ye95pWw44CCCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWVfKSB7CiAgICAgICAgLy8g54q25oCB5Y+Y6YeP6YCa6L+H5YW25ZCN56ew6K6/6Zeu77yMCiAgICAgICAgLy8g6ICM5LiN5piv6YCa6L+H5L6L5aaCIGB0aGlzLm93bmVyYCDnmoTmlrnlvI/orr/pl67jgIIKICAgICAgICAvLyDlh73mlbDlj6/ku6Xnm7TmjqXmiJbpgJrov4cgYHRoaXMuZmAg6K6/6Zeu44CCCiAgICAgICAgLy8g5L2G5ZCO6ICF5o+Q5L6b5LqG5LiA5Liq5a+55Ye95pWw55qE5aSW6YOo5Y+v6KeG5pa55rOV44CCCiAgICAgICAgLy8g54m55Yir5piv5Zyo5p6E6YCg5Ye95pWw5Lit77yM5oKo5LiN5bqU6K+l5LuO5aSW6YOo6K6/6Zeu5Ye95pWw77yMCiAgICAgICAgLy8g5Zug5Li66K+l5Ye95pWw6L+Y5LiN5a2Y5Zyo44CCCiAgICAgICAgLy8g6K+m6KeB5LiL5LiA6IqC44CCCiAgICAgICAgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgICAgICAvLyDmiJHku6zov5vooYzkuobku44gYGFkZHJlc3NgIOWIsCBgVG9rZW5DcmVhdG9yYCDnmoTmmL7lvI/nsbvlnovovazmjaLvvIwKICAgICAgICAvLyDlubblgYflrprosIPnlKjlkIjnuqbnmoTnsbvlnovmmK8gYFRva2VuQ3JlYXRvcmDvvIwKICAgICAgICAvLyDmsqHmnInnnJ/mraPnmoTmlrnms5XmnaXpqozor4HvvIwKICAgICAgICAvLyDov5nlubbmsqHmnInliJvlu7rkuIDkuKrmlrDnmoTlkIjnuqbjgIIKICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBuYW1lXzsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyDlj6rmnInliJvlu7rogIXlj6/ku6XmlLnlj5jlkI3np7DjgIIKICAgICAgICAvLyDmiJHku6zmoLnmja7lkIjnuqbnmoTlnLDlnYDov5vooYzmr5TovoPvvIwKICAgICAgICAvLyDlroPlj6/ku6XpgJrov4fmmL7lvI/ovazmjaLkuLrlnLDlnYDmnaXmo4DntKLjgIIKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBhZGRyZXNzKGNyZWF0b3IpKQogICAgICAgICAgICBuYW1lID0gbmV3TmFtZTsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgewogICAgICAgIC8vIOWPquacieW9k+WJjeaJgOacieiAheaJjeiDveWPkemAgSB0b2tlbuOAggogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIOaIkeS7rOmAmui/h+S9v+eUqOS4i+mdouWumuS5ieeahCBgVG9rZW5DcmVhdG9yYCDlkIjnuqbnmoTkuIDkuKrlh73mlbAKICAgICAgICAvLyDmnaXor6Lpl67liJvlu7rogIXlkIjnuqbmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICAvLyDlpoLmnpzosIPnlKjlpLHotKXvvIjkvovlpoLnlLHkuo7msJTkvZPlgLzogJflsL3vvInvvIwKICAgICAgICAvLyDov5nph4znmoTmiafooYzkuZ/kvJrlpLHotKXjgIIKICAgICAgICBpZiAoY3JlYXRvci5pc1Rva2VuVHJhbnNmZXJPSyhvd25lciwgbmV3T3duZXIpKQogICAgICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9CgoKY29udHJhY3QgVG9rZW5DcmVhdG9yIHsKICAgIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGJ5dGVzMzIgbmFtZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChPd25lZFRva2VuIHRva2VuQWRkcmVzcykKICAgIHsKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgYFRva2VuYCDlkIjnuqblubbov5Tlm57lhbblnLDlnYDjgIIKICAgICAgICAvLyDku45KYXZhU2NyaXB05pa56Z2i5p2l55yL77yMCiAgICAgICAgLy8g6L+Z5Liq5Ye95pWw55qE6L+U5Zue57G75Z6L5pivIGBhZGRyZXNzYO+8jAogICAgICAgIC8vIOWboOS4uui/meaYr0FCSeS4reacgOaOpei/keeahOexu+Wei+OAggogICAgICAgIHJldHVybiBuZXcgT3duZWRUb2tlbihuYW1lKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzLCBieXRlczMyIG5hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8g5ZCM5qC377yMYHRva2VuQWRkcmVzc2Ag55qE5aSW6YOo57G75Z6L5piv566A5Y2V55qEIGBhZGRyZXNzYOOAggogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIOaJp+ihjOajgOafpe+8jOS7peehruWumuaYr+WQpuW6lOivpeWwhuS7o+W4gei9rOenu+WIsCBgT3duZWRUb2tlbmAg5ZCI57qm5LiK44CCCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyDmo4Dmn6XkuIDkuKrku7vmhI/nmoTmnaHku7bvvIznnIvmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoY3VycmVudE93bmVyLCBuZXdPd25lcikpWzBdID09IDB4N2Y7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">OwnedToken</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// `TokenCreator` 是如下定义的合约类型。</span>
<span class="w">    </span><span class="c1">// 不创建新合约的话，也可以引用它。</span>
<span class="w">    </span>TokenCreator<span class="w"> </span>creator<span class="p">;</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 这是注册 creator 和设置名称的构造函数。</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 状态变量通过其名称访问，</span>
<span class="w">        </span><span class="c1">// 而不是通过例如 `this.owner` 的方式访问。</span>
<span class="w">        </span><span class="c1">// 函数可以直接或通过 `this.f` 访问。</span>
<span class="w">        </span><span class="c1">// 但后者提供了一个对函数的外部可视方法。</span>
<span class="w">        </span><span class="c1">// 特别是在构造函数中，您不应该从外部访问函数，</span>
<span class="w">        </span><span class="c1">// 因为该函数还不存在。</span>
<span class="w">        </span><span class="c1">// 详见下一节。</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 我们进行了从 `address` 到 `TokenCreator` 的显式类型转换，</span>
<span class="w">        </span><span class="c1">// 并假定调用合约的类型是 `TokenCreator`，</span>
<span class="w">        </span><span class="c1">// 没有真正的方法来验证，</span>
<span class="w">        </span><span class="c1">// 这并没有创建一个新的合约。</span>
<span class="w">        </span>creator<span class="w"> </span><span class="o">=</span><span class="w"> </span>TokenCreator<span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span>name<span class="w"> </span><span class="o">=</span><span class="w"> </span>name_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeName</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">newName</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 只有创建者可以改变名称。</span>
<span class="w">        </span><span class="c1">// 我们根据合约的地址进行比较，</span>
<span class="w">        </span><span class="c1">// 它可以通过显式转换为地址来检索。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>creator<span class="p">))</span>
<span class="w">            </span>name<span class="w"> </span><span class="o">=</span><span class="w"> </span>newName<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 只有当前所有者才能发送 token。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span><span class="kt">return</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 我们通过使用下面定义的 `TokenCreator` 合约的一个函数</span>
<span class="w">        </span><span class="c1">// 来询问创建者合约是否应该进行转移。</span>
<span class="w">        </span><span class="c1">// 如果调用失败（例如由于气体值耗尽），</span>
<span class="w">        </span><span class="c1">// 这里的执行也会失败。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>creator<span class="p">.</span>isTokenTransferOK<span class="p">(</span>owner<span class="p">,</span><span class="w"> </span>newOwner<span class="p">))</span>
<span class="w">            </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">TokenCreator</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createToken</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>OwnedToken<span class="w"> </span>tokenAddress<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 创建一个新的 `Token` 合约并返回其地址。</span>
<span class="w">        </span><span class="c1">// 从JavaScript方面来看，</span>
<span class="w">        </span><span class="c1">// 这个函数的返回类型是 `address`，</span>
<span class="w">        </span><span class="c1">// 因为这是ABI中最接近的类型。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>OwnedToken<span class="p">(</span>name<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeName</span><span class="p">(</span>OwnedToken<span class="w"> </span>tokenAddress<span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 同样，`tokenAddress` 的外部类型是简单的 `address`。</span>
<span class="w">        </span>tokenAddress<span class="p">.</span>changeName<span class="p">(</span>name<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 执行检查，以确定是否应该将代币转移到 `OwnedToken` 合约上。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">isTokenTransferOK</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">currentOwner</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">ok</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 检查一个任意的条件，看是否应该进行转移。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span>currentOwner<span class="p">,</span><span class="w"> </span>newOwner<span class="p">))[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x7f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="getter">
<span id="visibility-and-getters"></span><h3>可见性和 getter 函数<a class="headerlink" href="#getter" title="此标题的永久链接"></a></h3>
<section id="id3">
<h4>状态变量的可见性<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">public</span></code></dt><dd><p>公开状态变量与内部变量的不同之处在于，编译器会自动为它们生成 <a class="reference internal" href="#getter-functions"><span class="std std-ref">getter函数</span></a>，
从而允许其他合约读取它们的值。当在同一个合约中使用时，外部访问（例如 <code class="docutils literal notranslate"><span class="pre">this.x</span></code>）会调用getter，
而内部访问（例如 <code class="docutils literal notranslate"><span class="pre">x</span></code>）会直接从存储中获取变量值。
Setter函数没有被生成，所以其他合约不能直接修改其值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code></dt><dd><p>内部状态变量只能从它们所定义的合约和派生合约中访问。
它们不能被外部访问。
这是状态变量的默认可见性。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>标记一些变量为 <code class="docutils literal notranslate"><span class="pre">private</span></code> 或 <code class="docutils literal notranslate"><span class="pre">internal</span></code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p>
</div>
</section>
<section id="id4">
<h4>函数的可见性<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p>Solidity 有两种函数调用：确实创建了实际 EVM 消息调用的外部函数和不创建 EVM 消息调用的内部函数。
此外，派生合约可能无法访问内部函数。
这就产生了四种类型的函数的可见性。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">external</span></code></dt><dd><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。
一个外部函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 不能从内部调用
（即 <code class="docutils literal notranslate"><span class="pre">f()</span></code> 不起作用，但 <code class="docutils literal notranslate"><span class="pre">this.f()</span></code> 可以）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">public</span></code></dt><dd><p>公开函数是合约接口的一部分，可以在内部或通过消息调用。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code></dt><dd><p>内部函数只能从当前的合约或从它派生出来的合约中访问。
它们不能被外部访问。
由于它们没有通过合约的ABI暴露在外部，它们可以接受内部类型的参数，如映射或存储引用。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>私有函数和内部函数一样，但它们在派生合约中是不可见的。</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>标记一些变量为 <code class="docutils literal notranslate"><span class="pre">private</span></code> 或 <code class="docutils literal notranslate"><span class="pre">internal</span></code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p>
</div>
<p>在状态变量的类型之后，以及在函数的参数列表和返回参数列表之间，都会给出可见性指定符。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setData</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>data<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在下面的例子中，合约 <code class="docutils literal notranslate"><span class="pre">D</span></code>, 可以调用 <code class="docutils literal notranslate"><span class="pre">c.getData()</span></code> 来检索状态存储中 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的值，
但不能调用 <code class="docutils literal notranslate"><span class="pre">f</span></code>。 合约 <code class="docutils literal notranslate"><span class="pre">E</span></code> 是从合约 <code class="docutils literal notranslate"><span class="pre">C</span></code> 派生出来的，因此可以调用 <code class="docutils literal notranslate"><span class="pre">compute</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyDov5nlsIbkuI3kvJrnvJbor5EKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyDplJnor6/vvJrmiJDlkZggYGZgIOS4jeWPr+ingQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyDplJnor6/vvJrmiJDlkZggYGNvbXB1dGVgIOS4jeWPr+ingQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIOiuv+mXruWGhemDqOaIkOWRmO+8iOS7jue7p+aJv+WQiOe6puiuv+mXrueItuWQiOe6puaIkOWRmO+8iQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">private </span><span class="nv">data</span><span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setData</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>data<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getData</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>data<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">compute</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 这将不会编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">readData</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>C<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>C<span class="p">();</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">local</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>f<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">);</span><span class="w"> </span><span class="c1">// 错误：成员 `f` 不可见</span>
<span class="w">        </span>c<span class="p">.</span>setData<span class="p">(</span><span class="m m-Decimal">3</span><span class="p">);</span>
<span class="w">        </span>local<span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>getData<span class="p">();</span>
<span class="w">        </span>local<span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>compute<span class="p">(</span><span class="m m-Decimal">3</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 错误：成员 `compute` 不可见</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">E</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>C<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>C<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>C<span class="p">();</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>compute<span class="p">(</span><span class="m m-Decimal">3</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 访问内部成员（从继承合约访问父合约成员）</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="getter-functions">
<span id="index-4"></span><span id="id5"></span><h4>Getter 函数<a class="headerlink" href="#getter-functions" title="此标题的永久链接"></a></h4>
<p>编译器会自动为所有 <strong>公开</strong> 状态变量创建getter函数。
对于下面给出的合约，编译器将生成一个名为 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的函数，
它没有任何输入参数，并返回一个 <code class="docutils literal notranslate"><span class="pre">uint</span></code>，
即状态变量 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的值。状态变量在声明时可以被初始化。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Caller</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>C<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>C<span class="p">();</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>c<span class="p">.</span>data<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>getter函数具有外部可见性。
如果该符号被内部访问（即没有 <code class="docutils literal notranslate"><span class="pre">this.</span></code>），它被评估为一个状态变量。
如果它被外部访问（即有 <code class="docutils literal notranslate"><span class="pre">this.</span></code>），它将被评价为一个函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIOWGhemDqOiuv+mXrgogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8g5aSW6YOo6K6/6ZeuCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">x</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>data<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// 内部访问</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">this</span><span class="p">.</span>data<span class="p">();</span><span class="w"> </span><span class="c1">// 外部访问</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您有一个数组类型的 <code class="docutils literal notranslate"><span class="pre">public</span></code> 状态变量，
那么您只能通过生成的getter函数检索数组的单个元素。
这种机制的存在是为了避免在返回整个数组时产生高额的气体成本。
您可以使用参数来指定要返回的单个元素，例如 <code class="docutils literal notranslate"><span class="pre">myArray(0)</span></code>。
如果您想在一次调用中返回整个数组，那么您需要写一个函数，例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyDlhazlvIDnirbmgIHlj5jph48KICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyDnvJbor5HlmajnlJ/miJDnmoRnZXR0ZXLlh73mlbAKICAgIC8qCiAgICBmdW5jdGlvbiBteUFycmF5KHVpbnQgaSkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBteUFycmF5W2ldOwogICAgfQogICAgKi8KCiAgICAvLyDov5Tlm57mlbTkuKrmlbDnu4TnmoTlh73mlbAKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">arrayExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 公开状态变量</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>myArray<span class="p">;</span>

<span class="w">    </span><span class="c1">// 编译器生成的getter函数</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    function myArray(uint i) public view returns (uint) {</span>
<span class="cm">        return myArray[i];</span>
<span class="cm">    }</span>
<span class="cm">    */</span>

<span class="w">    </span><span class="c1">// 返回整个数组的函数</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getArray</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>myArray<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在您可以使用 <code class="docutils literal notranslate"><span class="pre">getArray()</span></code> 来检索整个数组，
而不是使用 <code class="docutils literal notranslate"><span class="pre">myArray(i)</span></code>，它每次调用只返回一个元素。</p>
<p>下一个例子稍微复杂一些：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcgKHVpbnQgPT4gdWludCkgbWFwOwogICAgICAgIHVpbnRbM10gYzsKICAgICAgICB1aW50W10gZDsKICAgICAgICBieXRlcyBlOwogICAgfQogICAgbWFwcGluZyAodWludCA9PiBtYXBwaW5nKGJvb2wgPT4gRGF0YVtdKSkgcHVibGljIGRhdGE7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Complex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">;</span>
<span class="w">        </span>bytes3<span class="w"> </span>b<span class="p">;</span>
<span class="w">        </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>map<span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span>c<span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>d<span class="p">;</span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">e</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Data<span class="p">[]))</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>data<span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它生成了一个如下形式的函数。结构中的映射和数组（字节数组除外）被省略了，
因为没有好的方法来选择单个结构成员或为映射提供一个键：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">data</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg3</span><span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span>bytes3<span class="w"> </span>b<span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>e<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">[</span>arg1<span class="p">][</span>arg2<span class="p">][</span>arg3<span class="p">].</span>a<span class="p">;</span>
<span class="w">    </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">[</span>arg1<span class="p">][</span>arg2<span class="p">][</span>arg3<span class="p">].</span>b<span class="p">;</span>
<span class="w">    </span>e<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">[</span>arg1<span class="p">][</span>arg2<span class="p">][</span>arg3<span class="p">].</span>e<span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="modifiers">
<span id="index-5"></span><span id="id6"></span><h3>函数修饰器<a class="headerlink" href="#modifiers" title="此标题的永久链接"></a></h3>
<p>函数修饰器可以用来以声明的方式改变函数的行为。
例如，您可以使用修饰器在执行函数之前自动检查一个条件。</p>
<p>修饰器是合约的可继承属性，可以被派生合约重载，
但只有当它们被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 时，才能被重载。
详情请见 <a class="reference internal" href="#modifier-overriding"><span class="std std-ref">修饰器重载</span></a>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIOi/meS4quWQiOe6puWPquWumuS5ieS6huS4gOS4quS/rumlsOWZqO+8jOS9huayoeacieS9v+eUqOWug++8mgogICAgLy8g5a6D5bCG5Zyo5rS+55Sf5ZCI57qm5Lit5L2/55So44CCCiAgICAvLyDkv67ppbDlmajmiYDkv67ppbDnmoTlh73mlbDkvZPkvJrooqvmj5LlhaXliLDnibnmrornrKblj7cgYF87YCDnmoTkvY3nva7jgIIKICAgIC8vIOi/meaEj+WRs+edgO+8jOWmguaenOaJgOacieiAheiwg+eUqOi/meS4quWHveaVsO+8jOi/meS4quWHveaVsOWwseS8muiiq+aJp+ihjO+8jAogICAgLy8g5ZCm5YiZ5bCx5Lya5oqb5Ye65LiA5Liq5byC5bi444CCCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgZGVzdHJ1Y3RpYmxlIGlzIG93bmVkIHsKICAgIC8vIOi/meS4quWQiOe6puS7jiBgb3duZWRgIOWQiOe6pue7p+aJv+S6hiBgb25seU93bmVyYCDkv67ppbDlmajvvIwKICAgIC8vIOW5tuWwhuWFtuW6lOeUqOS6jiBgZGVzdHJveWAg5Ye95pWw77yMCiAgICAvLyDlj6rmnInlnKjlkIjnuqbph4zkv53lrZjnmoQgb3duZXIg6LCD55SoIGBkZXN0cm95YCDlh73mlbDvvIzmiY3kvJrnlJ/mlYjjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBzZWxmZGVzdHJ1Y3Qob3duZXIpOwogICAgfQp9Cgpjb250cmFjdCBwcmljZWQgewogICAgLy8g5L+u6aWw5Zmo5Y+v5Lul5o6l5Y+X5Y+C5pWw77yaCiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBkZXN0cnVjdGlibGUgewogICAgbWFwcGluZyAoYWRkcmVzcyA9PiBib29sKSByZWdpc3RlcmVkQWRkcmVzc2VzOwogICAgdWludCBwcmljZTsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IGluaXRpYWxQcmljZSkgeyBwcmljZSA9IGluaXRpYWxQcmljZTsgfQoKICAgIC8vIOWcqOi/memHjOS5n+S9v+eUqOWFs+mUruWtlyBgcGF5YWJsZWAg6Z2e5bi46YeN6KaB77yMCiAgICAvLyDlkKbliJnlh73mlbDkvJroh6rliqjmi5Lnu53miYDmnInlj5HpgIHnu5nlroPnmoTku6XlpKrluIHjgIIKICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKCkgcHVibGljIHBheWFibGUgY29zdHMocHJpY2UpIHsKICAgICAgICByZWdpc3RlcmVkQWRkcmVzc2VzW21zZy5zZW5kZXJdID0gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VQcmljZSh1aW50IHByaWNlXykgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgcHJpY2UgPSBwcmljZV87CiAgICB9Cn0KCmNvbnRyYWN0IE11dGV4IHsKICAgIGJvb2wgbG9ja2VkOwogICAgbW9kaWZpZXIgbm9SZWVudHJhbmN5KCkgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgICFsb2NrZWQsCiAgICAgICAgICAgICJSZWVudHJhbnQgY2FsbC4iCiAgICAgICAgKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgbG9ja2VkID0gZmFsc2U7CiAgICB9CgogICAgLy8vIOi/meS4quWHveaVsOWPl+S6kuaWpemHj+S/neaKpO+8jOi/meaEj+WRs+edgCBgbXNnLnNlbmRlci5jYWxsYCDkuK3nmoTph43lhaXosIPnlKjkuI3og73lho3mrKHosIPnlKggIGBmYOOAggogICAgLy8vIGByZXR1cm4gN2Ag6K+t5Y+l5oyH5a6a6L+U5Zue5YC85Li6IDfvvIzkvYbkv67ppbDlmajkuK3nmoTor63lj6UgYGxvY2tlZCA9IGZhbHNlYCDku43kvJrmiafooYzjgIIKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgbm9SZWVudHJhbmN5IHJldHVybnMgKHVpbnQpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBtc2cuc2VuZGVyLmNhbGwoIiIpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgcmV0dXJuIDc7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span>

<span class="w">    </span><span class="c1">// 这个合约只定义了一个修饰器，但没有使用它：</span>
<span class="w">    </span><span class="c1">// 它将在派生合约中使用。</span>
<span class="w">    </span><span class="c1">// 修饰器所修饰的函数体会被插入到特殊符号 `_;` 的位置。</span>
<span class="w">    </span><span class="c1">// 这意味着，如果所有者调用这个函数，这个函数就会被执行，</span>
<span class="w">    </span><span class="c1">// 否则就会抛出一个异常。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;Only owner can call this function.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 这个合约从 `owned` 合约继承了 `onlyOwner` 修饰器，</span>
<span class="w">    </span><span class="c1">// 并将其应用于 `destroy` 函数，</span>
<span class="w">    </span><span class="c1">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">priced</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 修饰器可以接受参数：</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>costs<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">price</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>price<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>_<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Register</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>priced<span class="p">,</span><span class="w"> </span>destructible<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>registeredAddresses<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">price</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">initialPrice</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>price<span class="w"> </span><span class="o">=</span><span class="w"> </span>initialPrice<span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 在这里也使用关键字 `payable` 非常重要，</span>
<span class="w">    </span><span class="c1">// 否则函数会自动拒绝所有发送给它的以太币。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span>costs<span class="p">(</span>price<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>registeredAddresses<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changePrice</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">price_</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>price<span class="w"> </span><span class="o">=</span><span class="w"> </span>price_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Mutex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nv">locked</span><span class="p">;</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>noReentrancy<span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>
<span class="w">            </span><span class="o">!</span>locked<span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;Reentrant call.&quot;</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span>locked<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">        </span>locked<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span>
<span class="w">    </span><span class="c1">/// `return 7` 语句指定返回值为 7，但修饰器中的语句 `locked = false` 仍会执行。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>noReentrancy<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">.</span>call<span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您想访问定义在合约 <code class="docutils literal notranslate"><span class="pre">C</span></code> 中的修饰器 <code class="docutils literal notranslate"><span class="pre">m</span></code>，
您可以使用 <code class="docutils literal notranslate"><span class="pre">C.m</span></code> 来引用它而不需要虚拟查询。
只能使用定义在当前合约或其基础合约中的修饰器。
修饰器也可以定义在库合约中，但其使用仅限于同一库合约的函数。</p>
<p>如果同一个函数有多个修饰器，它们之间以空格隔开，并按照所呈现的顺序进行评估运算。</p>
<p>修饰器不能隐式地访问或改变它们所修改的函数的参数和返回值。
它们的值只能在调用的时候明确地传递给它们。</p>
<p>在函数修改器中，有必要指定何时运行应用修改器的函数。
占位符语句（用单个下划线字符 <code class="docutils literal notranslate"><span class="pre">_</span></code> 表示）用于表示被修改的函数主体应该插入的位置。
请注意，占位符操作符与在变量名中使用下划线作为前导或尾随字符不同，
后者是一种风格上的选择。</p>
<p>修饰器或函数体的显式返回只离开当前修饰器或函数体。
返回变量会被赋值，但整个执行逻辑会从前一个修饰器中定义的 <code class="docutils literal notranslate"><span class="pre">_</span></code> 之后继续执行。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在Solidity的早期版本中，具有修饰器的函数中的 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句会表现的不同。</p>
</div>
<p>用 <code class="docutils literal notranslate"><span class="pre">return;</span></code> 从修饰器显式返回并不影响函数返回的值。
然而，修饰器可以选择完全不执行函数主体，在这种情况下，
返回变量被设置为 <a class="reference internal" href="index.html#default-value"><span class="std std-ref">默认值</span></a>，就像函数有一个空主体一样。</p>
<p><code class="docutils literal notranslate"><span class="pre">_</span></code> 符号可以在修饰器中多次出现。每次出现都会被替换成函数体。</p>
<p>允许修饰器参数使用任意表达式，在这种情况下，所有从函数中可见的符号在修饰器中都是可见的。
修饰器中引入的符号在函数中是不可见的（因为它们可能因重载而改变）。</p>
</section>
<section id="constant-immutable">
<span id="constants"></span><span id="index-6"></span><h3>Constant 和 Immutable 状态变量<a class="headerlink" href="#constant-immutable" title="此标题的永久链接"></a></h3>
<p>状态变量可以被声明为 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 或 <code class="docutils literal notranslate"><span class="pre">immutable</span></code>。
在这两种情况下，变量在合约构建完成后不能被修改。
对于 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 变量，其值必须在编译时固定，
而对于 <code class="docutils literal notranslate"><span class="pre">immutable</span></code> 变量，仍然可以在构造时分配。</p>
<p>也可以在文件级别定义 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 变量。</p>
<p>编译器并没有为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式。</p>
<p>与普通的状态变量相比，常量变量（constant）和不可改变的变量（immutable）的气体成本要低得多。
对于常量变量，分配给它的表达式被复制到所有访问它的地方，并且每次都要重新评估，
这使得局部优化成为可能。不可变的变量在构造时被评估一次，其值被复制到代码中所有被访问的地方。
对于这些值，要保留32个字节，即使它们可以装入更少的字节。由于这个原因，常量值有时会比不可变的值更便宜。</p>
<p>目前，并非所有的常量和不可变量的类型都已实现。
唯一支持的类型是 <a class="reference internal" href="index.html#strings"><span class="std std-ref">字符串类型</span></a> （仅用于常量）和 <a class="reference internal" href="index.html#value-types"><span class="std std-ref">值类型</span></a>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjQ7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzOwogICAgdWludCBpbW11dGFibGUgbWF4QmFsYW5jZTsKICAgIGFkZHJlc3MgaW1tdXRhYmxlIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IGRlY2ltYWxzXywgYWRkcmVzcyByZWYpIHsKICAgICAgICBkZWNpbWFscyA9IGRlY2ltYWxzXzsKICAgICAgICAvLyDlr7nkuI3lj6/lj5jph4/nmoTotYvlgLznlJroh7Plj6/ku6Xorr/pl67kuIDkupvlhajlsYDlsZ7mgKfjgIIKICAgICAgICBtYXhCYWxhbmNlID0gcmVmLmJhbGFuY2U7CiAgICB9CgogICAgZnVuY3Rpb24gaXNCYWxhbmNlVG9vSGlnaChhZGRyZXNzIG90aGVyKSBwdWJsaWMgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIG90aGVyLmJhbGFuY2UgPiBtYXhCYWxhbmNlOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.4</span><span class="p">;</span>

<span class="kt">uint</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>X<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">32</span><span class="o">**</span><span class="m m-Decimal">22</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>TEXT<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;abc&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>MY_HASH<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">immutable</span><span class="w"> </span>decimals<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">immutable</span><span class="w"> </span>maxBalance<span class="p">;</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">immutable</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">decimals_</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>decimals<span class="w"> </span><span class="o">=</span><span class="w"> </span>decimals_<span class="p">;</span>
<span class="w">        </span><span class="c1">// 对不可变量的赋值甚至可以访问一些全局属性。</span>
<span class="w">        </span>maxBalance<span class="w"> </span><span class="o">=</span><span class="w"> </span>ref<span class="p">.</span>balance<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">isBalanceTooHigh</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">other</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>other<span class="p">.</span>balance<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>maxBalance<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="constant">
<h4>Constant<a class="headerlink" href="#constant" title="此标题的永久链接"></a></h4>
<p>对于 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 变量，其值在编译时必须是一个常量，并且必须在变量声明的地方分配。
任何访问存储、区块链数据（例如： <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code>, <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 或 <code class="docutils literal notranslate"><span class="pre">block.number</span></code>）
或执行数据（ <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 或 <code class="docutils literal notranslate"><span class="pre">gasleft()</span></code>）或者调用外部合约的表达式都是不允许的。
但可能对内存分配产生副作用的表达式是允许的，但那些可能对其他内存对象产生副作用的表达式是不允许的。
内置函数 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code>， <code class="docutils literal notranslate"><span class="pre">sha256</span></code>， <code class="docutils literal notranslate"><span class="pre">ripemd160</span></code>， <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>， <code class="docutils literal notranslate"><span class="pre">addmod</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mulmod</span></code>
是允许的（尽管除了 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code>，它们确实调用了外部合约）。</p>
<p>允许在内存分配器上产生副作用的原因是，
它应该可以构建复杂的对象，比如说查找表。
这个功能现在还不能完全使用。</p>
</section>
<section id="immutable">
<h4>Immutable<a class="headerlink" href="#immutable" title="此标题的永久链接"></a></h4>
<p>声明为 <code class="docutils literal notranslate"><span class="pre">immutable</span></code> 的变量比声明为 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 的变量受到的限制要少一些。
不可变的变量可以在合约的构造函数中或在声明时被分配一个任意的值。
它们只能被分配一次，并且从那时起，即使在构造时间内也可以被读取。</p>
<p>编译器生成的合约创建代码将在其返回之前修改合约的运行时代码，
用分配给它们的值替换所有对不可变量的引用。
当您将编译器生成的运行时代码与实际存储在区块链中的代码进行比较时，这一点很重要。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在声明时被分配的不可变量只有在合约的构造函数执行时才会被视为初始化。
这意味着您不能在内联中用一个依赖于另一个不可变量的值来初始化不可变量。
然而，您可以在合约的构造函数中这样做。</p>
<p>这是对状态变量初始化和构造函数执行顺序的不同解释的一种保障，特别是在继承方面。</p>
</div>
</section>
</section>
<section id="functions">
<span id="index-7"></span><span id="id7"></span><h3>函数<a class="headerlink" href="#functions" title="此标题的永久链接"></a></h3>
<p>可以在合约内部和外部定义函数。</p>
<p>合约之外的函数，也称为 &quot;自由函数&quot;，总是隐含着 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 的 <a class="reference internal" href="#visibility-and-getters"><span class="std std-ref">可见性</span></a>。
它们的代码包含在所有调用它们的合约中，类似于内部库函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z5Zyo5YaF6YOo6LCD55So6Ieq55Sx5Ye95pWw44CCCiAgICAgICAgLy8g57yW6K+R5Zmo5Lya5bCG5YW25Luj56CB5re75Yqg5Yiw5ZCI57qm5Lit44CCCiAgICAgICAgdWludCBzID0gc3VtKGFycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">sum</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>arr<span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>arr<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span>
<span class="w">        </span>s<span class="w"> </span><span class="o">+=</span><span class="w"> </span>arr<span class="p">[</span>i<span class="p">];</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">ArrayExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nv">found</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>arr<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这在内部调用自由函数。</span>
<span class="w">        </span><span class="c1">// 编译器会将其代码添加到合约中。</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>sum<span class="p">(</span>arr<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>s<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">);</span>
<span class="w">        </span>found<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在合约之外定义的函数仍然总是在合约的范围内执行。
它们仍然可以调用其他合约，向它们发送以太，并销毁调用它们的合约，以及其他一些事情。
与合约内定义的函数的主要区别是，自由函数不能直接访问变量 <code class="docutils literal notranslate"><span class="pre">this</span></code>，存储变量和不在其范围内的函数。</p>
</div>
<section id="function-parameters-return-variables">
<span id="id8"></span><h4>函数参数和返回变量<a class="headerlink" href="#function-parameters-return-variables" title="此标题的永久链接"></a></h4>
<p>与许多其他语言不同, 函数接受类型化的参数作为输入，
也可以返回任意数量的值作为输出。</p>
<section id="id9">
<h5>函数参数<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h5>
<p>函数参数的声明方式与变量相同，未使用的参数名称可以省略。</p>
<p>例如，如果您想让您的合约接受一种带有两个整数的外部调用，您可以使用类似以下的方式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Simple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">taker</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>sum<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数参数可以像任何其他局部变量一样使用，它们也可以被赋值。</p>
</section>
<section id="index-8">
<span id="id10"></span><h5>返回的变量<a class="headerlink" href="#index-8" title="此标题的永久链接"></a></h5>
<p>函数的返回变量在 <code class="docutils literal notranslate"><span class="pre">returns</span></code> 关键字之后用同样的语法声明。</p>
<p>例如，假设您想返回两个结果：作为函数参数传递的两个整数的总和和乘积，那么您就使用类似的方法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Simple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">arithmetic</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">product</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>sum<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">        </span>product<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>返回变量的名字可以被省略。返回变量可以像其他本地变量一样使用，
它们被初始化为相应的 <a class="reference internal" href="index.html#default-value"><span class="std std-ref">默认值</span></a>，
并且在它们被（重新）赋值之前拥有这个值。</p>
<p>您可以明确地赋值给返回变量，然后像上面那样结束函数，
或者您可以用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句直接提供返回值（单个或 <a class="reference internal" href="#multi-return"><span class="std std-ref">多个返回值</span></a>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Simple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">arithmetic</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>pure
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">product</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">,</span><span class="w"> </span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span>b<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您过早使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 来结束一个有返回变量的函数，您必须在返回语句中同时提供返回值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>您不能从非内部函数返回某些类型。
这包括下面列出的类型和任何递归地包含它们的复合类型：</p>
<ul class="simple">
<li><p>映射，</p></li>
<li><p>内部函数类型，</p></li>
<li><p>参考类型，位置设置为 <code class="docutils literal notranslate"><span class="pre">storage</span></code>，</p></li>
<li><p>多维数组（仅适用于 <a class="reference internal" href="index.html#abi-coder"><span class="std std-ref">ABI coder v1</span></a>），</p></li>
<li><p>结构体（仅适用于 <a class="reference internal" href="index.html#abi-coder"><span class="std std-ref">ABI coder v1</span></a>）。</p></li>
</ul>
<p>这个限制不适用于库函数，因为它们有不同的 <a class="reference internal" href="#library-selectors"><span class="std std-ref">内部 ABI</span></a>。</p>
</div>
</section>
<section id="multi-return">
<span id="id11"></span><h5>返回多个值<a class="headerlink" href="#multi-return" title="此标题的永久链接"></a></h5>
<p>当一个函数有多个返回类型时，语句 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(v0,</span> <span class="pre">v1,</span> <span class="pre">...,</span> <span class="pre">vn)</span></code> 可以用来返回多个值。
声明的数量必须与返回变量的数量相同，并且它们的类型必须匹配，
有可能是经过 <a class="reference internal" href="index.html#types-conversion-elementary-types"><span class="std std-ref">隐式转换</span></a>。</p>
</section>
</section>
<section id="state-mutability">
<span id="id12"></span><h4>状态可变性<a class="headerlink" href="#state-mutability" title="此标题的永久链接"></a></h4>
<section id="view">
<span id="view-functions"></span><span id="index-9"></span><h5>View 函数<a class="headerlink" href="#view" title="此标题的永久链接"></a></h5>
<p>函数可以被声明为 <code class="docutils literal notranslate"><span class="pre">view</span></code>，在这种情况下，它们承诺不修改状态。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果编译器的EVM版本是Byzantium或更新的（默认），
当调用 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数时，会使用操作码 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，这使得状态作为EVM执行的一部分保持不被修改。
对于库合约的 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数，会使用 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>，
因为没有组合的 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> 和 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>。
这意味着库合约中的 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数没有防止状态修改的运行时的检查。
这应该不会对安全产生负面影响，因为库合约的代码通常在编译时就知道了，
而且静态检查器也会进行编译时检查。</p>
</div>
<p>以下声明被认为是修改状态：</p>
<ol class="arabic simple">
<li><p>修改状态变量。</p></li>
<li><p><a class="reference internal" href="#events"><span class="std std-ref">产生事件</span></a>。</p></li>
<li><p><a class="reference internal" href="index.html#creating-contracts"><span class="std std-ref">创建其它合约</span></a>。</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code>。</p></li>
<li><p>通过调用发送以太币。</p></li>
<li><p>调用任何没有标记为 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 的函数。</p></li>
<li><p>使用低级调用。</p></li>
<li><p>使用包含特定操作码的内联汇编。</p></li>
</ol>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>b<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">block.timestamp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>函数上的 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 曾经是 <code class="docutils literal notranslate"><span class="pre">view</span></code> 的别名，但在0.5.0版本中被取消。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Getter方法被自动标记为 <code class="docutils literal notranslate"><span class="pre">view</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.5.0版本之前，编译器没有为 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 操作码。
这使得 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数通过使用无效的显式类型转换进行状态修改。
通过对 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，在EVM层面上防止了对状态的修改。</p>
</div>
</section>
<section id="pure">
<span id="pure-functions"></span><span id="index-10"></span><h5>Pure 函数<a class="headerlink" href="#pure" title="此标题的永久链接"></a></h5>
<p>函数可以被声明为 <code class="docutils literal notranslate"><span class="pre">pure</span></code>，在这种情况下，它们承诺不读取或修改状态。
特别是，应该可以在编译时评估一个 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数，只给它的输入和 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code>，
但不知道当前区块链状态。这意味着读取 <code class="docutils literal notranslate"><span class="pre">immutable</span></code> 的变量可以是一个非标准pure的操作。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果编译器的EVM版本是Byzantium或更新的（默认），则使用操作码 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，
这并不能保证不读取状态，但至少不能修改。</p>
</div>
<p>除了上面解释的状态修改语句列表外，以下内容被认为是从状态中读取的：</p>
<ol class="arabic simple">
<li><p>读取状态变量。</p></li>
<li><p>访问 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.balance</span></code>。</p></li>
<li><p>访问 <code class="docutils literal notranslate"><span class="pre">block</span></code>， <code class="docutils literal notranslate"><span class="pre">tx</span></code>， <code class="docutils literal notranslate"><span class="pre">msg</span></code> 中任意成员 （除 <code class="docutils literal notranslate"><span class="pre">msg.sig</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code> 之外）。</p></li>
<li><p>调用任何未标记为 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 的函数。</p></li>
<li><p>使用包含某些操作码的内联汇编。</p></li>
</ol>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>b<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当一个 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">错误发生</span></a> 时，
Pure 函数能够使用 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">require()</span></code> 函数来恢复潜在的状态变化。</p>
<p>恢复一个状态变化不被认为是 &quot;状态修改&quot;，
因为只有之前在没有 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 限制的代码中对状态的改变才会被恢复，
并且该代码可以选择捕捉 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 而不传递给它。</p>
<p>这种行为也与 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 操作码一致。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在EVM层面不可能阻止函数读取状态，只可能阻止它们写入状态
（即只有 <code class="docutils literal notranslate"><span class="pre">view</span></code> 可以在EVM层面执行， <code class="docutils literal notranslate"><span class="pre">pure</span></code> 不可以）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.5.0版本之前，编译器没有为 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 操作码。
这使得在 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数中通过使用无效的显式类型转换进行状态修改。
通过对 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，在EVM层面防止了对状态的修改。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.4.17版本之前，编译器并没有强制要求 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 不读取状态。
这是一个编译时的类型检查，可以规避在合约类型之间做无效的显式转换，
因为编译器可以验证合约的类型不做改变状态的操作，
但它不能检查将在运行时被调用的合约是否真的属于该类型。</p>
</div>
</section>
</section>
<section id="special-functions">
<span id="id13"></span><h4>特殊的函数<a class="headerlink" href="#special-functions" title="此标题的永久链接"></a></h4>
<section id="receive-ether-function">
<span id="index-11"></span><span id="id14"></span><h5>接收以太的函数<a class="headerlink" href="#receive-ether-function" title="此标题的永久链接"></a></h5>
<p>一个合约最多可以有一个 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数，
使用 <code class="docutils literal notranslate"><span class="pre">receive()</span> <span class="pre">external</span> <span class="pre">payable</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 来声明。（没有  <code class="docutils literal notranslate"><span class="pre">function</span></code> 关键字）。
这个函数不能有参数，不能返回任何东西，必须具有 <code class="docutils literal notranslate"><span class="pre">external</span></code> 的可见性和 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 的状态可变性。
它可以是虚拟的，可以重载，也可以有修饰器。</p>
<p>receive 函数是在调用合约时执行的，并带有空的 calldata。
这是在纯以太传输（例如通过 <code class="docutils literal notranslate"><span class="pre">.send()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">.transfer()</span></code> ）时执行的函数。
如果不存在这样的函数，但存在一个 payable 类型的 <a class="reference internal" href="#fallback-function"><span class="std std-ref">fallback函数</span></a>，
这个fallback函数将在纯以太传输时被调用。
如果既没有直接接收以太（receive函数），也没有可接收以太的 fallback 函数，
合约就不能通过常规交易接收以太，并抛出一个异常。</p>
<p>在最坏的情况下， <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数只有2300个气体可用（例如当使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 或 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 时），
除了基本的记录外，几乎没有空间来执行其他操作。以下操作的消耗气体将超过2300气体的规定：</p>
<ul class="simple">
<li><p>写入存储</p></li>
<li><p>创建合约</p></li>
<li><p>调用消耗大量 gas 的外部函数</p></li>
<li><p>发送以太币</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>当以太被直接发送到一个合约（没有使用函数调用，即发送者使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 或 <code class="docutils literal notranslate"><span class="pre">transfer</span></code>），
但接收合约没有定义一个接收以太的函数或一个 payable 类型的 fallback 函数，会抛出一个异常，
将以太送回（这在Solidity v0.4.0之前是不同的）。因此，如果您想让您的合约接收以太，
您必须实现一个 receive 函数（不建议使用 payable 类型的 fallback 函数来接收以太，
因为它不会因为接口混乱而失败）。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>没有接收以太币功能的合约可以作为 <em>coinbase交易*（又称 *矿工区块奖励</em>）的接收者
或作为 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 的目的地接收以太币。</p>
<p>合约不能对这样的以太币转移做出反应，因此也不能拒绝它们。
这是EVM的一个设计选择，Solidity无法绕过它。</p>
<p>这也意味着 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 可以高于合约中
实现的一些手工记帐的总和（即在接收以太函数中更新的累加器）。</p>
</div>
<p>下面您可以看到一个使用 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数的Sink合约的例子。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g6L+Z5Liq5ZCI57qm5Lya5L+d55WZ5omA5pyJ5Y+R6YCB57uZ5a6D55qE5Lul5aSq5biB77yM5rKh5pyJ5Yqe5rOV6L+U6L+Y44CCCmNvbnRyYWN0IFNpbmsgewogICAgZXZlbnQgUmVjZWl2ZWQoYWRkcmVzcywgdWludCk7CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgZW1pdCBSZWNlaXZlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Sink</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Received</span><span class="p">(</span><span class="kt">address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">);</span>
<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>emit<span class="w"> </span>Received<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fallback">
<span id="fallback-function"></span><span id="index-12"></span><h5>Fallback 函数<a class="headerlink" href="#fallback" title="此标题的永久链接"></a></h5>
<p>一个合约最多可以有一个 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 函数，使用 <code class="docutils literal notranslate"><span class="pre">fallback</span> <span class="pre">()</span> <span class="pre">external</span> <span class="pre">[payable]</span></code>
或 <code class="docutils literal notranslate"><span class="pre">fallback</span> <span class="pre">(bytes</span> <span class="pre">calldata</span> <span class="pre">input)</span> <span class="pre">external</span> <span class="pre">[payable]</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory</span> <span class="pre">output)</span></code>
来声明（都没有 <code class="docutils literal notranslate"><span class="pre">function</span></code> 关键字）。
这个函数必须具有 <code class="docutils literal notranslate"><span class="pre">external</span></code> 的函数可见性。
一个 fallback 函数可以被标记为 virtual，可以标记为 override，也可以有修饰器。</p>
<p>如果其他函数都不符合给定的函数签名，或者根本没有提供数据，
也没有 <a class="reference internal" href="#receive-ether-function"><span class="std std-ref">接收以太的函数</span></a>，那么fallback函数将在调用合约时执行。
fallback函数总是接收数据，但为了同时接收以太，它必须被标记为 <code class="docutils literal notranslate"><span class="pre">payable</span></code>。</p>
<p>如果使用带参数的版本， <code class="docutils literal notranslate"><span class="pre">input</span></code>  将包含发送给合约的全部数据（等于 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code>），
并可以在 <code class="docutils literal notranslate"><span class="pre">output</span></code> 中返回数据。返回的数据将不会被ABI编码。
相反，它将在没有修改的情况下返回（甚至没有填充）。</p>
<p>在最坏的情况下，如果一个可接收以太的fallback函数也被用来代替接收功能，
那么它只有2300气体是可用的
（参见 <a class="reference internal" href="#receive-ether-function"><span class="std std-ref">接收以太函数</span></a> 对这一含义的简要描述）。</p>
<p>像任何函数一样，只要有足够的气体传递给它，fallback函数就可以执行复杂的操作。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果没有 <a class="reference internal" href="#receive-ether-function"><span class="std std-ref">receive 函数</span></a> 的存在，
一个标记为 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 的 fallback 函数也会在普通的以太传输时执行。
如果您已经定义了一个 payable 类型的 fallback 函数，
我们仍建议您也定义一个 receive 函数接收以太，以区分以太传输和接口混淆的情况。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您想对输入数据进行解码，您可以检查前四个字节的函数选择器，
然后您可以使用 <code class="docutils literal notranslate"><span class="pre">abi.decode</span></code> 与数组切片语法一起对ABI编码的数据进行解码：
<code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">d)</span> <span class="pre">=</span> <span class="pre">abi.decode(input[4:],</span> <span class="pre">(uint256,</span> <span class="pre">uint256));</span></code>
注意，这只能作为最后的手段，应该使用适当的函数来代替。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyDmiYDmnInlj5HpgIHliLDmraTlkIjnuqbnmoTmtojmga/pg73kvJrosIPnlKjmraTlh73mlbDvvIjmsqHmnInlhbbku5blh73mlbDvvInjgIIKICAgIC8vIOWQkeivpeWQiOe6puWPkemAgeS7peWkquW4geWwhuW8lei1t+W8guW4uO+8jAogICAgLy8g5Zug5Li6ZmFsbGJhY2vlh73mlbDmsqHmnIkgYHBheWFibGVgIOS/rumlsOWZqOOAggogICAgZmFsbGJhY2soKSBleHRlcm5hbCB7IHggPSAxOyB9Cn0KCmNvbnRyYWN0IFRlc3RQYXlhYmxlIHsKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIC8vIOaJgOacieWPkemAgeWIsOatpOWQiOe6pueahOa2iOaBr+mDveS8muiwg+eUqOi/meS4quWHveaVsO+8jAogICAgLy8g6Zmk5LqG5pmu6YCa55qE5Lul5aSq5Lyg6L6T77yI6Zmk5LqGcmVjZWl2ZeWHveaVsO+8jOayoeacieWFtuS7luWHveaVsO+8ieOAggogICAgLy8g5Lu75L2V5a+56K+l5ZCI57qm55qE6Z2e56m655qE6LCD55So6YO95bCG5omn6KGMZmFsbGJhY2vlh73mlbDvvIjljbPkvb/ku6XlpKrkuI7osIPnlKjkuIDotbfooqvlj5HpgIHvvInjgIIKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8g6L+Z5Liq5Ye95pWw5piv5Li657qv5Lul5aSq5Lyg6L6T6ICM6LCD55So55qE77yMCiAgICAvLyDljbPkuLrmr4/kuIDkuKrluKbmnInnqbpjYWxsZGF0YeeahOiwg+eUqOOAggogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgeyB4ID0gMjsgeSA9IG1zZy52YWx1ZTsgfQp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgZnVuY3Rpb24gY2FsbFRlc3QoVGVzdCB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMeOAggoKICAgICAgICAvLyBhZGRyZXNzKHRlc3Qp5bCG5LiN5YWB6K6455u05o6l6LCD55SoIGBgc2VuZGBg77yMCiAgICAgICAgLy8g5Zug5Li6IGBgdGVzdGBgIOayoeacieWPr+aOpeaUtuS7peWkqueahGZhbGxiYWNr5Ye95pWw44CCCiAgICAgICAgLy8g5a6D5b+F6aG76KKr6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5omN5YWB6K646LCD55SoIGBgc2VuZGBg44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIHRlc3RQYXlhYmxlID0gcGF5YWJsZShhZGRyZXNzKHRlc3QpKTsKCiAgICAgICAgLy8g5aaC5p6c5pyJ5Lq65ZCR6K+l5ZCI57qm5Y+R6YCB5Lul5aSq5biB77yM6L2s6LSm5bCG5aSx6LSl77yM5Y2z6L+Z6YeM6L+U5ZueZmFsc2XjgIIKICAgICAgICByZXR1cm4gdGVzdFBheWFibGUuc2VuZCgyIGV0aGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjYWxsVGVzdFBheWFibGUoVGVzdFBheWFibGUgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIOe7k+aenOaYryB0ZXN0Lngg562J5LqOIDHvvIx0ZXN0Lnkg562J5LqOIDDjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAxfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMe+8jHRlc3QueSDnrYnkuo4gMeOAggoKICAgICAgICAvLyDlpoLmnpzmnInkurrlkJHor6XlkIjnuqblj5HpgIHku6XlpKrluIHvvIxUZXN0UGF5YWJsZeeahHJlY2VpdmXlh73mlbDlsIbooqvosIPnlKjjgIIKICAgICAgICAvLyDnlLHkuo7or6Xlh73mlbDkvJrlhpnlhaXlrZjlgqjnqbrpl7TvvIzlroPpnIDopoHnmoTmsJTkvZPmr5TnroDljZXnmoQgYGBzZW5kYGAg5oiWIGBgdHJhbnNmZXJgYCDopoHlpJrjgIIKICAgICAgICAvLyDnlLHkuo7ov5nkuKrljp/lm6DvvIzmiJHku6zlv4XpobvopoHkvb/nlKjkuIDkuKrkvY7nuqfliKvnmoTosIPnlKjjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyDnu5PmnpzmmK8gdGVzdC54IOetieS6jiAx77yMdGVzdC55IOetieS6jiAyIOS4quS7peWkquOAggoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 所有发送到此合约的消息都会调用此函数（没有其他函数）。</span>
<span class="w">    </span><span class="c1">// 向该合约发送以太币将引起异常，</span>
<span class="w">    </span><span class="c1">// 因为fallback函数没有 `payable` 修饰器。</span>
<span class="w">    </span>fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">TestPayable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 所有发送到此合约的消息都会调用这个函数，</span>
<span class="w">    </span><span class="c1">// 除了普通的以太传输（除了receive函数，没有其他函数）。</span>
<span class="w">    </span><span class="c1">// 任何对该合约的非空的调用都将执行fallback函数（即使以太与调用一起被发送）。</span>
<span class="w">    </span>fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 这个函数是为纯以太传输而调用的，</span>
<span class="w">    </span><span class="c1">// 即为每一个带有空calldata的调用。</span>
<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Caller</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callTest</span><span class="p">(</span>Test<span class="w"> </span>test<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;nonExistingFunction()&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1。</span>

<span class="w">        </span><span class="c1">// address(test)将不允许直接调用 ``send``，</span>
<span class="w">        </span><span class="c1">// 因为 ``test`` 没有可接收以太的fallback函数。</span>
<span class="w">        </span><span class="c1">// 它必须被转换为 ``address payable`` 类型，才允许调用 ``send``。</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>testPayable<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span>test<span class="p">));</span>

<span class="w">        </span><span class="c1">// 如果有人向该合约发送以太币，转账将失败，即这里返回false。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>testPayable<span class="p">.</span>send<span class="p">(</span><span class="m m-Decimal">2</span><span class="w"> </span>ether<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callTestPayable</span><span class="p">(</span>TestPayable<span class="w"> </span>test<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;nonExistingFunction()&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1，test.y 等于 0。</span>
<span class="w">        </span><span class="p">(</span>success<span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">{</span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;nonExistingFunction()&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1，test.y 等于 1。</span>

<span class="w">        </span><span class="c1">// 如果有人向该合约发送以太币，TestPayable的receive函数将被调用。</span>
<span class="w">        </span><span class="c1">// 由于该函数会写入存储空间，它需要的气体比简单的 ``send`` 或 ``transfer`` 要多。</span>
<span class="w">        </span><span class="c1">// 由于这个原因，我们必须要使用一个低级别的调用。</span>
<span class="w">        </span><span class="p">(</span>success<span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">{</span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span>ether<span class="p">}(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1，test.y 等于 2 个以太。</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="overload-function">
<span id="index-13"></span><span id="id15"></span><h4>函数重载<a class="headerlink" href="#overload-function" title="此标题的永久链接"></a></h4>
<p>一个合约可以有多个同名的，但参数类型不同的函数。
这个过程被称为 &quot;重载&quot;，也适用于继承的函数。
下面的例子显示了在合约 <code class="docutils literal notranslate"><span class="pre">A</span></code> 范围内对函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的重载。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">really</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>really<span class="p">)</span>
<span class="w">            </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIOi/meauteS7o+eggeS4jeS8mue8luivkQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiB2YWx1ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoQiBvdXQpIHsKICAgICAgICBvdXQgPSB2YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBmKGFkZHJlc3MgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 这段代码不会编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span>B<span class="w"> </span>value<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>B<span class="w"> </span>out<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以上两个 <code class="docutils literal notranslate"><span class="pre">f</span></code> 函数重载最终都接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p>
<section id="id16">
<h5>重载解析和参数匹配<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h5>
<p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。
如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。
如果一个候选都没有，解析失败。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>返回参数不作为重载解析的依据。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>val<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>val<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>调用 <code class="docutils literal notranslate"><span class="pre">f(50)</span></code> 会导致类型错误，因为 <code class="docutils literal notranslate"><span class="pre">50</span></code> 既可以被隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>
也可以被隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>。 另一方面，调用 <code class="docutils literal notranslate"><span class="pre">f(256)</span></code> 则会解析为 <code class="docutils literal notranslate"><span class="pre">f(uint256)</span></code> 重载，
因为 <code class="docutils literal notranslate"><span class="pre">256</span></code> 不能隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>。</p>
</section>
</section>
</section>
<section id="events">
<span id="index-14"></span><span id="id17"></span><h3>事件<a class="headerlink" href="#events" title="此标题的永久链接"></a></h3>
<p>Solidity事件在EVM的日志功能之上给出了一个抽象。
应用程序可以通过Ethereum客户端的RPC接口订阅和监听这些事件。</p>
<p>事件是合约的可继承成员。当您调用它们时，
它们会导致参数被存储在交易的日志中--区块链中的一个特殊数据结构。
这些日志与合约的地址相关联，被纳入区块链，
只要有区块可以访问，就会留在那里（目前是永远，但这可能会随着Serenity升级而改变）。
日志及其事件数据不能从合约内部访问（甚至不能从创建它们的合约访问）。</p>
<p>有可能要求为日志提供Merkle证明，
所以如果外部实体向合约提供这样的证明，它可以检查日志是否真的存在于区块链中。
由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。</p>
<p>您可以最多给三个参数添加 <code class="docutils literal notranslate"><span class="pre">indexed</span></code> 属性，将它们添加到一个特殊的数据结构中，
称为 <a class="reference internal" href="index.html#abi-events"><span class="std std-ref">&quot;topics&quot;</span></a>，而不是日志的数据部分。
一个topic只能容纳一个字（32字节），所以如果您为一个索引参数使用 <a class="reference internal" href="index.html#reference-types"><span class="std std-ref">引用类型</span></a>，
该值的Keccak-256哈希值将被存储为一个topic中。</p>
<p>所有没有 <code class="docutils literal notranslate"><span class="pre">indexed</span></code> 属性的参数都会被 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI 编码</span></a> 到日志的数据部分。</p>
<p>Topics允许您用来搜索事件，例如为特定的事件来过滤一系列的区块。
您用来也可以通过发出事件的合约的地址来过滤事件。</p>
<p>例如，下面的代码使用web3.js <code class="docutils literal notranslate"><span class="pre">subscribe(&quot;logs&quot;)</span></code>
<a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs">方法</a>
来过滤与某一地址值相匹配的日志：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fromBlock</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">    </span><span class="nx">address</span><span class="o">:</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">defaultAccount</span><span class="p">,</span>
<span class="w">    </span><span class="nx">topics</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">]</span>
<span class="p">};</span>
<span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">&#39;logs&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">log</span><span class="p">);</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;changed&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="p">});</span>
</pre></div>
</div>
<p>除非您用 <code class="docutils literal notranslate"><span class="pre">anonymous</span></code> 指定符声明事件，否则事件的签名的哈希值是topic之一。
这意味着不可能通过名字来过滤特定的匿名事件，
您只能通过合约地址来过滤。匿名事件的优点是，它们的部署和调用都比较便宜。
它还允许您声明四个索引参数，而不是三个。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于交易日志只存储事件数据而不存储类型，因此您必须知道事件的类型，
包括哪个参数被索引以及事件是否是匿名的，以便正确解析数据。
特别的是，有可能用一个匿名事件 “伪造“ 另一个事件的签名。</p>
</div>
<section id="index-15">
<span id="id19"></span><h4>事件类型的成员方法<a class="headerlink" href="#index-15" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">event.selector</span></code>： 对于非匿名事件，这是一个 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 值，
包含事件签名的 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 哈希值，在默认topic中使用。</p></li>
</ul>
</section>
<section id="id20">
<h4>示例<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h4>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyDkuovku7bmmK/nlKggYGVtaXRgIOWPkeWHuueahO+8jOWQjumdouaYr+S6i+S7tueahOWQjeensOWSjOaLrOWPt+mHjOeahOWPguaVsO+8iOWmguaenOacie+8ieOAggogICAgICAgIC8vIOS7u+S9lei/meagt+eahOiwg+eUqO+8iOeUmuiHs+aYr+a3seW6puW1jOWll++8iemDveWPr+S7pemAmui/h+i/h+a7pCBgRGVwb3NpdGAKICAgICAgICAvLyDku45KYXZhU2NyaXB0IEFQSeS4reajgOa1i+WHuuadpeOAggogICAgICAgIGVtaXQgRGVwb3NpdChtc2cuc2VuZGVyLCBpZCwgbXNnLnZhbHVlKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.21</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">ClientReceipt</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Deposit</span><span class="p">(</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>from<span class="p">,</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>id<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">deposit</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">id</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 事件是用 `emit` 发出的，后面是事件的名称和括号里的参数（如果有）。</span>
<span class="w">        </span><span class="c1">// 任何这样的调用（甚至是深度嵌套）都可以通过过滤 `Deposit`</span>
<span class="w">        </span><span class="c1">// 从JavaScript API中检测出来。</span>
<span class="w">        </span>emit<span class="w"> </span>Deposit<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>id<span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在JavaScript API中的使用方式如下：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">abi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* 由编译器产生的abi */</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">ClientReceipt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">contract</span><span class="p">(</span><span class="nx">abi</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">clientReceipt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ClientReceipt</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="s2">&quot;0x1234...ab67&quot;</span><span class="w"> </span><span class="cm">/* 地址 */</span><span class="p">);</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">depositEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">clientReceipt</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">();</span>

<span class="c1">// 监视变化</span>
<span class="nx">depositEvent</span><span class="p">.</span><span class="nx">watch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// 结果包含非索引的参数和给 `Deposit` 调用的 topics。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>


<span class="c1">// 或者通过回调立即开始监视</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">depositEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">clientReceipt</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>上面的输出看起来像下面这样（经过修剪）:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">   </span><span class="nt">&quot;returnValues&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="nt">&quot;from&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x1111…FFFFCCCC&quot;</span><span class="p">,</span>
<span class="w">       </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x50…sd5adb20&quot;</span><span class="p">,</span>
<span class="w">       </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x420042&quot;</span>
<span class="w">   </span><span class="p">},</span>
<span class="w">   </span><span class="nt">&quot;raw&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="nt">&quot;data&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x7f…91385&quot;</span><span class="p">,</span>
<span class="w">       </span><span class="nt">&quot;topics&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;0xfd4…b4ead7&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;0x7f…1a91385&quot;</span><span class="p">]</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id21">
<h4>了解事件类型的其他资料<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/ethereum/web3.js/blob/1.x/docs/web3-eth-contract.rst#events">Javascript 文档</a></p></li>
<li><p><a class="reference external" href="https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件的使用实例</a></p></li>
<li><p><a class="reference external" href="https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js">如何在js中访问它们</a></p></li>
</ul>
</section>
</section>
<section id="errors">
<span id="index-16"></span><span id="id23"></span><h3>错误和恢复语句<a class="headerlink" href="#errors" title="此标题的永久链接"></a></h3>
<p>Solidity 中的错误提供了一种方便且省gas的方式来向用户解释为什么一个操作会失败。
它们可以被定义在合约内部和外部（包括接口合约和库合约）。</p>
<p>它们必须与 <a class="reference internal" href="index.html#revert-statement"><span class="std std-ref">恢复语句</span></a> 一起使用，
它导致当前调用中的所有变化被恢复，并将错误数据传回给调用者。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDovazotKbnmoTkvZnpop3kuI3otrPjgILpnIDopoEgYHJlcXVpcmVkYCDmlbDph4/kvYblj6rmnIkgYGF2YWlsYWJsZWAg5pWw6YeP5Y+v55So44CCCi8vLyBAcGFyYW0g5Y+v55So55qE5L2Z6aKd44CCCi8vLyBAcGFyYW0g6ZyA6KaB6KaB5rGC55qE6L2s5biQ6YeR6aKd44CCCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="c1">/// 转账的余额不足。需要 `required` 数量但只有 `available` 数量可用。</span>
<span class="c1">/// @param 可用的余额。</span>
<span class="c1">/// @param 需要要求的转帐金额。</span>
error<span class="w"> </span>InsufficientBalance<span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">available</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">required</span><span class="p">);</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">TestToken</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>balance<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>amount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>balance<span class="p">[</span><span class="k">msg.sender</span><span class="p">])</span>
<span class="w">            </span>revert<span class="w"> </span>InsufficientBalance<span class="p">({</span>
<span class="w">                </span>available<span class="o">:</span><span class="w"> </span>balance<span class="p">[</span><span class="k">msg.sender</span><span class="p">],</span>
<span class="w">                </span>required<span class="o">:</span><span class="w"> </span>amount
<span class="w">            </span><span class="p">});</span>
<span class="w">        </span>balance<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">        </span>balance<span class="p">[</span>to<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误不能被重载或覆盖，但是可以被继承。
只要作用域不同，同一个错误可以在多个地方定义。
错误的实例只能使用 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 语句创建。</p>
<p>错误会创建数据，然后通过还原操作传递给调用者，
使其返回到链下组件或在 <a class="reference internal" href="index.html#try-catch"><span class="std std-ref">try/catch 语句</span></a> 中捕获它。
需要注意的是，一个错误只能在来自外部调用时被捕获，
发生在内部调用或同一函数内的还原不能被捕获。</p>
<p>如果您不提供任何参数，错误只需要四个字节的数据，
您可以像上面一样使用 <a class="reference internal" href="index.html#natspec"><span class="std std-ref">NatSpec 语法</span></a> 来进一步解释错误背后的原因，
这并不存储在链上。这使得这同时也是一个非常便宜和方便的错误报告功能。</p>
<p>更具体地说，一个错误实例在被ABI编码时，
其方式与对相同名称和类型的函数的调用相同，
然后作为 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 操作码的返回数据。
这意味着数据由一个4字节的选择器和 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI编码</span></a> 数据组成。
选择器由错误类型的签名的keccak256-hash的前四个字节组成。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>一个合约有可能因为同名的不同错误而恢复，
甚至因为在不同地方定义的错误而使调用者无法区分。
对于外部来说，即ABI，只有错误的名称是相关的，而不是定义它的合约或文件。</p>
</div>
<p>如果您能定义 <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">Error(string)</span></code>，
那么语句 <code class="docutils literal notranslate"><span class="pre">require(condition,</span> <span class="pre">&quot;description&quot;);</span></code>
将等同于 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(!condition)</span> <span class="pre">revert</span> <span class="pre">Error(&quot;description&quot;)</span></code>。
但是请注意， <code class="docutils literal notranslate"><span class="pre">Error</span></code> 是一个内置类型，不能在用户提供的代码中定义。</p>
<p>同样，一个失败的 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 或类似的条件将以一个内置的 <code class="docutils literal notranslate"><span class="pre">Panic(uint256)</span></code> 类型的错误来恢复。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>错误数据应该只被用来指示失败，而不是作为控制流的手段。
原因是内部调用的恢复数据默认是通过外部调用链传播回来的。
这意味着内部调用可以 ”伪造” 恢复数据，使它看起来像是来自调用它的合约。</p>
</div>
<section id="id24">
<h4>错误类型的成员<a class="headerlink" href="#id24" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">error.selector</span></code>： 一个包含错误类型的选择器的 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 值。</p></li>
</ul>
</section>
</section>
<section id="index-17">
<span id="id25"></span><h3>继承<a class="headerlink" href="#index-17" title="此标题的永久链接"></a></h3>
<p>Solidity支持多重继承，包括多态性。</p>
<p>多态性意味着函数调用（内部和外部）总是执行继承层次结构中最新继承的合约中的同名函数（和参数类型）。
但必须使用 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 和 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字在层次结构中的每个函数上明确启用。
参见 <a class="reference internal" href="#function-overriding"><span class="std std-ref">函数重载</span></a> 以了解更多细节。</p>
<p>通过使用 <code class="docutils literal notranslate"><span class="pre">ContractName.functionName()</span></code> 明确指定合约，
可以在内部调用继承层次结构中更高的函数。
或者如果您想在扁平化的继承层次中调用高一级的函数（见下文），
可以使用 <code class="docutils literal notranslate"><span class="pre">super.functionName()</span></code>。</p>
<p>当一个合约继承自其他合约时，在区块链上只创建一个单一的合约，
所有基础合约的代码被编译到创建的合约中。
这意味着对基础合约的所有内部函数的调用也只是使用内部函数调用
（ <code class="docutils literal notranslate"><span class="pre">super.f(..)</span></code> 将使用 JUMP 而不是消息调用）。</p>
<p>状态变量的阴影被认为是一个错误。
一个派生合约只能声明一个状态变量 <code class="docutils literal notranslate"><span class="pre">x</span></code>，
如果在它的任何基类中没有相同名称的可见状态变量。</p>
<p>总的来说，Solidity 的继承系统与 <a class="reference external" href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python的继承系统</a>
非常相似，特别是关于多重继承方面，但也有一些 <a class="reference internal" href="#multi-inheritance"><span class="std std-ref">不同之处</span></a>。</p>
<p>详细情况见下面的例子。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIOS9v+eUqCBgaXNgIOS7juWPpuS4gOS4quWQiOe6pua0vueUn+OAgua0vueUn+WQiOe6puWPr+S7peiuv+mXruaJgOaciemdnuengeacieaIkOWRmO+8jAovLyDljIXmi6zlhoXpg6jlh73mlbDlkoznirbmgIHlj5jph4/vvIzkvYbml6Dms5XpgJrov4cgYHRoaXNgIOadpeWklumDqOiuv+mXruOAggpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgT3duZWQgewogICAgLy8g5YWz6ZSu5a2XIGB2aXJ0dWFsYCDmhI/lkbPnnYDor6Xlh73mlbDlj6/ku6XlnKjmtL7nlJ/nsbvkuK3mlLnlj5jlhbbooYzkuLrvvIgi6YeN6L29Iu+8ieOAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKCi8vIOi/meS6m+aKveixoeWQiOe6puS7heeUqOS6jue7mee8luivkeWZqOaPkOS+m+aOpeWPo+OAggovLyDms6jmhI/lh73mlbDmsqHmnInlh73mlbDkvZPjgIIKLy8g5aaC5p6c5LiA5Liq5ZCI57qm5rKh5pyJ5a6e546w5omA5pyJ5Ye95pWw77yM5YiZ5Y+q6IO955So5L2c5o6l5Y+j44CCCmFic3RyYWN0IGNvbnRyYWN0IENvbmZpZyB7CiAgICBmdW5jdGlvbiBsb29rdXAodWludCBpZCkgcHVibGljIHZpcnR1YWwgcmV0dXJucyAoYWRkcmVzcyBhZHIpOwp9CgoKYWJzdHJhY3QgY29udHJhY3QgTmFtZVJlZyB7CiAgICBmdW5jdGlvbiByZWdpc3RlcihieXRlczMyIG5hbWUpIHB1YmxpYyB2aXJ0dWFsOwogICAgZnVuY3Rpb24gdW5yZWdpc3RlcigpIHB1YmxpYyB2aXJ0dWFsOwp9CgoKLy8g5aSa6YeN57un5om/5piv5Y+v6IO955qE44CC6K+35rOo5oSP77yMIGBPd25lZGAg5Lmf5pivIGBEZXN0cnVjdGlibGVgIOeahOWfuuexu++8jAovLyDkvYblj6rmnInkuIDkuKogYE93bmVkYCDlrp7kvovvvIjlsLHlg48gQysrIOS4reeahOiZmuaLn+e7p+aJv++8ieOAggpjb250cmFjdCBOYW1lZCBpcyBPd25lZCwgRGVzdHJ1Y3RpYmxlIHsKICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZSkgewogICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICBOYW1lUmVnKGNvbmZpZy5sb29rdXAoMSkpLnJlZ2lzdGVyKG5hbWUpOwogICAgfQoKICAgIC8vIOWHveaVsOWPr+S7peiiq+WPpuS4gOS4quWFt+acieebuOWQjOWQjeensOWSjOebuOWQjOaVsOmHjy/nsbvlnovovpPlhaXnmoTlh73mlbDph43ovb3jgIIKICAgIC8vIOWmguaenOmHjei9veWHveaVsOacieS4jeWQjOexu+Wei+eahOi+k+WHuuWPguaVsO+8jOS8muWvvOiHtOmUmeivr+OAggogICAgLy8g5pys5Zyw5ZKM5Z+65LqO5raI5oGv55qE5Ye95pWw6LCD55So6YO95Lya6ICD6JmR6L+Z5Lqb6YeN6L2944CCCiAgICAvLyDlpoLmnpzmgqjmg7Pph43ovb3ov5nkuKrlh73mlbDvvIzmgqjpnIDopoHkvb/nlKggYG92ZXJyaWRlYCDlhbPplK7lrZfjgIIKICAgIC8vIOWmguaenOaCqOaDs+iuqei/meS4quWHveaVsOWGjeasoeiiq+mHjei9ve+8jOaCqOmcgOimgeWGjeaMh+WumiBgdmlydHVhbGAg5YWz6ZSu5a2X44CCCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKSB7CiAgICAgICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS51bnJlZ2lzdGVyKCk7CiAgICAgICAgICAgIC8vIOS7jeeEtuWPr+S7peiwg+eUqOeJueWumueahOmHjei9veWHveaVsOOAggogICAgICAgICAgICBEZXN0cnVjdGlibGUuZGVzdHJveSgpOwogICAgICAgIH0KICAgIH0KfQoKCi8vIOWmguaenOaehOmAoOWHveaVsOaOpeWPl+WPguaVsO+8jAovLyDliJnpnIDopoHlnKjlo7DmmI7vvIjlkIjnuqbnmoTmnoTpgKDlh73mlbDvvInml7bmj5DkvpvvvIwKLy8g5oiW5Zyo5rS+55Sf5ZCI57qm55qE5p6E6YCg5Ye95pWw5L2N572u5Lul5L+u6aWw5Zmo6LCD55So6aOO5qC85o+Q5L6b77yI6KeB5LiL5paH77yJ44CCCmNvbnRyYWN0IFByaWNlRmVlZCBpcyBPd25lZCwgRGVzdHJ1Y3RpYmxlLCBOYW1lZCgiR29sZEZlZWQiKSB7CiAgICBmdW5jdGlvbiB1cGRhdGVJbmZvKHVpbnQgbmV3SW5mbykgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgaW5mbyA9IG5ld0luZm87CiAgICB9CgogICAgLy8g5Zyo6L+Z6YeM77yM5oiR5Lus5Y+q5oyH5a6a5LqGIGBvdmVycmlkZWAg6ICM5rKh5pyJIGB2aXJ0dWFsYOOAggogICAgLy8g6L+Z5oSP5ZGz552A5LuOIGBQcmljZUZlZWRgIOa0vueUn+WHuuadpeeahOWQiOe6puS4jeiDveWGjeaUueWPmCBgZGVzdHJveWAg55qE6KGM5Li644CCCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIG92ZXJyaWRlKERlc3RydWN0aWJsZSwgTmFtZWQpIHsgTmFtZWQuZGVzdHJveSgpOyB9CiAgICBmdW5jdGlvbiBnZXQoKSBwdWJsaWMgdmlldyByZXR1cm5zKHVpbnQgcikgeyByZXR1cm4gaW5mbzsgfQoKICAgIHVpbnQgaW5mbzsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Owned</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 使用 `is` 从另一个合约派生。派生合约可以访问所有非私有成员，</span>
<span class="c1">// 包括内部函数和状态变量，但无法通过 `this` 来外部访问。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 关键字 `virtual` 意味着该函数可以在派生类中改变其行为（&quot;重载&quot;）。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// 这些抽象合约仅用于给编译器提供接口。</span>
<span class="c1">// 注意函数没有函数体。</span>
<span class="c1">// 如果一个合约没有实现所有函数，则只能用作接口。</span>
abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Config</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">lookup</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">id</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">adr</span><span class="p">);</span>
<span class="p">}</span>


abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">NameReg</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">unregister</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 多重继承是可能的。请注意， `Owned` 也是 `Destructible` 的基类，</span>
<span class="c1">// 但只有一个 `Owned` 实例（就像 C++ 中的虚拟继承）。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Named</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="p">,</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>Config<span class="w"> </span>config<span class="w"> </span><span class="o">=</span><span class="w"> </span>Config<span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span>
<span class="w">        </span>NameReg<span class="p">(</span>config<span class="p">.</span>lookup<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)).</span>register<span class="p">(</span>name<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。</span>
<span class="w">    </span><span class="c1">// 如果重载函数有不同类型的输出参数，会导致错误。</span>
<span class="w">    </span><span class="c1">// 本地和基于消息的函数调用都会考虑这些重载。</span>
<span class="w">    </span><span class="c1">// 如果您想重载这个函数，您需要使用 `override` 关键字。</span>
<span class="w">    </span><span class="c1">// 如果您想让这个函数再次被重载，您需要再指定 `virtual` 关键字。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>Config<span class="w"> </span>config<span class="w"> </span><span class="o">=</span><span class="w"> </span>Config<span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span>
<span class="w">            </span>NameReg<span class="p">(</span>config<span class="p">.</span>lookup<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)).</span>unregister<span class="p">();</span>
<span class="w">            </span><span class="c1">// 仍然可以调用特定的重载函数。</span>
<span class="w">            </span>Destructible<span class="p">.</span>destroy<span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// 如果构造函数接受参数，</span>
<span class="c1">// 则需要在声明（合约的构造函数）时提供，</span>
<span class="c1">// 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">PriceFeed</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="p">,</span><span class="w"> </span>Destructible<span class="p">,</span><span class="w"> </span>Named<span class="p">(</span><span class="s2">&quot;GoldFeed&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">updateInfo</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newInfo</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>info<span class="w"> </span><span class="o">=</span><span class="w"> </span>newInfo<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 在这里，我们只指定了 `override` 而没有 `virtual`。</span>
<span class="w">    </span><span class="c1">// 这意味着从 `PriceFeed` 派生出来的合约不能再改变 `destroy` 的行为。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Destructible<span class="p">,</span><span class="w"> </span>Named<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Named<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">get</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>info<span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">info</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，在上面，我们调用 <code class="docutils literal notranslate"><span class="pre">Destructible.destroy()</span></code> 来 &quot;转发&quot; 销毁请求。
这样做的方式是有问题的，从下面的例子中可以看出：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgRmluYWwgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7IEJhc2UyLmRlc3Ryb3koKTsgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 1 */</span><span class="w"> </span>Destructible<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 2 */</span><span class="w"> </span>Destructible<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Final</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Base2<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>调用 <code class="docutils literal notranslate"><span class="pre">Final.destroy()</span></code> 时会调用最后的派生重载函数 <code class="docutils literal notranslate"><span class="pre">Base2.destroy</span></code>，
但是会绕过 <code class="docutils literal notranslate"><span class="pre">Base1.destroy</span></code>， 解决这个问题的方法是使用 <code class="docutils literal notranslate"><span class="pre">super</span></code>：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgc3VwZXIuZGVzdHJveSgpOyB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 1 */</span><span class="w"> </span>super<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 2 */</span><span class="w"> </span>super<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Final</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>super<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">Base2</span></code> 调用 <code class="docutils literal notranslate"><span class="pre">super</span></code> 的函数，它不会简单在其基类合约上调用该函数。
相反，它在最终的继承关系图谱的上一个基类合约中调用这个函数，
所以它会调用 <code class="docutils literal notranslate"><span class="pre">Base1.destroy()</span></code>
（注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, Destructible, ownerd）。
在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。
这与普通的虚拟方法查找类似。</p>
<section id="function-overriding">
<span id="index-18"></span><span id="id26"></span><h4>函数重载<a class="headerlink" href="#function-overriding" title="此标题的永久链接"></a></h4>
<p>如果基函数被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>，则可以通过继承合约来改变其行为。
被重载的函数必须在函数头中使用 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字。
重载函数只能将被重载函数的可见性从 <code class="docutils literal notranslate"><span class="pre">external</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">public</span></code>。
可变性可以按照以下顺序改变为更严格的可变性。
<code class="docutils literal notranslate"><span class="pre">nonpayable</span></code> 可以被 <code class="docutils literal notranslate"><span class="pre">view</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 重载。
<code class="docutils literal notranslate"><span class="pre">view</span></code> 可以被 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 重写。 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 是一个例外，不能被改变为任何其他可变性。</p>
<p>下面的例子演示了改变函数可变性和可见性：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Middle</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="w"> </span><span class="p">{}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Middle
<span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>override<span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于多重继承，必须在 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字后明确指定定义同一函数的最多派生基类合约。
换句话说，您必须指定所有定义同一函数的基类合约，
并且还没有被另一个基类合约重载（在继承图的某个路径上）。
此外，如果一个合约从多个（不相关的）基类合约上继承了同一个函数，必须明确地重载它。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyDmtL7nlJ/oh6rlpJrkuKrlrprkuYkgZm9vKCkg5Ye95pWw55qE5Z+657G75ZCI57qm77yMCiAgICAvLyDmiYDku6XmiJHku6zlv4XpobvmmI7noa7lnLDph43ovb3lroMKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 派生自多个定义 foo() 函数的基类合约，</span>
<span class="w">    </span><span class="c1">// 所以我们必须明确地重载它</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果函数被定义在一个共同的基类合约中，
或者在一个共同的基类合约中有一个独特的函数已经重载了所有其他的函数，
则不需要明确的函数重载指定符。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyDml6DpnIDmmI7noa7nmoTph43ovb0KY29udHJhY3QgRCBpcyBCLCBDIHt9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="p">{}</span><span class="w"> </span><span class="p">}</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{}</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{}</span>
<span class="c1">// 无需明确的重载</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>B<span class="p">,</span><span class="w"> </span>C<span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>更准确地说，如果有一个基类合约是该签名的所有重载路径的一部分，
并且（1）该基类合约实现了该函数，并且从当前合约到该基类合约的任何路径都没有提到具有该签名的函数，
或者（2）该基类合约没有实现该函数，并且从当前合约到该基类合约的所有路径中最多只有一个提到该函数，
那么就不需要重载从多个基类合约继承的函数（直接或间接）。</p>
<p>在这个意义上，一个签名的重载路径是一条继承图的路径，
它从所考虑的合约开始，到提到具有该签名的函数的合约结束，
而该签名没有重载。</p>
<p>如果您不把一个重载的函数标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>，派生合约就不能再改变该函数的行为。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>具有 <code class="docutils literal notranslate"><span class="pre">private</span></code> 可见性的函数不能是 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在接口合约之外，没有实现的函数必须被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。
在接口合约中，所有的函数都被自动视为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>从Solidity 0.8.8开始，当重载一个接口函数时，
不需要 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字，除非该函数被定义在多个基础上。</p>
</div>
<p>如果函数的参数和返回类型与变量的getter函数匹配，公共状态变量可以重载为外部函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">override</span><span class="w"> </span>f<span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>虽然公共状态变量可以重载外部函数，但它们本身不能被重载。</p>
</div>
</section>
<section id="modifier-overriding">
<span id="index-19"></span><span id="id27"></span><h4>修饰器重载<a class="headerlink" href="#modifier-overriding" title="此标题的永久链接"></a></h4>
<p>函数修改器可以相互重载。
这与 <a class="reference internal" href="#function-overriding"><span class="std std-ref">函数重载</span></a> 的工作方式相同（除了对修改器没有重载）。
<code class="docutils literal notranslate"><span class="pre">virtual</span></code> 关键字必须用在被重载的修改器上， <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字必须用在重载的修改器上：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base
<span class="p">{</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>override<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在多重继承的情况下，必须明确指定所有的直接基类合约。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2
<span class="p">{</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{</span>_<span class="p">;}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="constructor">
<span id="index-20"></span><span id="id28"></span><h4>构造函数<a class="headerlink" href="#constructor" title="此标题的永久链接"></a></h4>
<p>构造函数是一个用 <code class="docutils literal notranslate"><span class="pre">constructor</span></code> 关键字声明的可选函数，
它在合约创建时被执行，您可以在这里运行合约初始化代码。</p>
<p>在构造函数代码执行之前，如果您用内联编程的方式初始化状态变量，则将其初始化为指定的值；
如果您不用内联编程的方式来初始化，则将其初始化为 <a class="reference internal" href="index.html#default-value"><span class="std std-ref">默认值</span></a>。</p>
<p>构造函数运行后，合约的最终代码被部署到区块链上。
部署代码的gas花费与代码长度成线性关系。
这段代码包括属于公共接口的所有函数，以及所有通过函数调用可以到达的函数。
但不包括构造函数代码或只从构造函数中调用的内部函数。</p>
<p>如果没有构造函数，合约将假定默认的构造函数，
相当于 <code class="docutils literal notranslate"><span class="pre">constructor()</span> <span class="pre">{}</span></code>。比如说：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">a</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>a_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您可以在构造函数中使用内部参数（例如，存储指针）。
在这种情况下，合约必须被标记为 <a class="reference internal" href="#abstract-contract"><span class="std std-ref">abstract</span></a>，
因为这些参数不能从外部分配有效的值，只能通过派生合约的构造函数来赋值。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在0.4.22版本之前，构造函数被定义为与合约同名的函数。
这种语法已被废弃，在0.5.0版本中不再允许。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在0.7.0版本之前，您必须指定构造函数的可见性为 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 或 <code class="docutils literal notranslate"><span class="pre">public</span></code>。</p>
</div>
</section>
<section id="index-21">
<span id="id29"></span><h4>基本构造函数的参数<a class="headerlink" href="#index-21" title="此标题的永久链接"></a></h4>
<p>所有基类合约的构造函数将按照下面解释的线性化规则被调用。
如果基类合约构造函数有参数，派生合约需要指定所有的参数。
这可以通过两种方式实现：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyDopoHkuYjnm7TmjqXlnKjnu6fmib/liJfooajkuK3mjIflrpouLi4KY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZSg3KSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaIluiAhemAmui/h+a0vueUn+aehOmAoOWHveaVsOeahOS4gOS4qiAi5L+u5pS55ZmoIuKApuKApgpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgeSkgQmFzZSh5ICogeSkge30KfQoKLy8g5oiW6ICF5bCG5ZCI57qm5aOw5piO5Li6YWJzdHJhY3TnsbvlnovigKbigKYKYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIOW5tuiuqeS4i+S4gOS4quWFt+S9k+eahOa0vueUn+WQiOe6puWvueWFtui/m+ihjOWIneWni+WMluOAggpjb250cmFjdCBEZXJpdmVkRnJvbURlcml2ZWQgaXMgRGVyaXZlZDMgewogICAgY29uc3RydWN0b3IoKSBCYXNlKDEwICsgMTApIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>x_<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 要么直接在继承列表中指定...</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 或者通过派生构造函数的一个 &quot;修改器&quot;……</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span>Base<span class="p">(</span>y<span class="w"> </span><span class="o">*</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 或者将合约声明为abstract类型……</span>
abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Derived3</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="w"> </span><span class="p">{</span>
<span class="p">}</span>

<span class="c1">// 并让下一个具体的派生合约对其进行初始化。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">DerivedFromDerived</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Derived3<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base<span class="p">(</span><span class="m m-Decimal">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一种方式是直接在继承列表中给出（ <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">Base(7)</span></code> ）。
另一种是通过修改器作为派生构造函数的一部分被调用的方式（ <code class="docutils literal notranslate"><span class="pre">Base(_y</span> <span class="pre">*</span> <span class="pre">_y)</span></code> ）。
如果构造函数参数是一个常量，并且定义了合约的行为或描述了它，那么第一种方式更方便。
如果基类合约的构造函数参数依赖于派生合约的参数，则必须使用第二种方式。
参数必须在继承列表中或在派生构造函数中以修饰器的形式给出。
在两个地方都指定参数是一个错误。</p>
<p>如果一个派生合约没有指定其所有基类合约的构造函数的参数，那么它必须被声明为 abstract 类型。在这种情况下，
当另一个合约从它派生时，其他合约的继承列表或构造函数必须为所有没有指定参数的基类合约提供必要的参数
（否则，其他合约也必须被声明为 abstract 类型）。例如，在上面的代码片段中，
可以查看合约 <code class="docutils literal notranslate"><span class="pre">Derived3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">DerivedFromDerived</span></code>。</p>
</section>
<section id="multi-inheritance">
<span id="index-22"></span><span id="id30"></span><h4>多重继承与线性化<a class="headerlink" href="#multi-inheritance" title="此标题的永久链接"></a></h4>
<p>编程语言实现多重继承需要解决几个问题。
一个问题是 <a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题</a> 。
Solidity 借鉴了 Python 的方式并且使用 &quot;<a class="reference external" href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a>&quot;
强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。
这最终实现我们所希望的唯一化的结果，但也使某些继承方式变为无效。
尤其是，基类在 <code class="docutils literal notranslate"><span class="pre">is</span></code> 后面的顺序很重要。 在下面的代码中，
您必须按照从 “最接近的基类”（most base-like）到 “最远的继承”（most derived）的顺序来指定所有的基类。
注意，这个顺序与Python中使用的顺序相反。</p>
<p>另一种简化的解释方式是，当一个函数被调用时，
它在不同的合约中被多次定义，给定的基类以深度优先的方式从右到左（Python中从左到右）进行搜索，
在第一个匹配处停止。如果一个基类合约已经被搜索过了，它就被跳过。</p>
<p>在下面的代码中，Solidity 会给出 “Linearization of inheritance graph impossible” 这样的错误。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8g6L+Z5q615Luj56CB5LiN5Lya57yW6K+RCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">X</span><span class="w"> </span><span class="p">{}</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>X<span class="w"> </span><span class="p">{}</span>
<span class="c1">// 这段代码不会编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="p">,</span><span class="w"> </span>X<span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>代码编译出错的原因是 <code class="docutils literal notranslate"><span class="pre">C</span></code> 要求 <code class="docutils literal notranslate"><span class="pre">X</span></code> 重写 <code class="docutils literal notranslate"><span class="pre">A</span></code>
（因为定义的顺序是 <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">X</span></code> ）， 但是 <code class="docutils literal notranslate"><span class="pre">A</span></code> 本身要求重写 <code class="docutils literal notranslate"><span class="pre">X</span></code>，
这是一种无法解决的冲突。</p>
<p>由于您必须明确地重载一个从多个基类合约继承的函数，
而没有唯一的重载，C3线性化在实践中不是太重要。</p>
<p>继承的线性化特别重要的一个领域是，当继承层次中存在多个构造函数时，也许不那么清楚。
构造函数将总是按照线性化的顺序执行，而不管它们的参数在继承合约的构造函数中是以何种顺序提供的。 比如说：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaehOmAoOWHveaVsOaMieS7peS4i+mhuuW6j+aJp+ihjO+8mgovLyAgMSAtIEJhc2UxCi8vICAyIC0gQmFzZTIKLy8gIDMgLSBEZXJpdmVkMQpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlMSwgQmFzZTIgewogICAgY29uc3RydWN0b3IoKSBCYXNlMSgpIEJhc2UyKCkge30KfQoKLy8g5p6E6YCg5Ye95pWw5oyJ5Lul5LiL6aG65bqP5omn6KGM77yaCi8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQyCmNvbnRyYWN0IERlcml2ZWQyIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UyKCkgQmFzZTEoKSB7fQp9CgovLyDmnoTpgKDlh73mlbDku43mjInku6XkuIvpobrluo/miafooYzvvJoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 构造函数按以下顺序执行：</span>
<span class="c1">//  1 - Base1</span>
<span class="c1">//  2 - Base2</span>
<span class="c1">//  3 - Derived1</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base1<span class="p">()</span><span class="w"> </span>Base2<span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 构造函数按以下顺序执行：</span>
<span class="c1">//  1 - Base2</span>
<span class="c1">//  2 - Base1</span>
<span class="c1">//  3 - Derived2</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base2<span class="p">,</span><span class="w"> </span>Base1<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base2<span class="p">()</span><span class="w"> </span>Base1<span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 构造函数仍按以下顺序执行：</span>
<span class="c1">//  1 - Base2</span>
<span class="c1">//  2 - Base1</span>
<span class="c1">//  3 - Derived3</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived3</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base2<span class="p">,</span><span class="w"> </span>Base1<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base1<span class="p">()</span><span class="w"> </span>Base2<span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id32">
<h4>继承有相同名字的不同类型成员<a class="headerlink" href="#id32" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt>由于继承的原因，当合约有以下任何一对具有相同的名称时，这是一个错误：</dt><dd><ul class="simple">
<li><p>函数和修饰器</p></li>
<li><p>函数和事件</p></li>
<li><p>事件和修饰器</p></li>
</ul>
</dd>
</dl>
<p>有一种例外情况，状态变量的 getter 可以重载一个外部函数。</p>
</section>
</section>
<section id="abstract-contract">
<span id="index-23"></span><span id="id33"></span><h3>抽象合约<a class="headerlink" href="#abstract-contract" title="此标题的永久链接"></a></h3>
<p>当合约中至少有一个函数没有被实现，或者合约没有为其所有的基本合约构造函数提供参数时，
合约必须被标记为 abstract。
即使不是这种情况，合约仍然可以被标记为 abstract，
例如，当您不打算直接创建合约时。
抽象（abstract）合约类似于 <a class="reference internal" href="#interfaces"><span class="std std-ref">接口（interface）合约</span></a>，
但是接口（interface）合约可以声明的内容更加有限。</p>
<p>如下例所示，使用 <code class="docutils literal notranslate"><span class="pre">abstract</span></code> 关键字来声明一个抽象合约。
注意，这个合约需要被定义为 abstract，因为函数 <code class="docutils literal notranslate"><span class="pre">utterance()</span></code> 被声明了，
但没有提供实现（没有给出实现体 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Feline</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">utterance</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样的抽象合约不能被直接实例化。如果一个抽象合约本身实现了所有定义的功能，这也是可以的。
抽象合约作为基类的用法在下面的例子中显示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Feline</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">utterance</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Cat</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Feline<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">utterance</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>override<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="s2">&quot;miaow&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果一个合约继承自一个抽象合约，并且没有通过重写实现所有未实现的函数，那么它也需要被标记为抽象的。</p>
<p>注意，没有实现的函数与 <a class="reference internal" href="index.html#function-types"><span class="std std-ref">函数类型</span></a> 不同，尽管它们的语法看起来非常相似。</p>
<p>没有实现内容的函数的例子（一个函数声明）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">);</span>
</pre></div>
</div>
<p>类型为函数类型的变量的声明实例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span>foo<span class="p">;</span>
</pre></div>
</div>
<p>抽象合约将合约的定义与它的实现解耦，提供了更好的可扩展性和自我记录，
促进了像 <a class="reference external" href="https://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a> 这样的模式，
并消除了代码的重复。抽象合约的作用与在接口中定义方法的作用相同。
它是抽象合约的设计者说 &quot;我的任何孩子都必须实现这个方法&quot; 的一种方式。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>抽象合约不能用一个未实现的virtual函数来重载一个已实现的virtual函数。</p>
</div>
</section>
<section id="interface">
<span id="interfaces"></span><span id="index-24"></span><h3>接口（interface）合约<a class="headerlink" href="#interface" title="此标题的永久链接"></a></h3>
<p>接口（interface）合约类似于抽象（abstract）合约，但是它们不能实现任何函数。并且还有进一步的限制：</p>
<ul class="simple">
<li><p>它们不能继承其他合约，但是它们可以继承其他接口合约。</p></li>
<li><p>在接口合约中所有声明的函数必须是 external 类型的，即使它们在合约中是 public 类型的。</p></li>
<li><p>它们不能声明构造函数。</p></li>
<li><p>它们不能声明状态变量。</p></li>
<li><p>它们不能声明修饰器。</p></li>
</ul>
<p>将来可能会解除这些里的某些限制。</p>
<p>接口合约基本上仅限于合约 ABI 可以表示的内容，
并且 ABI 和接口合约之间的转换应该不会丢失任何信息。</p>
<p>接口合约由它们自己的关键字表示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

interface<span class="w"> </span>Token<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">TokenType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Fungible<span class="p">,</span><span class="w"> </span>NonFungible<span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Coin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nv">obverse</span><span class="p">;</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nv">reverse</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>就像继承其他合约一样，合约可以继承接口合约。</p>
<p>所有在接口合约中声明的函数都是隐式的 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 的类型，
任何重载它们的函数都不需要 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字。
这并不自动意味着一个重载的函数可以被再次重载--这只有在重载的函数被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 时才可能。</p>
<p>接口合约可以从其他接口合约继承。这与普通的继承有着相同的规则。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyDlv4Xpobvph43mlrDlrprkuYl0ZXN077yM5Lul5L6/5pat6KiA54i257G755qE5ZCr5LmJ5piv5YW85a6555qE44CCCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

interface<span class="w"> </span>ParentA<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">);</span>
<span class="p">}</span>

interface<span class="w"> </span>ParentB<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">);</span>
<span class="p">}</span>

interface<span class="w"> </span>SubInterface<span class="w"> </span><span class="kt">is</span><span class="w"> </span>ParentA<span class="p">,</span><span class="w"> </span>ParentB<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 必须重新定义test，以便断言父类的含义是兼容的。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>override<span class="p">(</span>ParentA<span class="p">,</span><span class="w"> </span>ParentB<span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在接口合约和其他类似合约的结构中定义的类型可以从其他合约中访问： <code class="docutils literal notranslate"><span class="pre">Token.TokenType</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Token.Coin</span></code>。</p>
</section>
<section id="libraries">
<span id="index-25"></span><span id="id35"></span><h3>库合约<a class="headerlink" href="#libraries" title="此标题的永久链接"></a></h3>
<p>库合约与普通合约类似，但是它们只需要在特定的地址部署一次，
并且它们的代码可以通过 EVM 的 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> (Homestead 之前使用 <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code> 关键字)特性进行重用。
这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，
即 <code class="docutils literal notranslate"><span class="pre">this</span></code> 指向调用合约，特别是可以访问调用合约的存储。
因为每个库合约都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。
如果库函数不修改状态（也就是说，如果它们是 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数），
它们可以通过直接调用来使用（即不使用 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> 关键字），
这是因为我们假定库合约是无状态的。
特别的是，销毁一个库合约是不可能的。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.4.20版本之前，有可能通过规避Solidity的类型系统来破坏库合约。
从该版本开始，库合约包含一个 <a class="reference internal" href="#call-protection"><span class="std std-ref">保护机制</span></a>，
不允许直接调用修改状态的函数（即没有 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> ）。</p>
</div>
<p>库合约可以看作是使用他们的合约的隐式的基类合约。
虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似
（如果 <code class="docutils literal notranslate"><span class="pre">L</span></code> 是库合约的话，可以使用 <code class="docutils literal notranslate"><span class="pre">L.f()</span></code> 调用库函数）。
当然，需要使用内部调用约定来调用内部函数，这意味着所有的内部类型都可以被传递，
类型 <a class="reference internal" href="index.html#data-location"><span class="std std-ref">存储在内存</span></a> 将被引用传递而不是复制。
为了在EVM中实现这一点，从合约中调用的内部库函数的代码和其中调用的所有函数将在编译时包含在调用合约中，
并使用常规的 <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 调用，而不是 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当涉及到公共函数时，继承的类比就失效了。
用 <code class="docutils literal notranslate"><span class="pre">L.f()</span></code> 调用公共库函数的结果是一个外部调用（准确地说，是 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> ）。
相反，当 <code class="docutils literal notranslate"><span class="pre">A.f()</span></code> 是当前合约的基类合约时， <code class="docutils literal notranslate"><span class="pre">A.f()</span></code> 是一个内部调用。</p>
</div>
<p id="index-26">下面的示例说明如何使用库（但也请务必看看 <a class="reference internal" href="#using-for"><span class="std std-ref">using for</span></a> 有一个实现 set 更好的例子）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIOaIkeS7rOWumuS5ieS6huS4gOS4quaWsOeahOe7k+aehOS9k+aVsOaNruexu+Wei++8jOeUqOS6juWcqOiwg+eUqOWQiOe6puS4reS/neWtmOaVsOaNruOAggpzdHJ1Y3QgRGF0YSB7CiAgICBtYXBwaW5nKHVpbnQgPT4gYm9vbCkgZmxhZ3M7Cn0KCmxpYnJhcnkgU2V0IHsKICAgIC8vIOazqOaEj+esrOS4gOS4quWPguaVsOaYryDigJxzdG9yYWdlIHJlZmVyZW5jZeKAneexu+Wei++8jAogICAgLy8g5Zug5q2k5Zyo6LCD55So5Lit5Y+C5pWw5Lyg6YCS55qE5Y+q5piv5a6D55qE5a2Y5YKo5Zyw5Z2A6ICM5LiN5piv5YaF5a6544CCCiAgICAvLyDov5nmmK/lupPlh73mlbDnmoTkuIDkuKrnibnmgKfjgILlpoLmnpzor6Xlh73mlbDlj6/ku6Xooqvop4bkuLrlr7nosaHnmoTmlrnms5XvvIwKICAgIC8vIOWImeS5oOaDr+ensOesrOS4gOS4quWPguaVsOS4uiBgc2VsZmAg44CCCiAgICBmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5LiN5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyDkuI3pnIDopoHlupPnmoTnibnlrprlrp7kvovlsLHlj6/ku6XosIPnlKjlupPlh73mlbDvvIwKICAgICAgICAvLyDlm6DkuLrlvZPliY3lkIjnuqblsLHmmK8g4oCcaW5zdGFuY2XigJ3jgIIKICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyDlpoLmnpzmiJHku6zmhL/mhI/vvIzmiJHku6zkuZ/lj6/ku6XlnKjov5nkuKrlkIjnuqbkuK3nm7TmjqXorr/pl64ga25vd25WYWx1ZXMuZmxhZ3PjgIIKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>


<span class="c1">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>flags<span class="p">;</span>
<span class="p">}</span>

<span class="kt">library</span><span class="w"> </span>Set<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 注意第一个参数是 “storage reference”类型，</span>
<span class="w">    </span><span class="c1">// 因此在调用中参数传递的只是它的存储地址而不是内容。</span>
<span class="w">    </span><span class="c1">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，</span>
<span class="w">    </span><span class="c1">// 则习惯称第一个参数为 `self` 。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 已经存在</span>
<span class="w">        </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不存在</span>
<span class="w">        </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contains</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>view
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>Data<span class="w"> </span>knownValues<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 不需要库的特定实例就可以调用库函数，</span>
<span class="w">        </span><span class="c1">// 因为当前合约就是 “instance”。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>Set<span class="p">.</span>insert<span class="p">(</span>knownValues<span class="p">,</span><span class="w"> </span>value<span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当然，您不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。
函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">Set.contains</span></code>， <code class="docutils literal notranslate"><span class="pre">Set.insert</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Set.remove</span></code> 都被编译为对外部合约/库的调用（ <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> ）。
如果使用库，请注意实际执行的是外部函数调用。
<code class="docutils literal notranslate"><span class="pre">msg.sender</span></code>， <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 和 <code class="docutils literal notranslate"><span class="pre">this</span></code> 在调用中将保留它们的值，
（在 Homestead 之前，因为使用了 <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code> ，改变了 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code>)。</p>
<p>下面的例子显示了如何使用 <a class="reference internal" href="index.html#data-location"><span class="std std-ref">存储在内存中的类型</span></a> 和库合约中的内部函数，
以实现自定义类型，而没有外部函数调用的开销：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyDlpKrlt67kuobvvIzmiJHku6zpnIDopoHlop7liqDkuIDkuKogbGltYgogICAgICAgICAgICB1aW50W10gbWVtb3J5IG5ld0xpbWJzID0gbmV3IHVpbnRbXShyLmxpbWJzLmxlbmd0aCArIDEpOwogICAgICAgICAgICB1aW50IGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKQogICAgICAgICAgICAgICAgbmV3TGltYnNbaV0gPSByLmxpbWJzW2ldOwogICAgICAgICAgICBuZXdMaW1ic1tpXSA9IGNhcnJ5OwogICAgICAgICAgICByLmxpbWJzID0gbmV3TGltYnM7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGxpbWIoYmlnaW50IG1lbW9yeSBhLCB1aW50IGluZGV4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gaW5kZXggPCBhLmxpbWJzLmxlbmd0aCA/IGEubGltYnNbaW5kZXhdIDogMDsKICAgIH0KCiAgICBmdW5jdGlvbiBtYXgodWludCBhLCB1aW50IGIpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgQmlnSW50IGZvciBiaWdpbnQ7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBiaWdpbnQgbWVtb3J5IHggPSBCaWdJbnQuZnJvbVVpbnQoNyk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB5ID0gQmlnSW50LmZyb21VaW50KHR5cGUodWludCkubWF4KTsKICAgICAgICBiaWdpbnQgbWVtb3J5IHogPSB4LmFkZCh5KTsKICAgICAgICBhc3NlcnQoei5saW1iKDEpID4gMCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.0</span><span class="p">;</span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">bigint</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>limbs<span class="p">;</span>
<span class="p">}</span>

<span class="kt">library</span><span class="w"> </span>BigInt<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">fromUint</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>r<span class="p">.</span>limbs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span><span class="m m-Decimal">1</span><span class="p">);</span>
<span class="w">        </span>r<span class="p">.</span>limbs<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">add</span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="p">,</span><span class="w"> </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>b<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>r<span class="p">.</span>limbs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>max<span class="p">(</span>a<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">,</span><span class="w"> </span>b<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">));</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">carry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>r<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="o">++</span>i<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">limbA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>limb<span class="p">(</span>a<span class="p">,</span><span class="w"> </span>i<span class="p">);</span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">limbB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>limb<span class="p">(</span>b<span class="p">,</span><span class="w"> </span>i<span class="p">);</span>
<span class="w">            </span>unchecked<span class="w"> </span><span class="p">{</span>
<span class="w">                </span>r<span class="p">.</span>limbs<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>limbA<span class="w"> </span><span class="o">+</span><span class="w"> </span>limbB<span class="w"> </span><span class="o">+</span><span class="w"> </span>carry<span class="p">;</span>

<span class="w">                </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>limbA<span class="w"> </span><span class="o">+</span><span class="w"> </span>limbB<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>limbA<span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span>limbA<span class="w"> </span><span class="o">+</span><span class="w"> </span>limbB<span class="w"> </span><span class="o">==</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>carry<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">))</span>
<span class="w">                    </span>carry<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">                </span><span class="kt">else</span>
<span class="w">                    </span>carry<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>carry<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 太差了，我们需要增加一个 limb</span>
<span class="w">            </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>newLimbs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>r<span class="p">.</span>limbs<span class="p">.</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="p">;</span>
<span class="w">            </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span>i<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>r<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="o">++</span>i<span class="p">)</span>
<span class="w">                </span>newLimbs<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>r<span class="p">.</span>limbs<span class="p">[</span>i<span class="p">];</span>
<span class="w">            </span>newLimbs<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>carry<span class="p">;</span>
<span class="w">            </span>r<span class="p">.</span>limbs<span class="w"> </span><span class="o">=</span><span class="w"> </span>newLimbs<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">limb</span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">index</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>index<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>a<span class="p">.</span>limbs<span class="p">.</span>length<span class="w"> </span><span class="o">?</span><span class="w"> </span>a<span class="p">.</span>limbs<span class="p">[</span>index<span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">max</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>b<span class="w"> </span><span class="o">?</span><span class="w"> </span>a<span class="w"> </span><span class="o">:</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>using<span class="w"> </span>BigInt<span class="w"> </span><span class="kt">for</span><span class="w"> </span>bigint<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>BigInt<span class="p">.</span>fromUint<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">);</span>
<span class="w">        </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span>BigInt<span class="p">.</span>fromUint<span class="p">(</span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">);</span>
<span class="w">        </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>z<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">.</span>add<span class="p">(</span>y<span class="p">);</span>
<span class="w">        </span>assert<span class="p">(</span>z<span class="p">.</span>limb<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通过将库合约的类型转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，即使用 <code class="docutils literal notranslate"><span class="pre">address(LibraryName)</span></code>，可以获得一个库的地址。</p>
<p>由于编译器不知道库合约的部署地址，
编译后的十六进制代码将包含 <code class="docutils literal notranslate"><span class="pre">__$30bbc0abd4d6364515865950d3e0d10953$__</span></code> 形式的占位符。
占位符是完全等同于库合约名的keccak256哈希值的34个字符的前缀，例如 <code class="docutils literal notranslate"><span class="pre">libraries/bigint.sol:BigInt</span></code>，
如果该库存储在 <code class="docutils literal notranslate"><span class="pre">libraries/</span></code> 目录下一个名为 <code class="docutils literal notranslate"><span class="pre">bigint.sol</span></code> 的文件中。
这样的字节码是不完整的，不应该被部署。占位符需要被替换成实际地址。
您可以在编译库的时候把它们传递给编译器，或者用链接器来更新已经编译好的二进制文件。
参见 <a class="reference internal" href="index.html#library-linking"><span class="std std-ref">库链接</span></a>，了解如何使用命令行编译器进行链接。</p>
<p>与合约相比，库在以下方面受到限制：</p>
<ul class="simple">
<li><p>它们不能有状态变量</p></li>
<li><p>它们不能继承，也不能被继承</p></li>
<li><p>它们不能接收以太</p></li>
<li><p>它们不能被销毁</p></li>
</ul>
<p>(这些可能会在以后的时间里被解除)。</p>
<span class="target" id="library-selectors"></span><section id="index-27">
<span id="id36"></span><h4>库合约中的函数签名和选择器<a class="headerlink" href="#index-27" title="此标题的永久链接"></a></h4>
<p>虽然对公共或外部库函数的外部调用是可能的，但这种调用的调用惯例被认为是 Solidity 内部的，
与常规 <a class="reference internal" href="index.html#abi"><span class="std std-ref">合约 ABI</span></a> 所指定的不一样。
外部库函数比外部合约函数支持更多的参数类型，例如递归结构和存储指针。
由于这个原因，用于计算4字节选择器的函数签名是按照内部命名模式计算的，
合约ABI中不支持的类型的参数使用内部编码。</p>
<p>签名中的类型使用了以下标识符：</p>
<ul class="simple">
<li><p>值类型、非存储的 <code class="docutils literal notranslate"><span class="pre">string</span></code> 和非存储的 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 使用与合约ABI中相同的标识符。</p></li>
<li><p>非存储数组类型遵循与合约ABI中相同的惯例，即 <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;[]</span></code> 用于动态数组，
<code class="docutils literal notranslate"><span class="pre">&lt;type&gt;[M]</span></code> 用于 <code class="docutils literal notranslate"><span class="pre">M</span></code> 元素的固定大小数组。</p></li>
<li><p>非存储结构体用其完全等同于的名称来指代，即 <code class="docutils literal notranslate"><span class="pre">C.S</span></code> 代表 <code class="docutils literal notranslate"><span class="pre">contract</span> <span class="pre">C</span> <span class="pre">{</span> <span class="pre">struct</span> <span class="pre">S</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">}</span></code>。</p></li>
<li><p>存储指针映射使用 <code class="docutils literal notranslate"><span class="pre">mapping(&lt;keyType&gt;</span> <span class="pre">=&gt;</span> <span class="pre">&lt;valueType&gt;)</span> <span class="pre">storage</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">&lt;keyType&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;valueType&gt;</span></code> 分别是映射的键和值类型的标识。</p></li>
<li><p>其他存储指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格，即 <code class="docutils literal notranslate"><span class="pre">storage</span></code>。</p></li>
</ul>
<p>参数的编码与普通合约ABI相同，除了存储指针，
它被编码为一个 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 值，指的是它们所指向的存储槽。</p>
<p>与合约ABI类似，选择器由签名的Keccak256-hash的前四个字节组成。
它的值可以通过使用 <code class="docutils literal notranslate"><span class="pre">.selector</span></code> 成员从 Solidity 获得，如下：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.14</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>L<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bytes4<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>L<span class="p">.</span>f<span class="p">.</span>selector<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="call-protection">
<span id="id37"></span><h4>库的调用保护<a class="headerlink" href="#call-protection" title="此标题的永久链接"></a></h4>
<p>正如介绍中提到的那样，如果库的代码是通过 <code class="docutils literal notranslate"><span class="pre">CALL</span></code> 来执行，
而不是 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code>，
那么执行的结果会被恢复， 除非是对 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数的调用。</p>
<p>EVM没有提供一个直接的方法让合约检测它是否被使用 <code class="docutils literal notranslate"><span class="pre">CALL</span></code> 调用，
但是合约可以使用 <code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code> 操作码来找出它当前运行的 &quot;位置&quot;。
生成的代码将这个地址与构造时使用的地址进行比较，以确定调用的模式。</p>
<p>更具体地说，一个库合约的运行时代码总是以 push 指令开始，
在编译时它是一个20字节的零。
当部署代码运行时，这个常数在内存中被当前地址所取代，这个修改后的代码被存储在合约中。
在运行时，这导致部署时的地址成为第一个被推入堆栈的常数，
对于任何 非-view 和 非-pure 函数，调度器代码会将当前地址与这个常数进行比较。</p>
<p>这意味着一个存储在链上的库合约的实际代码，与编译器报告的 <code class="docutils literal notranslate"><span class="pre">deployedBytecode</span></code> 的代码不同。</p>
</section>
</section>
<section id="using-for">
<span id="index-28"></span><span id="id38"></span><h3>Using For<a class="headerlink" href="#using-for" title="此标题的永久链接"></a></h3>
<p>指令 <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code> 可以用来将函数（ <code class="docutils literal notranslate"><span class="pre">A</span></code>）作为成员函数附加到任何类型（ <code class="docutils literal notranslate"><span class="pre">B</span></code>）。
这些函数将接收它们被调用的对象作为其第一个参数（就像Python中的 <code class="docutils literal notranslate"><span class="pre">self</span></code> 变量）。</p>
<p>它可以在文件级别或者在合约级别的合约内部有效。</p>
<p>第一部分， <code class="docutils literal notranslate"><span class="pre">A</span></code>，可以是以下之一：</p>
<ul class="simple">
<li><p>文件级别或库函数的列表（ <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">{f,</span> <span class="pre">g,</span> <span class="pre">h,</span> <span class="pre">L.t}</span> <span class="pre">for</span> <span class="pre">uint;</span></code>）-
只有这些函数才会被附加到类型上。</p></li>
<li><p>一个库合约的名字（ <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">L</span> <span class="pre">for</span> <span class="pre">uint;</span></code>）-
库合约的所有函数（公共函数和内部函数）都被附加到了该类型上。</p></li>
</ul>
<p>在文件级别，第二部分， <code class="docutils literal notranslate"><span class="pre">B</span></code>， 必须是一个显式类型（没有数据位置指定符）。
在合约内部，您还可以使用 <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">L</span> <span class="pre">for</span> <span class="pre">*;</span></code>，
这会使库合约 <code class="docutils literal notranslate"><span class="pre">L</span></code> 的所有函数都被附加到 <em>所有</em> 类型上。</p>
<p>如果您指定了一个库合约，那么库合约中的 <em>所有</em> 函数都会被附加上，
即使那些第一个参数的类型与对象的类型不匹配的函数也是如此。
类型会在函数被调用的时候检查，并执行函数重载解析。</p>
<p>如果您使用函数列表（ <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">{f,</span> <span class="pre">g,</span> <span class="pre">h,</span> <span class="pre">L.t}</span> <span class="pre">for</span> <span class="pre">uint;</span></code>），
那么类型（ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）必须隐式可转换为这些函数的第一个参数。
即使这些函数都没有被调用，这个检查也会执行。</p>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code> 指令只在当前作用域（合约或当前模块/源单元）内有效，
包括其中所有的函数，在使用它的合约或模块之外没有任何效果。</p>
<p>当在文件级别使用该指令并应用于在同一文件中用户定义类型时，
可以在末尾添加 <code class="docutils literal notranslate"><span class="pre">global</span></code> 关键字。
这将产生的效果是，函数将附加到类型的每个地方（包括其他文件），
而不仅仅是在 using 语句的作用域内。</p>
<p>下面我们将使用文件级函数来重写 <a class="reference internal" href="#libraries"><span class="std std-ref">库合约</span></a> 部分中的 set 示例。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyDnjrDlnKjmiJHku6znu5nov5nkuKrnsbvlnovpmYTliqDkuIrlh73mlbDjgIIKLy8g6ZmE5Yqg55qE5Ye95pWw5Y+v5Lul5Zyo5qih5Z2X55qE5YW25LuW6YOo5YiG5L2/55So44CCCi8vIOWmguaenOaCqOWvvOWFpeS6huivpeaooeWdl++8jAovLyDmgqjlv4XpobvlnKjpgqPph4zph43lpI11c2luZ+aMh+S7pO+8jOS+i+WmggovLyAgIGltcG9ydCAiZmxhZ3Muc29sIiBhcyBGbGFnczsKLy8gICB1c2luZyB7RmxhZ3MuaW5zZXJ0LCBGbGFncy5yZW1vdmUsIEZsYWdzLmNvbnRhaW5zfQovLyAgICAgZm9yIEZsYWdzLkRhdGE7CnVzaW5nIHtpbnNlcnQsIHJlbW92ZSwgY29udGFpbnN9IGZvciBEYXRhOwoKZnVuY3Rpb24gaW5zZXJ0KERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKHNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgIHJldHVybiBmYWxzZTsgLy8gYWxyZWFkeSB0aGVyZQogICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgcmV0dXJuIHRydWU7Cn0KCmZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBub3QgdGhlcmUKICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gZmFsc2U7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gY29udGFpbnMoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICB2aWV3CiAgICByZXR1cm5zIChib29sKQp7CiAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyDov5nph4zvvIwgRGF0YSDnsbvlnovnmoTmiYDmnInlj5jph4/pg73mnInkuI7kuYvnm7jlr7nlupTnmoTmiJDlkZjlh73mlbDjgIIKICAgICAgICAvLyDkuIvpnaLnmoTlh73mlbDosIPnlKjlkowgYFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKWAg55qE5pWI5p6c5a6M5YWo55u45ZCM44CCCiAgICAgICAgcmVxdWlyZShrbm93blZhbHVlcy5pbnNlcnQodmFsdWUpKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.13</span><span class="p">;</span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>flags<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// 现在我们给这个类型附加上函数。</span>
<span class="c1">// 附加的函数可以在模块的其他部分使用。</span>
<span class="c1">// 如果您导入了该模块，</span>
<span class="c1">// 您必须在那里重复using指令，例如</span>
<span class="c1">//   import &quot;flags.sol&quot; as Flags;</span>
<span class="c1">//   using {Flags.insert, Flags.remove, Flags.contains}</span>
<span class="c1">//     for Flags.Data;</span>
using<span class="w"> </span><span class="p">{</span>insert<span class="p">,</span><span class="w"> </span>remove<span class="p">,</span><span class="w"> </span>contains<span class="p">}</span><span class="w"> </span><span class="kt">for</span><span class="w"> </span>Data<span class="p">;</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// already there</span>
<span class="w">    </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// not there</span>
<span class="w">    </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">contains</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">    </span>view
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">];</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>Data<span class="w"> </span>knownValues<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这里， Data 类型的所有变量都有与之相对应的成员函数。</span>
<span class="w">        </span><span class="c1">// 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>knownValues<span class="p">.</span>insert<span class="p">(</span>value<span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>也可以通过这种方式来扩展内置类型。
在这个例子中，我们将使用一个库合约。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyDov5nlsIbmiafooYzlupPlkIjnuqbkuK3nmoTlh73mlbDosIPnlKgKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.13</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>Search<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">indexOf</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>view
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>self<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>value<span class="p">)</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>i<span class="p">;</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
using<span class="w"> </span>Search<span class="w"> </span><span class="kt">for</span><span class="w"> </span><span class="kt">uint</span><span class="p">[];</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>data<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">append</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>data<span class="p">.</span>push<span class="p">(</span>value<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">replace</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">from</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">to</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 这将执行库合约中的函数调用</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>indexOf<span class="p">(</span>from<span class="p">);</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>index<span class="w"> </span><span class="o">==</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">)</span>
<span class="w">            </span>data<span class="p">.</span>push<span class="p">(</span>to<span class="p">);</span>
<span class="w">        </span><span class="kt">else</span>
<span class="w">            </span>data<span class="p">[</span>index<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>to<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，所有的外部库调用实际都是EVM函数调用。
这意味着，如果您传递内存或值类型，将进行拷贝，即使是在 <code class="docutils literal notranslate"><span class="pre">self</span></code> 变量的情况下。
唯一不进行拷贝的情况是当使用存储引用变量或调用内部库函数时。</p>
</section>
</section>
<span id="document-assembly"></span><section id="inline-assembly">
<span id="id1"></span><h2>内联汇编<a class="headerlink" href="#inline-assembly" title="此标题的永久链接"></a></h2>
<p id="index-0">您可以用接近Ethereum虚拟机的语言，将Solidity语句与内联汇编交错使用。
这给了您更精细的控制，这在您通过编写库来增强语言时特别有用。</p>
<p>在 Solidity 中用于内联汇编的语言被称为 <a class="reference internal" href="index.html#yul"><span class="std std-ref">Yul</span></a>，它在自己的章节中被记录。
本节将只涉及内联汇编代码如何在 Solidity 代码内交互。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>内联汇编是一种在低等级上访问Ethereum虚拟机的方式。
这绕过了Solidity的几个重要安全功能和检查。
您应该只在需要它的任务中使用它，而且只有在您对使用它有信心的情况下。</p>
</div>
<p>一个内联汇编块由 <code class="docutils literal notranslate"><span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 标记的，其中大括号内的代码是 <a class="reference internal" href="index.html#yul"><span class="std std-ref">Yul</span></a> 语言中的代码。</p>
<p>内联汇编代码可以访问本地 Solidity 变量，如下所述。</p>
<p>不同的内联汇编块不共享名称空间，
即不能调用或访问一个在不同内联汇编块中定义的Yul函数或变量。</p>
<section id="id2">
<h3>例子<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>下面例子展示了一个库合约的代码，它可以取得另一个合约的代码，
并将其加载到一个 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 变量中。 通过使用 <code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.code</span></code>，
这在 &quot;普通Solidity&quot; 中也是可能的。但这里的重点是，可重用的汇编库可以增强 Solidity 语言，
而不需要改变编译器。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgR2V0Q29kZSB7CiAgICBmdW5jdGlvbiBhdChhZGRyZXNzIGFkZHIpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJ5dGVzIG1lbW9yeSBjb2RlKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyDojrflj5bku6PnoIHlpKflsI/vvIzov5npnIDopoHmsYfnvJbor63oqIAKICAgICAgICAgICAgbGV0IHNpemUgOj0gZXh0Y29kZXNpemUoYWRkcikKICAgICAgICAgICAgLy8g5YiG6YWN6L6T5Ye65a2X6IqC5pWw57uEIOKAkyDov5nkuZ/lj6/ku6XkuI3nlKjmsYfnvJbor63oqIDmnaXlrp7njrAKICAgICAgICAgICAgLy8g6YCa6L+H5L2/55SoIGNvZGUgPSBuZXcgYnl0ZXMoc2l6ZSkKICAgICAgICAgICAgY29kZSA6PSBtbG9hZCgweDQwKQogICAgICAgICAgICAvLyDljIXmi6zooaXkvY3lnKjlhoXmlrDnmoQg4oCcbWVtb3J5IGVuZOKAnQogICAgICAgICAgICBtc3RvcmUoMHg0MCwgYWRkKGNvZGUsIGFuZChhZGQoYWRkKHNpemUsIDB4MjApLCAweDFmKSwgbm90KDB4MWYpKSkpCiAgICAgICAgICAgIC8vIOaKiumVv+W6puS/neWtmOWIsOWGheWtmOS4rQogICAgICAgICAgICBtc3RvcmUoY29kZSwgc2l6ZSkKICAgICAgICAgICAgLy8g5a6e6ZmF6I635Y+W5Luj56CB77yM6L+Z6ZyA6KaB5rGH57yW6K+t6KiACiAgICAgICAgICAgIGV4dGNvZGVjb3B5KGFkZHIsIGFkZChjb2RlLCAweDIwKSwgMCwgc2l6ZSkKICAgICAgICB9CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>GetCode<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">at</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>code<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 获取代码大小，这需要汇编语言</span>
<span class="w">            </span>let<span class="w"> </span>size<span class="w"> </span><span class="o">:=</span><span class="w"> </span>extcodesize<span class="p">(</span>addr<span class="p">)</span>
<span class="w">            </span><span class="c1">// 分配输出字节数组 – 这也可以不用汇编语言来实现</span>
<span class="w">            </span><span class="c1">// 通过使用 code = new bytes(size)</span>
<span class="w">            </span>code<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
<span class="w">            </span><span class="c1">// 包括补位在内新的 “memory end”</span>
<span class="w">            </span>mstore<span class="p">(</span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span>add<span class="p">(</span>code<span class="p">,</span><span class="w"> </span>and<span class="p">(</span>add<span class="p">(</span>add<span class="p">(</span>size<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">),</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">),</span><span class="w"> </span>not<span class="p">(</span><span class="mh">0x1f</span><span class="p">))))</span>
<span class="w">            </span><span class="c1">// 把长度保存到内存中</span>
<span class="w">            </span>mstore<span class="p">(</span>code<span class="p">,</span><span class="w"> </span>size<span class="p">)</span>
<span class="w">            </span><span class="c1">// 实际获取代码，这需要汇编语言</span>
<span class="w">            </span>extcodecopy<span class="p">(</span>addr<span class="p">,</span><span class="w"> </span>add<span class="p">(</span>code<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>size<span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在优化器不能产生高效代码的情况下，内联汇编也是有益的，例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCgpsaWJyYXJ5IFZlY3RvclN1bSB7CiAgICAvLyDov5nkuKrlh73mlbDnmoTmiafooYzmlYjnjofmr5TovoPkvY7vvIwKICAgIC8vIOWboOS4uuS8mOWMluWZqOW9k+WJjeaXoOazleWIoOmZpOaVsOe7hOiuv+mXruS4reeahOi+ueeVjOajgOafpeOAggogICAgZnVuY3Rpb24gc3VtU29saWRpdHkodWludFtdIG1lbW9yeSBkYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpCiAgICAgICAgICAgIHN1bSArPSBkYXRhW2ldOwogICAgfQoKICAgIC8vIOaIkeS7rOefpemBk+aIkeS7rOWPquiDveWcqOaVsOe7hOiMg+WbtOWGheiuv+mXruaVsOe7hOWFg+e0oO+8jOaJgOS7peaIkeS7rOWPr+S7pemBv+WFjeajgOafpeOAggogICAgLy8g55Sx5LqOIEFCSSDnvJbnoIHkuK3mlbDnu4TmlbDmja7nmoTnrKzkuIDkuKrlrZfvvIgzMiDlrZfoioLvvInnmoTkvY3nva7kv53lrZjnmoTmmK/mlbDnu4Tplb/luqbvvIwKICAgIC8vIOaJgOS7peaIkeS7rOWcqOiuv+mXruaVsOe7hOWFg+e0oOaXtumcgOimgeWKoOWFpSAweDIwIOS9nOS4uuWBj+enu+mHj+OAggogICAgZnVuY3Rpb24gc3VtQXNtKHVpbnRbXSBtZW1vcnkgZGF0YSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCBzdW0pIHsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGFzc2VtYmx5IHsKICAgICAgICAgICAgICAgIHN1bSA6PSBhZGQoc3VtLCBtbG9hZChhZGQoYWRkKGRhdGEsIDB4MjApLCBtdWwoaSwgMHgyMCkpKSkKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICAvLyDlkozkuIrpnaLkuIDmoLfvvIzkvYblnKjlhoXogZTmsYfnvJblhoXlrozmiJDmlbTkuKrku6PnoIHjgIIKICAgIGZ1bmN0aW9uIHN1bVB1cmVBc20odWludFtdIG1lbW9yeSBkYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGFzc2VtYmx5IHsKICAgICAgICAgICAgLy8g5Yqg6L295pWw57uE6ZW/5bqm77yI5YmNIDMyIOWtl+iKgu+8iQogICAgICAgICAgICBsZXQgbGVuIDo9IG1sb2FkKGRhdGEpCgogICAgICAgICAgICAvLyDnlaXov4fplb/luqblrZfmrrXjgIIKICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8g5L+d5oyB5Li05pe25Y+Y6YeP5Lul5L6/5a6D5Y+v5Lul5Zyo5Y6f5Zyw5aKe5Yqg44CCCiAgICAgICAgICAgIC8vCiAgICAgICAgICAgIC8vIOazqOaEj++8mumAkuWinmRhdGHkvJrlr7zoh7TlnKjov5nkuKrmsYfnvJblnZfkuYvlkI7lh7rnjrDkuIDkuKrml6Dms5Xkvb/nlKjnmoRkYXRh5Y+Y6YeP44CCCiAgICAgICAgICAgIGxldCBkYXRhRWxlbWVudExvY2F0aW9uIDo9IGFkZChkYXRhLCAweDIwKQoKICAgICAgICAgICAgLy8g6L+t5Luj5Yiw5pWw57uE5pWw5o2u57uT5p2f44CCCiAgICAgICAgICAgIGZvcgogICAgICAgICAgICAgICAgeyBsZXQgZW5kIDo9IGFkZChkYXRhRWxlbWVudExvY2F0aW9uLCBtdWwobGVuLCAweDIwKSkgfQogICAgICAgICAgICAgICAgbHQoZGF0YUVsZW1lbnRMb2NhdGlvbiwgZW5kKQogICAgICAgICAgICAgICAgeyBkYXRhRWxlbWVudExvY2F0aW9uIDo9IGFkZChkYXRhRWxlbWVudExvY2F0aW9uLCAweDIwKSB9CiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHN1bSA6PSBhZGQoc3VtLCBtbG9hZChkYXRhRWxlbWVudExvY2F0aW9uKSkKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>


<span class="kt">library</span><span class="w"> </span>VectorSum<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 这个函数的执行效率比较低，</span>
<span class="w">    </span><span class="c1">// 因为优化器当前无法删除数组访问中的边界检查。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sumSolidity</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>data<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>data<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="o">++</span>i<span class="p">)</span>
<span class="w">            </span>sum<span class="w"> </span><span class="o">+=</span><span class="w"> </span>data<span class="p">[</span>i<span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 我们知道我们只能在数组范围内访问数组元素，所以我们可以避免检查。</span>
<span class="w">    </span><span class="c1">// 由于 ABI 编码中数组数据的第一个字（32 字节）的位置保存的是数组长度，</span>
<span class="w">    </span><span class="c1">// 所以我们在访问数组元素时需要加入 0x20 作为偏移量。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sumAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>data<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>data<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="o">++</span>i<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">                </span>sum<span class="w"> </span><span class="o">:=</span><span class="w"> </span>add<span class="p">(</span>sum<span class="p">,</span><span class="w"> </span>mload<span class="p">(</span>add<span class="p">(</span>add<span class="p">(</span>data<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">),</span><span class="w"> </span>mul<span class="p">(</span>i<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">))))</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 和上面一样，但在内联汇编内完成整个代码。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sumPureAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>data<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 加载数组长度（前 32 字节）</span>
<span class="w">            </span>let<span class="w"> </span>len<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span>data<span class="p">)</span>

<span class="w">            </span><span class="c1">// 略过长度字段。</span>
<span class="w">            </span><span class="c1">//</span>
<span class="w">            </span><span class="c1">// 保持临时变量以便它可以在原地增加。</span>
<span class="w">            </span><span class="c1">//</span>
<span class="w">            </span><span class="c1">// 注意：递增data会导致在这个汇编块之后出现一个无法使用的data变量。</span>
<span class="w">            </span>let<span class="w"> </span>dataElementLocation<span class="w"> </span><span class="o">:=</span><span class="w"> </span>add<span class="p">(</span>data<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">)</span>

<span class="w">            </span><span class="c1">// 迭代到数组数据结束。</span>
<span class="w">            </span><span class="kt">for</span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span>let<span class="w"> </span>end<span class="w"> </span><span class="o">:=</span><span class="w"> </span>add<span class="p">(</span>dataElementLocation<span class="p">,</span><span class="w"> </span>mul<span class="p">(</span>len<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">                </span>lt<span class="p">(</span>dataElementLocation<span class="p">,</span><span class="w"> </span>end<span class="p">)</span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span>dataElementLocation<span class="w"> </span><span class="o">:=</span><span class="w"> </span>add<span class="p">(</span>dataElementLocation<span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span>sum<span class="w"> </span><span class="o">:=</span><span class="w"> </span>add<span class="p">(</span>sum<span class="p">,</span><span class="w"> </span>mload<span class="p">(</span>dataElementLocation<span class="p">))</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="index-1">
<span id="id3"></span><h3>访问外部变量、函数和库<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>您可以通过使用其名称来访问 Solidity 变量和其他标识符。</p>
<p>值类型的局部变量可以直接用于内联汇编。它们既可以被读取也可以被赋值。</p>
<p>指向内存的局部变量是指内存中变量的地址，而不是值本身。
这样的变量也可以被赋值，但请注意，赋值只会改变指针而不是数据，
尊重 Solidity 的内存管理是您的责任。
参见 <a class="reference internal" href="#conventions-in-solidity"><span class="std std-ref">Solidity的惯例</span></a>。</p>
<p>同样地，引用静态大小的calldata数组或calldata结构的局部变量会指向calldata中变量的地址，
而不是值本身。变量也可以被分配一个新的偏移量，但是请注意，
没有进行验证以确保变量不会指向超过 <code class="docutils literal notranslate"><span class="pre">calldatasize()</span></code> 的地方。</p>
<p>对于外部函数指针，地址和函数选择器可以用 <code class="docutils literal notranslate"><span class="pre">x.address</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x.selector</span></code> 来访问。
选择器由四个右对齐的字节组成。两个值都可以被赋值。比如说：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjEwIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8g5bCG5LiA5Liq5paw55qE6YCJ5oup5Zmo5ZKM5Zyw5Z2A5YiG6YWN57uZ6L+U5Zue5Y+Y6YePIEBmdW4KICAgIGZ1bmN0aW9uIGNvbWJpbmVUb0Z1bmN0aW9uUG9pbnRlcihhZGRyZXNzIG5ld0FkZHJlc3MsIHVpbnQgbmV3U2VsZWN0b3IpIHB1YmxpYyBwdXJlIHJldHVybnMgKGZ1bmN0aW9uKCkgZXh0ZXJuYWwgZnVuKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICBmdW4uc2VsZWN0b3IgOj0gbmV3U2VsZWN0b3IKICAgICAgICAgICAgZnVuLmFkZHJlc3MgIDo9IG5ld0FkZHJlc3MKICAgICAgICB9CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.10</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 将一个新的选择器和地址分配给返回变量 @fun</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">combineToFunctionPointer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newAddress</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">newSelector</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">function</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>fun<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span>fun<span class="p">.</span>selector<span class="w"> </span><span class="o">:=</span><span class="w"> </span>newSelector
<span class="w">            </span>fun<span class="p">.</span><span class="kt">address</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span>newAddress
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于动态的calldata数组，您可以使用 <code class="docutils literal notranslate"><span class="pre">x.offset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x.length</span></code> 访问它们的calldata偏移量（字节）和长度（元素数）。
这两个表达式也可以被赋值，但是和静态情况一样，不会进行验证以确保产生的数据区域在 <code class="docutils literal notranslate"><span class="pre">calldatasize()</span></code> 的范围内。</p>
<p>对于本地存储变量或状态变量，一个Yul标识符是不够的，因为它们不一定占据一个完整的存储槽。
因此，它们的 &quot;地址&quot; 是由一个槽和槽内的字节偏移量组成。要检索变量 <code class="docutils literal notranslate"><span class="pre">x</span></code> 所指向的槽，
您可以使用 <code class="docutils literal notranslate"><span class="pre">x.slot</span></code>，要检索字节偏移量，您可以使用 <code class="docutils literal notranslate"><span class="pre">x.offset</span></code> 。
使用 <code class="docutils literal notranslate"><span class="pre">x</span></code> 本身会导致错误。</p>
<p>您也可以分配给本地存储变量指针的 <code class="docutils literal notranslate"><span class="pre">.slot</span></code> 部分。
对于这些（结构、数组或映射）， <code class="docutils literal notranslate"><span class="pre">.offset</span></code> 部分总是零。
但不可能分配给状态变量的 <code class="docutils literal notranslate"><span class="pre">.slot</span></code> 或 <code class="docutils literal notranslate"><span class="pre">.offset</span></code> 部分。</p>
<p>本地 Solidity 变量可用于赋值，例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IGI7CiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCByKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyDmiJHku6zlv73nlaXkuoblrZjlgqjmp73nmoTlgY/np7vph4/vvIzmiJHku6znn6XpgZPlnKjov5nnp43nibnmrormg4XlhrXkuIvlroPmmK/pm7bjgIIKICAgICAgICAgICAgciA6PSBtdWwoeCwgc2xvYWQoYi5zbG90KSkKICAgICAgICB9CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 我们忽略了存储槽的偏移量，我们知道在这种特殊情况下它是零。</span>
<span class="w">            </span>r<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mul<span class="p">(</span>x<span class="p">,</span><span class="w"> </span>sload<span class="p">(</span>b<span class="p">.</span>slot<span class="p">))</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果您访问一个跨度小于256位的类型的变量（例如 <code class="docutils literal notranslate"><span class="pre">uint64</span></code>， <code class="docutils literal notranslate"><span class="pre">address</span></code>，或 <code class="docutils literal notranslate"><span class="pre">bytes16</span></code>），
您不能对不属于该类型的编码的位做任何假设。特别是，不要假设它们是零。
为了安全起见，在使用前一定要适当清除数据，因为这一点很重要：
<code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f();</span> <span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">and(x,</span> <span class="pre">0xffffff)</span> <span class="pre">/*</span> <span class="pre">现在使用</span> <span class="pre">x</span> <span class="pre">*/</span> <span class="pre">}</span></code>
为了清除有符号的类型，您可以使用 <code class="docutils literal notranslate"><span class="pre">signextend</span></code> 操作码。
<code class="docutils literal notranslate"><span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">signextend(&lt;num_bytes_of_x_minus_one&gt;,</span> <span class="pre">x)</span> <span class="pre">}</span></code></p>
</div>
<p>自Solidity 0.6.0以来，内联汇编变量的名称不能影射内联汇编块范围内可见的任何声明
（包括变量、合约和函数声明）。</p>
<p>自Solidity 0.7.0以来，在内联程序块内声明的变量和函数不能包含 <code class="docutils literal notranslate"><span class="pre">.</span></code>，
但使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 可以有效地从内联程序块外访问Solidity变量。</p>
</section>
<section id="id4">
<h3>需要避免的事情<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>内联汇编可能有一个相当高级的外观，但它实际上是非常低级的。
函数调用、循环、if条件和switch条件都可以通过简单的改写规则进行转换，
之后，汇编器为您做的唯一事情就是重新安排函数式的操作码，
为变量访问计算堆栈高度，并在达到汇编局部变量块的末端时移除堆栈槽。</p>
</section>
<section id="solidity">
<span id="conventions-in-solidity"></span><h3>Solidity的的惯例<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h3>
<section id="assembly-typed-variables">
<span id="id5"></span><h4>类型化变量的值<a class="headerlink" href="#assembly-typed-variables" title="此标题的永久链接"></a></h4>
<p>与EVM汇编相反，Solidity有比256位更窄的类型，例如： <code class="docutils literal notranslate"><span class="pre">uint24</span></code>。
为了提高效率，大多数算术运算忽略了类型可以短于256位的事实，高阶位在必要时被清理，
例如，在它们被写入内存前不久或在执行比较之前。
这意味着，如果您从内联汇编中访问这样的变量，您可能不得不先手动清理高阶位。</p>
</section>
<section id="assembly-memory-management">
<span id="id6"></span><h4>内存管理<a class="headerlink" href="#assembly-memory-management" title="此标题的永久链接"></a></h4>
<p>Solidity以下列方式管理内存。在内存中 <code class="docutils literal notranslate"><span class="pre">0x40</span></code> 的位置有一个 &quot;空闲内存指针&quot;。
如果您想分配内存，从这个指针指向的地方开始使用内存，并更新它。
不能保证该内存以前没有被使用过，因此您不能假设其内容为零字节。
没有内置的机制来释放或释放分配的内存。下面是一段汇编代码，
您可以用它来分配内存，它遵循上述的过程：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gYWxsb2NhdGUobGVuZ3RoKSAtPiBwb3MgewogIHBvcyA6PSBtbG9hZCgweDQwKQogIG1zdG9yZSgweDQwLCBhZGQocG9zLCBsZW5ndGgpKQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">allocate</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pos</span> <span class="p">{</span>
  <span class="n">pos</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
  <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>前64字节的内存可以作为短期分配的 &quot;划痕空间（scratch space）&quot;。
空闲内存指针之后的32字节（即从 <code class="docutils literal notranslate"><span class="pre">0x60</span></code> 开始）是指永久为零，
并作为空的动态内存数组的初始值使用。
这意味着可分配的内存从 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> 开始，也就是空闲内存指针的初始值。</p>
<p>Solidity中内存数组中的元素总是占据32字节的倍数
（对于 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 来说也是如此，但对于 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 来说不是这样）。
多维内存数组是指向内存数组的指针。一个动态数组的长度被存储在数组的第一个槽里，后面是数组元素。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>静态大小的内存数组没有长度字段，但以后可能会加入长度字段，
以便在静态大小的数组和动态大小的数组之间有更好的转换性；所以，不要依赖这个特性。</p>
</div>
</section>
<section id="id7">
<h4>内存安全<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>在不使用内联汇编的情况下，编译器可以依靠内存在任何时候都保持一个良好的定义状态。
这对于 <a class="reference internal" href="index.html#ir-breaking-changes"><span class="std std-ref">通过 Yul IR 的新代码生成管道</span></a> 来说尤其重要：
这个代码生成路径可以将局部变量从堆栈转移到内存，以避免堆栈过深的错误，并执行额外的内存优化，
如果它可以依赖于对内存使用的某些假设的话。</p>
<p>虽然我们建议始终尊重 Solidity 的内存模型，但内联汇编允许您以不兼容的方式使用内存。
因此，在任何包含内存操作或在内存中分配给 Solidity 变量的内联汇编块存在的情况下，
将堆栈变量移动到内存和额外的内存优化默认为全局禁用。</p>
<p>然而，您可以特别注释一个汇编块，以表明它实际上是遵循 Solidity 内存模型的，如下所示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICAgIC4uLgp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>assembly<span class="w"> </span><span class="p">(</span><span class="s2">&quot;memory-safe&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>特别的是，一个内存安全的汇编块只能访问以下内存范围：</p>
<ul class="simple">
<li><p>通过上述 <code class="docutils literal notranslate"><span class="pre">allocate</span></code> 函数这样的机制由自己分配的内存。</p></li>
<li><p>由 Solidity 分配的内存，例如，在您引用的内存数组的范围内的内存。</p></li>
<li><p>上面提到的内存偏移量0和64之间的划痕空间。</p></li>
<li><p>位于汇编块开始时的空闲内存指针值 <em>之后</em> 的临时内存，
即在空闲内存指针上 “分配” 而不更新空闲内存指针的内存。</p></li>
</ul>
<p>此外，如果汇编块分配给内存中的 Solidity 变量，则需要确保对 Solidity 变量的访问只访问这些内存范围。</p>
<p>由于这主要是关于优化器的，所以这些限制仍然需要被遵守，即使汇编块回退或终止。
举个例子，下面的汇编片段不是内存安全的，
因为 <code class="docutils literal notranslate"><span class="pre">returndatasize()</span></code> 的值可能会超过64字节的划痕空间。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YXNzZW1ibHkgewogIHJldHVybmRhdGFjb3B5KDAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KDAsIHJldHVybmRhdGFzaXplKCkpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">  </span>returndatacopy<span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>returndatasize<span class="p">())</span>
<span class="w">  </span>revert<span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>returndatasize<span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>另一方面，下面的代码 <em>是</em> 内存安全的，
因为超出空闲内存指针所指向的位置的内存可以安全地用作临时划痕空间：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICBsZXQgcCA6PSBtbG9hZCgweDQwKQogIHJldHVybmRhdGFjb3B5KHAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KHAsIHJldHVybmRhdGFzaXplKCkpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>assembly<span class="w"> </span><span class="p">(</span><span class="s2">&quot;memory-safe&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span>let<span class="w"> </span>p<span class="w"> </span><span class="o">:=</span><span class="w"> </span>mload<span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
<span class="w">  </span>returndatacopy<span class="p">(</span>p<span class="p">,</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>returndatasize<span class="p">())</span>
<span class="w">  </span>revert<span class="p">(</span>p<span class="p">,</span><span class="w"> </span>returndatasize<span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，如果没有后续分配，则不需要更新空闲内存指针，
但只能使用从空闲内存指针给出的当前偏移量开始的内存。</p>
<p>如果内存操作使用的长度为0，那么也可以使用任意偏移量（不仅仅是落在了划痕空间中）；</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICByZXZlcnQoMCwgMCkKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>assembly<span class="w"> </span><span class="p">(</span><span class="s2">&quot;memory-safe&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span>revert<span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，不仅内联汇编中的内存操作本身可以是内存不安全的，
而且对内存中引用类型的 Solidity 变量的赋值也是如此。例如，以下内容就不是内存安全的：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ynl0ZXMgbWVtb3J5IHg7CmFzc2VtYmx5IHsKICB4IDo9IDB4NDAKfQp4WzB4MjBdID0gMHg0Mjs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>x<span class="p">;</span>
assembly<span class="w"> </span><span class="p">{</span>
<span class="w">  </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x40</span>
<span class="p">}</span>
x<span class="p">[</span><span class="mh">0x20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x42</span><span class="p">;</span>
</pre></div>
</div>
<p>既不涉及访问内存的任何操作，也不对内存中的任何 Solidity 变量进行赋值的内联汇编，
自动被认为是内存安全的，不需要被注释。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>确保汇编块程序实际满足内存模型是您的责任。
如果您将一个汇编块注释为内存安全的，但却违反了其中一个内存假设，
那么这 <strong>将</strong> 导致不正确的和未定义的行为，而这些行为不容易通过测试发现。</p>
</div>
<p>如果您正在开发一个要在多个 Solidity 版本之间兼容的库，
您可以使用一个特殊的注释将一个汇编块注释为内存安全的：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8vIEBzb2xpZGl0eSBtZW1vcnktc2FmZS1hc3NlbWJseQphc3NlbWJseSB7CiAgICAuLi4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">/// @solidity memory-safe-assembly</span>
assembly<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，我们将在未来的突破性版本中不允许通过注释的方式进行注解；
因此，如果您不关心与旧编译器版本的向后兼容问题，最好使用这种写法的代码字符串形式。</p>
</section>
</section>
</section>
<span id="document-cheatsheet"></span><section id="id1">
<h2>速查表<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<section id="index-0">
<span id="id2"></span><h3>操作符的优先顺序<a class="headerlink" href="#index-0" title="此标题的永久链接"></a></h3>
<p>以下是按评估顺序列出的操作符优先级。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 13%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>优先级</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>操作符</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>1</em></p></td>
<td><p>后置自增和自减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">++</span></code>， <code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>创建类型实例</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">&lt;类型名&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>数组元素</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;数组&gt;[&lt;索引&gt;]</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>访问成员</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;对象&gt;.&lt;成员名&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>函数调用</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;函数&gt;(&lt;参数...&gt;)</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>小括号</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(&lt;表达式&gt;)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>2</em></p></td>
<td><p>前置自增和自减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">++</span></code>， <code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>一元运算减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>一元操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">delete</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>逻辑非</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">!</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>按位非</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>3</em></p></td>
<td><p>乘方</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>4</em></p></td>
<td><p>乘、除和模运算</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>5</em></p></td>
<td><p>算术加和减</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code>， <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>6</em></p></td>
<td><p>移位操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>7</em></p></td>
<td><p>按位与</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>8</em></p></td>
<td><p>按位异或</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>9</em></p></td>
<td><p>按位或</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>10</em></p></td>
<td><p>非等操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>11</em></p></td>
<td><p>等于操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>12</em></p></td>
<td><p>逻辑与</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>13</em></p></td>
<td><p>逻辑或</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>14</em></p></td>
<td><p>三元操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;判断条件&gt;</span> <span class="pre">?</span> <span class="pre">&lt;如果为真时执行的表达式&gt;</span> <span class="pre">:</span> <span class="pre">&lt;如果为假时执行的表达式&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>赋值操作符</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code>， <code class="docutils literal notranslate"><span class="pre">|=</span></code>， <code class="docutils literal notranslate"><span class="pre">^=</span></code>， <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">+=</span></code>， <code class="docutils literal notranslate"><span class="pre">-=</span></code>， <code class="docutils literal notranslate"><span class="pre">*=</span></code>， <code class="docutils literal notranslate"><span class="pre">/=</span></code>， <code class="docutils literal notranslate"><span class="pre">%=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>15</em></p></td>
<td><p>逗号</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">,</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="index-1">
<span id="id3"></span><h3>全局变量<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abi.decode(bytes</span> <span class="pre">memory</span> <span class="pre">encodedData,</span> <span class="pre">(...))</span> <span class="pre">returns</span> <span class="pre">(...)</span></code>： <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a> -对提供的数据进行解码。类型在括号中作为第二个参数给出。
示例： <code class="docutils literal notranslate"><span class="pre">(uint</span> <span class="pre">a,</span> <span class="pre">uint[2]</span> <span class="pre">memory</span> <span class="pre">b,</span> <span class="pre">bytes</span> <span class="pre">memory</span> <span class="pre">c)</span> <span class="pre">=</span> <span class="pre">abi.decode(data,</span> <span class="pre">(uint,</span> <span class="pre">uint[2],</span> <span class="pre">bytes))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encode(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a>-对给定的参数进行编码。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodePacked(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对给定的参数执行 <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">紧密打包</span></a>。
请注意，这种编码可能是不明确的!</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(bytes4</span> <span class="pre">selector,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a>-对给定参数进行编码，
并以给定的函数选择器作为起始的 4 字节数据一起返回</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeCall(function</span> <span class="pre">functionPointer,</span> <span class="pre">(...))</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对 <code class="docutils literal notranslate"><span class="pre">functionPointer</span></code> 的调用进行ABI编码，
参数在元组中找到。执行全面的类型检查，确保类型与函数签名相符。结果等于 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(functionPointer.selector(..))</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeWithSignature(string</span> <span class="pre">memory</span> <span class="pre">signature,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 等价于
<code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(bytes4(keccak256(bytes(signature)),</span> <span class="pre">...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bytes.concat(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： <a class="reference internal" href="index.html#bytes-concat"><span class="std std-ref">将可变数量的参数连接成一个字节数组</span></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string.concat(...)</span> <span class="pre">returns</span> <span class="pre">(string</span> <span class="pre">memory)</span></code>： <a class="reference internal" href="index.html#string-concat"><span class="std std-ref">将可变数量的参数连接成一个字符串数组</span></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.basefee</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 当前区块的基本费用 （ <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a> ）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.chainid</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 当前链的ID</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.coinbase</span></code> (<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>)： 当前区块矿工的地址</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.difficulty</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 当前区块的难度值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.gaslimit</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 当前区块的 gas 上限</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.number</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 当前区块的区块号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 当前区块的时间戳，自Unix epoch以来的秒数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gasleft()</span> <span class="pre">returns</span> <span class="pre">(uint256)</span></code>： 剩余gas</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.data</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes</span></code>)： 完整的调用数据</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> (<code class="docutils literal notranslate"><span class="pre">address</span></code>)： 消息发送方（当前调用）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.sig</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes4</span></code>)： Calldata的前四个字节（即函数标识符）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.value</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 随消息发送的 wei 的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx.gasprice</span></code> (<code class="docutils literal notranslate"><span class="pre">uint</span></code>)： 交易的 gas 价格</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx.origin</span></code> (<code class="docutils literal notranslate"><span class="pre">address</span></code>)： 交易发送方（完整调用链上的原始发送方）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assert(bool</span> <span class="pre">condition)</span></code>： 如果条件为 <code class="docutils literal notranslate"><span class="pre">false</span></code>，则中止执行并恢复状态变化（用于内部错误）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">require(bool</span> <span class="pre">condition)</span></code>： 如果条件为 <code class="docutils literal notranslate"><span class="pre">false</span></code>，则中止执行并恢复状态变化（用于错误的输入或外部组件的错误）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">require(bool</span> <span class="pre">condition,</span> <span class="pre">string</span> <span class="pre">memory</span> <span class="pre">message)</span></code>： 如果条件为 <code class="docutils literal notranslate"><span class="pre">false</span></code>，则中止执行并恢复状态变化（用于错误的输入或外部组件的错误）。同时提供错误信息。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">revert()</span></code>： 中止执行并恢复状态变化</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">revert(string</span> <span class="pre">memory</span> <span class="pre">message)</span></code>： 中止执行并恢复状态变化，提供一个解释性的字符串</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blockhash(uint</span> <span class="pre">blockNumber)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>： 给定区块的哈希值 - 只对最近的256个区块有效</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keccak256(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>： 计算输入的Keccak-256哈希值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sha256(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>： 计算输入的SHA-256哈希值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ripemd160(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes20)</span></code>： 计算输入的RIPEMD-160的哈希值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ecrecover(bytes32</span> <span class="pre">hash,</span> <span class="pre">uint8</span> <span class="pre">v,</span> <span class="pre">bytes32</span> <span class="pre">r,</span> <span class="pre">bytes32</span> <span class="pre">s)</span> <span class="pre">returns</span> <span class="pre">(address)</span></code>： 从椭圆曲线签名中恢复与公钥相关的地址，错误时返回0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code>： 计算 <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code> 的值，其中加法的结果即使超过 <code class="docutils literal notranslate"><span class="pre">2**256</span></code> 也不会被截取。从 0.5.0 版本开始会加入对 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> 的 assert（即会在此函数开头执行 <code class="docutils literal notranslate"><span class="pre">assert(k</span> <span class="pre">!=</span> <span class="pre">0);</span></code> 作为参数检查，译者注）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mulmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code>： 计算 <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code> 的值，其中乘法的结果即使超过 <code class="docutils literal notranslate"><span class="pre">2**256</span></code> 也不会被截取。从 0.5.0 版本开始会加入对 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> 的 assert（即会在此函数开头执行 <code class="docutils literal notranslate"><span class="pre">assert(k</span> <span class="pre">!=</span> <span class="pre">0);</span></code> 作为参数检查，译者注）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> （当前合约的类型）： 当前合约，可明确转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 或 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">super</span></code>： 继承层次中高一级的合约</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">selfdestruct(address</span> <span class="pre">payable</span> <span class="pre">recipient)</span></code>： 销毁当前合约，将其资金发送到给定的地址。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.balance</span></code> (<code class="docutils literal notranslate"><span class="pre">uint256</span></code>)： <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 的余额，以 Wei 为单位</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.code</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code>)： 在 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 的代码（可以是空的）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.codehash</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes32</span></code>)： <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 的代码哈希值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;address</span> <span class="pre">payable&gt;.send(uint256</span> <span class="pre">amount)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code>： 向 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 发送给定数量的 Wei，失败时返回 <code class="docutils literal notranslate"><span class="pre">false</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;address</span> <span class="pre">payable&gt;.transfer(uint256</span> <span class="pre">amount)</span></code>： 向 <a class="reference internal" href="index.html#address"><span class="std std-ref">地址类型</span></a> 发送给定数量的 Wei，失败时会把错误抛出（throw）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type(C).name</span></code> (<code class="docutils literal notranslate"><span class="pre">string</span></code>)： 合约的名称</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type(C).creationCode</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code>)： 给定合约的创建字节码，参见 <a class="reference internal" href="index.html#meta-type"><span class="std std-ref">类型信息</span></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type(C).runtimeCode</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code>)： 给定合约的运行时字节码，参见 <a class="reference internal" href="index.html#meta-type"><span class="std std-ref">类型信息</span></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type(I).interfaceId</span></code> (<code class="docutils literal notranslate"><span class="pre">bytes4</span></code>)： 包含给定接口的EIP-165接口标识符的值，参见 <a class="reference internal" href="index.html#meta-type"><span class="std std-ref">类型信息</span></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type(T).min</span></code> (<code class="docutils literal notranslate"><span class="pre">T</span></code>)： 整数类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 所能代表的最小值，参见 <a class="reference internal" href="index.html#meta-type"><span class="std std-ref">类型信息</span></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type(T).max</span></code> (<code class="docutils literal notranslate"><span class="pre">T</span></code>)： 整数类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 所能代表的最大值，参见 <a class="reference internal" href="index.html#meta-type"><span class="std std-ref">类型信息</span></a>。</p></li>
</ul>
</section>
<section id="index-2">
<span id="id4"></span><h3>函数可见性说明符<a class="headerlink" href="#index-2" title="此标题的永久链接"></a></h3>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gbXlGdW5jdGlvbigpIDx2aXNpYmlsaXR5IHNwZWNpZmllcj4gcmV0dXJucyAoYm9vbCkgewogICAgcmV0dXJuIHRydWU7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">myFunction</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span>visibility<span class="w"> </span>specifier<span class="o">&gt;</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">public</span></code>： 内部、外部均可见（参考为存储/状态变量创建 <a class="reference internal" href="index.html#getter-functions"><span class="std std-ref">getter function</span></a> 函数）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">private</span></code>： 仅在当前合约内可见</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">external</span></code>： 仅在外部可见（仅可修饰函数）——就是说，仅可用于消息调用（即使在合约内调用，也只能通过 <code class="docutils literal notranslate"><span class="pre">this.func</span></code> 的方式）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">internal</span></code>： 仅在内部可见（也就是在当前 Solidity 源代码文件内均可见，不仅限于当前合约内，译者注）</p></li>
</ul>
</section>
<section id="index-3">
<span id="id5"></span><h3>修改器<a class="headerlink" href="#index-3" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pure</span></code> 修饰函数时：不允许修改或访问状态。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">view</span></code> 修饰函数时：不允许修改状态。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">payable</span></code> 修饰函数时：允许从调用中接收以太币。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code> 修饰状态变量时：不允许赋值（除初始化以外），不会占据 存储插槽（storage slot）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> 修饰状态变量时：在构造时允许有一个确切的赋值，之后是恒定的。被存储在代码中。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anonymous</span></code> 修饰事件时：不把事件签名作为 topic 存储。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">indexed</span></code> 修饰事件参数时：将参数作为 topic 存储。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtual</span></code> 修饰函数和修改时：允许在派生合约中改变函数或修改器的行为。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">override</span></code> 表示该函数、修改器或公共状态变量改变了基类合约中的函数或修改器的行为。</p></li>
</ul>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-using-the-compiler"></span><section id="id1">
<h2>使用编译器<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<section id="commandline-compiler">
<span id="index-0"></span><span id="id2"></span><h3>使用命令行编译器<a class="headerlink" href="#commandline-compiler" title="此标题的永久链接"></a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这一节并不适用于 <a class="reference internal" href="index.html#solcjs"><span class="std std-ref">solcjs</span></a>， 即使在命令行模式下使用也不行。</p>
</div>
<section id="id3">
<h4>基本用法<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">solc</span></code> 是 Solidity 仓库的构建目标之一, 它是 solidity 命令行编译器。
使用 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--help</span></code> 可以为您提供所有选项的解释。编译器可以产生各种输出，
从简单的二进制文件和抽象语法树(解析树)上的汇编到气体使用量的估计。
如果您只想编译一个文件，您可以运行 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--bin</span> <span class="pre">sourceFile.sol</span></code> 来生成二进制文件。
如果您想通过 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 获得一些更高级的输出信息，
可以通过 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">-o</span> <span class="pre">outputDirectory</span> <span class="pre">--bin</span> <span class="pre">--ast-compact-json</span> <span class="pre">--asm</span> <span class="pre">sourceFile.sol</span></code> 命令
将所有的输出都保存到单独的文件中。</p>
</section>
<section id="id4">
<h4>优化器选项<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p>在您部署合约之前，在编译时使用 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--optimize</span> <span class="pre">--bin</span> <span class="pre">sourceFile.sol</span></code> 激活优化器。
默认情况下，优化器将假设合约在其生命周期内被调用200次（更确切地说，它假设每个操作码被执行200次左右）。
如果您想让最初的合约部署更便宜，而后来的函数执行更昂贵，请设置为 <code class="docutils literal notranslate"><span class="pre">--optimize-runs=1</span></code>。
如果您期望有很多交易，并且不在乎更高的部署成本和输出大小，那么把 <code class="docutils literal notranslate"><span class="pre">--optimize-runs</span></code> 设置成一个高的数字。
这个参数对以下方面有影响（将来可能会改变）：</p>
<ul class="simple">
<li><p>函数调度程序中二进制搜索的大小</p></li>
<li><p>像大数字或字符串等常量的存储方式</p></li>
</ul>
</section>
<section id="index-1">
<span id="id5"></span><h4>基本路径和导入重映射<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h4>
<p>命令行编译器将自动从文件系统中读取导入的文件，但同时，
它也支持通过如下方式，用 <code class="docutils literal notranslate"><span class="pre">prefix=path</span></code> 选项将 <a class="reference internal" href="index.html#import-remapping"><span class="std std-ref">路径重定向</span></a>：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>github.com/ethereum/dapp-bin/<span class="o">=</span>/usr/local/lib/dapp-bin/<span class="w"> </span>file.sol
</pre></div>
</div>
<p>这实质上是指示编译器在 <code class="docutils literal notranslate"><span class="pre">/usr/local/lib/dapp-bin</span></code> 下搜索
所有以 <code class="docutils literal notranslate"><span class="pre">github.com/ethereum/dapp-bin/</span></code> 开头的文件。</p>
<p>当访问文件系统搜索导入文件时，<a class="reference internal" href="index.html#direct-imports"><span class="std std-ref">不以./或../开头的路径</span></a> 被视为
相对于使用 <code class="docutils literal notranslate"><span class="pre">--base-path</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--include-path</span></code> 选项指定的目录（如果没有指定基本路径，则是当前工作目录）。
此外，通过这些选项添加的路径部分将不会出现在合约元数据中。</p>
<p>出于安全考虑，编译器 <a class="reference internal" href="index.html#allowed-paths"><span class="std std-ref">对它可以访问的目录有一些限制</span></a>。
在命令行中指定的源文件的目录和重映射的目标路径被自动允许被文件阅读器访问，
但其他的都是默认为拒绝的。
通过 <code class="docutils literal notranslate"><span class="pre">--allow-paths</span> <span class="pre">/sample/path,/another/sample/path</span></code> 语句可以允许额外的路径（和它们的子目录）。
通过 <code class="docutils literal notranslate"><span class="pre">--base-path</span></code> 指定的路径内的所有内容都是允许的。</p>
<p>以上只是对编译器如何处理导入路径的一个简化。
关于详细的解释，包括例子和边缘情况的讨论，请参考 <a class="reference internal" href="index.html#path-resolution"><span class="std std-ref">路径解析</span></a> 一节。</p>
</section>
<section id="library-linking">
<span id="index-2"></span><span id="id6"></span><h4>库链接<a class="headerlink" href="#library-linking" title="此标题的永久链接"></a></h4>
<p>如果您的合约使用 <a class="reference internal" href="index.html#libraries"><span class="std std-ref">库合约</span></a>，
您会注意到字节码中含有 <code class="docutils literal notranslate"><span class="pre">__$53aea86b7d70b31448b230b20ae141a537$__</span></code> 形式的字符串。
这些是实际库的地址的占位符。此占位符是完全限定库名的keccak256散列的十六进制编码的34个字符前缀。
字节码文件也将包含形式为 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">&lt;placeholder&gt;</span> <span class="pre">-&gt;</span> <span class="pre">&lt;fq</span> <span class="pre">library</span> <span class="pre">name&gt;</span></code> 的代码行，以帮助识别占位符代表的库。
注意，完全限定的库名是其源文件的路径和用 <code class="docutils literal notranslate"><span class="pre">:</span></code> 分隔的库名。
您可以使用 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 作为链接器，意味着您将在这些地方插入库的地址：</p>
<p>要么在您的命令中加入
<code class="docutils literal notranslate"><span class="pre">--libraries</span> <span class="pre">&quot;file.sol:Math=0x1234567890123456789012345678901234567890</span> <span class="pre">file.sol:Heap=0xabCD567890123456789012345678901234567890&quot;</span></code>，
为每个库提供一个地址（用逗号或空格作为分隔符），要么将字符串存储在一个文件中（每行一个库），
用 <code class="docutils literal notranslate"><span class="pre">-libraries</span> <span class="pre">fileName</span></code> 运行 <code class="docutils literal notranslate"><span class="pre">solc</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>从Solidity 0.8.1 开始，接受 <code class="docutils literal notranslate"><span class="pre">=</span></code> 作为库和地址之间的分隔符，而 <code class="docutils literal notranslate"><span class="pre">:</span></code> 作为分隔符已被废弃。
它将在未来被删除。目前 <code class="docutils literal notranslate"><span class="pre">--libraries</span> <span class="pre">&quot;file.sol:Math:0x1234567890123456789012345678901234567890</span> <span class="pre">file.sol:Heap:0xabCD56789012345678901234567890&quot;</span></code> 也可以工作。</p>
</div>
<p id="index-3">如果调用 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 时有 <code class="docutils literal notranslate"><span class="pre">--standard-json</span></code> 选项，它将在标准输入中期待一个JSON输入（如下所述），
并在标准输出中返回一个JSON输出。这是对更复杂的，特别是自动化使用时的推荐接口。
该进程将始终以 “成功” 状态终止，并通过JSON输出来报告任何错误。
选项 <code class="docutils literal notranslate"><span class="pre">--base-path</span></code> 也以标准JSON模式处理。</p>
<p>如果调用 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 时带有 <code class="docutils literal notranslate"><span class="pre">--link</span></code> 选项，所有输入文件都被编译成格式为 <code class="docutils literal notranslate"><span class="pre">__$53aea86b7d70b31448b230b20ae141a537$__</span></code>
形式的未链接的二进制文件（十六进制编码），并被本地链接（如果从标准输入（stdin）读取输入，则被写到标准输出（stdout））。
在这种情况下，除了 <code class="docutils literal notranslate"><span class="pre">--libraries</span></code> 以外的所有选项都被忽略（包括 <code class="docutils literal notranslate"><span class="pre">-o</span></code> ）。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>不推荐在生成的字节码上手动链接库文件，因为它不会更新合约元数据。
由于元数据包含在编译时指定的库的列表，而字节码包含元数据哈希，
您将得到不同的二进制文件，并且这取决于何时进行链接。</p>
<p>您应该在编译合约时请求编译器链接库文件，方法是使用 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 的 <code class="docutils literal notranslate"><span class="pre">--libraries</span></code> 选项
或 <code class="docutils literal notranslate"><span class="pre">libraries</span></code> 键（如果您使用编译器的标准JSON接口）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>库的占位符曾经是库本身的完全限定名称，而不是它的哈希值。
这种格式仍然被 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--link</span></code> 支持，但编译器将不再输出它。
这一改变是为了减少库之间发生碰撞的可能性，因为只有完全限定的库名的前36个字符可以被使用。</p>
</div>
<span class="target" id="evm-version"></span></section>
</section>
<section id="evm">
<span id="index-4"></span><h3>将EVM版本设置为目标版本<a class="headerlink" href="#evm" title="此标题的永久链接"></a></h3>
<p>当您编译您的合约代码时，您可以指定以太坊虚拟机版本来编译，以避免特定的功能或行为。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在错误的EVM版本进行编译会导致错误，奇怪和失败的行为。
请确保，特别是在运行一个私有链的情况下，您使用匹配的EVM版本。</p>
</div>
<p>在命令行中，您可以选择EVM的版本，如下所示：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>--evm-version<span class="w"> </span>&lt;VERSION&gt;<span class="w"> </span>contract.sol
</pre></div>
</div>
<p>在 <a class="reference internal" href="#compiler-api"><span class="std std-ref">标准 JSON 接口</span></a> 中，使用 <code class="docutils literal notranslate"><span class="pre">&quot;settings&quot;</span></code> 字段中的键 <code class="docutils literal notranslate"><span class="pre">&quot;evmVersion&quot;</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="s2">&quot;sources&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">},</span>
<span class="w">  </span><span class="s2">&quot;settings&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">},</span>
<span class="w">    </span><span class="s2">&quot;evmVersion&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&lt;VERSION&gt;&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="id7">
<h4>EVM版本选项<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>以下是一个EVM版本的列表，以及每个版本中引入的编译器相关变化。
每个版本之间不保证向后兼容。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">homestead</span></code></dt><dd><ul>
<li><p>（最老的版本）</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tangerineWhistle</span></code></dt><dd><ul>
<li><p>访问其他账户的gas成本增加，与gas估算和优化器有关。</p></li>
<li><p>对于外部调用，所有gas都是默认发送的，以前必须保留一定的数量。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">spuriousDragon</span></code></dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">exp</span></code> 操作码的gas成本增加，与gas估计和优化器有关。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">byzantium</span></code></dt><dd><ul>
<li><p>在汇编中可使用操作码 <code class="docutils literal notranslate"><span class="pre">returndatacopy</span></code>， <code class="docutils literal notranslate"><span class="pre">returndatasize</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 操作码在调用非库合约 view 或 pure 函数时使用，它可以防止函数在EVM级别修改状态，也就是说，甚至适用于您使用无效的类型转换时。</p></li>
<li><p>可以访问从函数调用返回的动态数据。</p></li>
<li><p>引入了 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 操作码，这意味着 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 将不会浪费gas。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">constantinople</span></code></dt><dd><ul>
<li><p>在汇编中可使用操作码 <code class="docutils literal notranslate"><span class="pre">create2</span></code>, <code class="docutils literal notranslate"><span class="pre">extcodehash</span></code>, <code class="docutils literal notranslate"><span class="pre">shl</span></code>, <code class="docutils literal notranslate"><span class="pre">shr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sar</span></code>。</p></li>
<li><p>移位运算符使用移位运算码，因此需要的gas较少。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">petersburg</span></code></dt><dd><ul>
<li><p>编译器的行为与 constantinople 版本的行为相同。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">istanbul</span></code></dt><dd><ul>
<li><p>在汇编中可使用操作码 <code class="docutils literal notranslate"><span class="pre">chainid</span></code> 和 <code class="docutils literal notranslate"><span class="pre">selfbalance</span></code>。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">berlin</span></code></dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SLOAD</span></code>, <code class="docutils literal notranslate"><span class="pre">*CALL</span></code>, <code class="docutils literal notranslate"><span class="pre">BALANCE</span></code>, <code class="docutils literal notranslate"><span class="pre">EXT*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">SELFDESTRUCT</span></code> 的gas成本增加。
编译器假设这类操作的gas成本是固定的。这与gas估计和优化器有关。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">london</span></code> (<strong>default</strong>)</dt><dd><ul>
<li><p>区块的基本费用（ <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a> ）
可以通过全局的 <code class="docutils literal notranslate"><span class="pre">block.basefee</span></code> 或内联汇编中的 <code class="docutils literal notranslate"><span class="pre">basefee()</span></code> 访问。</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<section id="json">
<span id="compiler-api"></span><span id="index-5"></span><h3>编译器输入和输出JSON说明<a class="headerlink" href="#json" title="此标题的永久链接"></a></h3>
<p>推荐的与Solidity编译器连接的方式，特别是对于更复杂和自动化的设置，是所谓的JSON输入输出接口。
编译器的所有发行版都提供相同的接口。</p>
<p>这些字段一般都会有变化，有些是可选的（如前所述），但我们尽量只做向后兼容的改动。</p>
<p>编译器API期望JSON格式的输入，并将编译结果输出为JSON格式的输出。
不使用标准错误输出，进程将始终以 “成功” 状态终止，即使存在错误。错误总是作为JSON输出的一部分报告。</p>
<p>以下各小节通过一个例子来描述该格式。
当然，注释是不允许的，在此仅用于解释。</p>
<section id="id8">
<h4>输入说明<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 必选：源代码语言。目前支持的是 “Solidity“ 和 “Yul“。</span>
<span class="w">  </span><span class="s2">&quot;language&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Solidity&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 必选</span>
<span class="w">  </span><span class="s2">&quot;sources&quot;</span><span class="o">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 这里的键值是源文件的 “全局“ 名称，</span>
<span class="w">    </span><span class="c1">// 导入文件可以通过重映射使用其他文件（见下文）。</span>
<span class="w">    </span><span class="s2">&quot;myFile.sol&quot;</span><span class="o">:</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 可选： 源文件的kaccak256哈希值</span>
<span class="w">      </span><span class="c1">// 如果通过URL导入，它用于验证检索的内容。</span>
<span class="w">      </span><span class="s2">&quot;keccak256&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x123...&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 必选（除非声明了 &quot;content&quot; 字段，参见下文）: 指向源文件的URL。</span>
<span class="w">      </span><span class="c1">// 应按此顺序导入URL，并根据keccak256哈希值检查结果（如果有的话）。</span>
<span class="w">      </span><span class="c1">// 如果哈希值不匹配，或者没有一个URL(s)的结果是成功的，就应该产生一个错误。</span>
<span class="w">      </span><span class="c1">// 使用命令行界面只支持文件系统路径。</span>
<span class="w">      </span><span class="c1">// 通过JavaScript接口，URL将被传递给用户提供的读取回调，因此可以使用回调支持的任何URL。</span>
<span class="w">      </span><span class="s2">&quot;urls&quot;</span><span class="o">:</span>
<span class="w">      </span><span class="p">[</span>
<span class="w">        </span><span class="s2">&quot;bzzr://56ab...&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;ipfs://Qma...&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;/tmp/path/to/file.sol&quot;</span>
<span class="w">        </span><span class="c1">// 如果使用文件，其目录应通过 `--allow-paths &lt;path&gt;` 添加到命令行中。</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="s2">&quot;destructible&quot;</span><span class="o">:</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 可选：源文件的keccak256哈希值</span>
<span class="w">      </span><span class="s2">&quot;keccak256&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x234...&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 必选：（除非使用 “urls“）：源文件的字面内容</span>
<span class="w">      </span><span class="s2">&quot;content&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;contract destructible is owned { function shutdown() { if (msg.sender == owner) selfdestruct(owner); } }&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// 可选</span>
<span class="w">  </span><span class="s2">&quot;settings&quot;</span><span class="o">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 可选： 在给定的阶段后停止编译。目前这里只有 “parsing” 有效。</span>
<span class="w">    </span><span class="s2">&quot;stopAfter&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;parsing&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// 可选： 经过排序的重映射列表</span>
<span class="w">    </span><span class="s2">&quot;remappings&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;:g=/dir&quot;</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="c1">// 可选： 优化器设置</span>
<span class="w">    </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 默认情况下是禁用的。</span>
<span class="w">      </span><span class="c1">// 注意：enabled=false 仍然保留了一些优化功能。见下面的注解。</span>
<span class="w">      </span><span class="c1">// 警告：在0.8.6版本之前，省略 “enabled“ 键并不等同于将其设置为false，</span>
<span class="w">      </span><span class="c1">// 实际上会禁用所有优化。</span>
<span class="w">      </span><span class="s2">&quot;enabled&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 根据您打算运行代码的次数进行优化。</span>
<span class="w">      </span><span class="c1">// 较低的值将更多地针对初始部署成本进行优化，</span>
<span class="w">      </span><span class="c1">// 较高的值将更多地针对高频使用进行优化。</span>
<span class="w">      </span><span class="s2">&quot;runs&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">200</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 打开或关闭优化器组件的细节。</span>
<span class="w">      </span><span class="c1">// 上面的 “enabled“ 开关提供了两个默认值，</span>
<span class="w">      </span><span class="c1">// 可以在这里进行调整。如果给出了 “details“，“enabled“ 可以省略。</span>
<span class="w">      </span><span class="s2">&quot;details&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 如果没有给出 details，窥视孔优化器总是打开的，使用 details 来关闭它。</span>
<span class="w">        </span><span class="s2">&quot;peephole&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 如果没有给出 details，内联器总是打开的，</span>
<span class="w">        </span><span class="c1">// 使用 details来关闭它。</span>
<span class="w">        </span><span class="s2">&quot;inliner&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 如果没有给出 details，未使用的跳板移除器总是打开的，</span>
<span class="w">        </span><span class="c1">// 使用 details来关闭它。</span>
<span class="w">        </span><span class="s2">&quot;jumpdestRemover&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 在换元运算中，有时会对字词重新排序。</span>
<span class="w">        </span><span class="s2">&quot;orderLiterals&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 移除重复的代码块</span>
<span class="w">        </span><span class="s2">&quot;deduplicate&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 常见的子表达式消除，这是最复杂的步骤，但也能提供最大的收益。</span>
<span class="w">        </span><span class="s2">&quot;cse&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 优化代码中字面数字和字符串的表示。</span>
<span class="w">        </span><span class="s2">&quot;constantOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 新的Yul优化器。主要在ABI coder v2 和 内联汇编的代码上运行。</span>
<span class="w">        </span><span class="c1">// 它与全局优化器设置一起被激活，并且可以在这里停用。</span>
<span class="w">        </span><span class="c1">// 在 Solidity 0.6.0 之前，它必须通过这个开关激活。</span>
<span class="w">        </span><span class="s2">&quot;yul&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// Yul优化器的调优选项。</span>
<span class="w">        </span><span class="s2">&quot;yulDetails&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// 改善变量的堆栈槽的分配，可以提前释放堆栈槽。</span>
<span class="w">          </span><span class="c1">// 如果Yul优化器被激活，则默认激活。</span>
<span class="w">          </span><span class="s2">&quot;stackAllocation&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">          </span><span class="c1">// 选择要应用的优化步骤。</span>
<span class="w">          </span><span class="c1">// 可选, 如果省略，优化器将使用默认序列。</span>
<span class="w">          </span><span class="s2">&quot;optimizerSteps&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;dhfoDgvulfnTUtnIf...&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 编译EVM的版本。</span>
<span class="w">    </span><span class="c1">// 影响到类型检查和代码生成。版本可以是 homestead,</span>
<span class="w">    </span><span class="c1">// tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul or berlin</span>
<span class="w">    </span><span class="s2">&quot;evmVersion&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;byzantium&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// 可选：改变编译管道以通过Yul的中间表示法。</span>
<span class="w">    </span><span class="c1">// 这在默认情况下是假的。</span>
<span class="w">    </span><span class="s2">&quot;viaIR&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// 可选： 调试设置</span>
<span class="w">    </span><span class="s2">&quot;debug&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 如何处理 revert（和require）的原因字符串。设置是</span>
<span class="w">      </span><span class="c1">// &quot;default&quot;, &quot;strip&quot;, &quot;debug&quot; 和 &quot;verboseDebug&quot;。</span>
<span class="w">      </span><span class="c1">// &quot;default&quot; 不注入编译器生成的revert字符串，而是保留用户提供的字符串。</span>
<span class="w">      </span><span class="c1">// &quot;strip&quot; 删除所有的revert字符串（如果可能的话，即如果使用了字面意义），以保持副作用。</span>
<span class="w">      </span><span class="c1">// &quot;debug&quot; 为编译器生成的内部revert注入字符串，目前为ABI编码器V1和V2实现。</span>
<span class="w">      </span><span class="c1">// &quot;verboseDebug&quot; 甚至将进一步的信息附加到用户提供的revert字符串中（尚未实现）。</span>
<span class="w">      </span><span class="s2">&quot;revertStrings&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 可选：在产生的EVM汇编和Yul代码的注释中包括多少额外的调试信息。可用的组件是：</span>
<span class="w">      </span><span class="c1">// - `location`: `@src &lt;index&gt;:&lt;start&gt;:&lt;end&gt;` 形式的注解，</span>
<span class="w">      </span><span class="c1">//   表明原始 Solidity 文件中相应元素的位置，其中：</span>
<span class="w">      </span><span class="c1">//     - `&lt;index&gt;` 是与 `@us-src` 注释相匹配的文件索引。</span>
<span class="w">      </span><span class="c1">//     - `&lt;start&gt;` 是该位置的第一个字节的索引。</span>
<span class="w">      </span><span class="c1">//     - `&lt;end&gt;` 是该位置后第一个字节的索引。</span>
<span class="w">      </span><span class="c1">// - `snippet`: 来自 `@src` 所示位置的单行代码片断。</span>
<span class="w">      </span><span class="c1">//     该片段有引号，并跟随相应的 `@src` 注释。</span>
<span class="w">      </span><span class="c1">// - `*`: 通配符值，可用于请求所有的东西。</span>
<span class="w">      </span><span class="s2">&quot;debugInfo&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;snippet&quot;</span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 元数据设置 (可选)</span>
<span class="w">    </span><span class="s2">&quot;metadata&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 只使用字面内容，不使用URL（默认为false）。</span>
<span class="w">      </span><span class="s2">&quot;useLiteralContent&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 对附加在字节码上的元数据哈希值使用给定的哈希值方法。</span>
<span class="w">      </span><span class="c1">// 元数据哈希可以通过选项 &quot;none &quot;从字节码中删除。</span>
<span class="w">      </span><span class="c1">// 其他选项是 &quot;ipfs&quot; 和 &quot;bzzr1&quot;。</span>
<span class="w">      </span><span class="c1">// 如果省略该选项，默认使用 &quot;ipfs&quot;。</span>
<span class="w">      </span><span class="s2">&quot;bytecodeHash&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ipfs&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 库的地址。如果这里没有给出所有的库，</span>
<span class="w">    </span><span class="c1">// 可能会导致未链接的对象，其输出数据是不同的。</span>
<span class="w">    </span><span class="s2">&quot;libraries&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 顶层键是使用该库的源文件的名称。</span>
<span class="w">      </span><span class="c1">// 如果使用了重映射，这个源文件应该与应用重映射后的全局路径一致。</span>
<span class="w">      </span><span class="c1">// 如果这个键是一个空字符串，那就是指一个全局水平。</span>
<span class="w">      </span><span class="s2">&quot;myFile.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;MyLib&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x123123...&quot;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 以下可用于根据文件和合约名称选择所需的输出。</span>
<span class="w">    </span><span class="c1">// 如果这个字段被省略，那么编译器就会加载并进行类型检查，但除了错误之外不会产生任何输出。</span>
<span class="w">    </span><span class="c1">// 第一层键是文件名，第二层键是合约名。</span>
<span class="w">    </span><span class="c1">// 一个空的合约名称用于不与合约绑定而是与整个源文件绑定的输出，如AST。</span>
<span class="w">    </span><span class="c1">// 以星号作为合约名称是指文件中的所有合约。</span>
<span class="w">    </span><span class="c1">// 同样地，以星形作为文件名可以匹配所有文件。</span>
<span class="w">    </span><span class="c1">// 要选择编译器可能产生的所有输出，</span>
<span class="w">    </span><span class="c1">// 使用 &quot;outputSelection&quot;。{ &quot;*&quot;: { &quot;*&quot;: [ &quot;*&quot; ], &quot;&quot;: [ &quot;*&quot; ] } }&quot;，</span>
<span class="w">    </span><span class="c1">// 但要注意，这可能会不必要地减慢编译过程。</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// 可用的输出类型如下：</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// 文件级别（需要空字符串作为合约名称）：</span>
<span class="w">    </span><span class="c1">//   ast - 所有源文件的AST</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// 合约级别（需要合约名称或 &quot;*&quot;）：</span>
<span class="w">    </span><span class="c1">//   abi - ABI</span>
<span class="w">    </span><span class="c1">//   devdoc - 开发者文档（Natspec格式）</span>
<span class="w">    </span><span class="c1">//   userdoc - 用户文档（Natspec格式）</span>
<span class="w">    </span><span class="c1">//   metadata - 元数据</span>
<span class="w">    </span><span class="c1">//   ir - 优化代码前的Yul中间表示法</span>
<span class="w">    </span><span class="c1">//   irOptimized - 优化后的中间表现</span>
<span class="w">    </span><span class="c1">//   storageLayout - 合约的状态变量的槽位、偏移量和类型</span>
<span class="w">    </span><span class="c1">//   evm.assembly - 新的汇编格式</span>
<span class="w">    </span><span class="c1">//   evm.legacyAssembly - JSON中的旧式汇编格式</span>
<span class="w">    </span><span class="c1">//   evm.bytecode.functionDebugData - 在函数层面的调试信息</span>
<span class="w">    </span><span class="c1">//   evm.bytecode.object - 字节码对象</span>
<span class="w">    </span><span class="c1">//   evm.bytecode.opcodes - 操作码列表</span>
<span class="w">    </span><span class="c1">//   evm.bytecode.sourceMap - 源码映射（对调试有用）</span>
<span class="w">    </span><span class="c1">//   evm.bytecode.linkReferences - 链接引用（如果是未链接的对象）</span>
<span class="w">    </span><span class="c1">//   evm.bytecode.generatedSources - 由编译器生成的源码</span>
<span class="w">    </span><span class="c1">//   evm.deployedBytecode* - 部署的字节码（拥有evm.bytecode的所有选项）。</span>
<span class="w">    </span><span class="c1">//   evm.deployedBytecode.immutableReferences - 从AST id到引用不可变的字节码范围的映射</span>
<span class="w">    </span><span class="c1">//   evm.methodIdentifiers - 函数哈希值的列表</span>
<span class="w">    </span><span class="c1">//   evm.gasEstimates - 函数gas估计</span>
<span class="w">    </span><span class="c1">//   ewasm.wast - WebAssembly S-expressions格式的Ewasm</span>
<span class="w">    </span><span class="c1">//   ewasm.wasm - WebAssembly二进制格式的Ewasm</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// 注意，使用 `evm`， `evm.bytecode`， `ewasm` 等将选择该输出的每个目标部分。</span>
<span class="w">    </span><span class="c1">// 此外，`*` 可以作为通配符来请求所有东西。</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="s2">&quot;outputSelection&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;*&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;*&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;evm.bytecode&quot;</span><span class="w"> </span><span class="c1">// 启用每个合约的元数据和字节码输出。</span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;evm.bytecode.sourceMap&quot;</span><span class="w"> </span><span class="c1">// 启用每个合约的源码映射输出。</span>
<span class="w">        </span><span class="p">],</span>
<span class="w">        </span><span class="s2">&quot;&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="s2">&quot;ast&quot;</span><span class="w"> </span><span class="c1">// 启用每个文件的AST输出。</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="c1">// 启用文件def中定义的MyContract的abi和opcodes输出。</span>
<span class="w">      </span><span class="s2">&quot;def&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;MyContract&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;abi&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;evm.bytecode.opcodes&quot;</span><span class="w"> </span><span class="p">]</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// modelChecker对象是实验性的，可能会有变化。</span>
<span class="w">    </span><span class="s2">&quot;modelChecker&quot;</span><span class="o">:</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 选择哪些合约应作为部署的合约进行分析。</span>
<span class="w">      </span><span class="s2">&quot;contracts&quot;</span><span class="o">:</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;source1.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract1&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="s2">&quot;source2.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;contract3&quot;</span><span class="p">]</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="c1">// 选择除法和模数运算的编码方式。</span>
<span class="w">      </span><span class="c1">// 当使用 `false` 时，它们被替换为与松弛变量的乘法。这是默认的。</span>
<span class="w">      </span><span class="c1">// 如果您使用CHC引擎而不使用Spacer作为Horn求解器（例如使用Eldarica），</span>
<span class="w">      </span><span class="c1">// 建议在这里使用 `true`。</span>
<span class="w">      </span><span class="c1">// 关于这个选项的更详细的解释，请参见形式验证部分。</span>
<span class="w">      </span><span class="s2">&quot;divModWithSlacks&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 选择要使用的模型检查器引擎：所有（默认）， bmc， chc， 无。</span>
<span class="w">      </span><span class="s2">&quot;engine&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;chc&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 选择哪些类型的不变性应该报告给用户：合约，重入。</span>
<span class="w">      </span><span class="s2">&quot;invariants&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;reentrancy&quot;</span><span class="p">],</span>
<span class="w">      </span><span class="c1">// 选择是否输出所有未验证的目标。默认为 `false`。</span>
<span class="w">      </span><span class="s2">&quot;showUnproved&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 如果有的话，选择应该使用哪些求解器。</span>
<span class="w">      </span><span class="c1">// 关于求解器的描述，见形式验证部分。</span>
<span class="w">      </span><span class="s2">&quot;solvers&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;cvc4&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;smtlib2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;z3&quot;</span><span class="p">],</span>
<span class="w">      </span><span class="c1">// 选择哪些目标应该被检查：常数条件，下溢，溢出，除以零，余额，断言，弹出空数组，界外。</span>
<span class="w">      </span><span class="c1">// 如果没有给出该选项，所有目标都被默认检查，除了 Solidity &gt;=0.8.7 的下溢/溢出。</span>
<span class="w">      </span><span class="c1">// 目标描述见形式化验证部分。</span>
<span class="w">      </span><span class="s2">&quot;targets&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;underflow&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;overflow&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;assert&quot;</span><span class="p">],</span>
<span class="w">      </span><span class="c1">// 每个SMT查询的超时时间，以毫秒为单位。</span>
<span class="w">      </span><span class="c1">// 如果没有给出这个选项，SMTChecker将默认使用确定性的资源限制。</span>
<span class="w">      </span><span class="c1">// 给定超时为0意味着任何查询都没有资源/时间限制。</span>
<span class="w">      </span><span class="s2">&quot;timeout&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">20000</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id9">
<h4>输出描述<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 可选：如果没有遇到错误/警告/消息，则不存在。</span>
<span class="w">  </span><span class="s2">&quot;errors&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 可选：在源文件中的位置。</span>
<span class="w">      </span><span class="s2">&quot;sourceLocation&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;file&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;sourceFile.sol&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;start&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;end&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">100</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="c1">// 可选：更多的位置（如有冲突的声明的地方）。</span>
<span class="w">      </span><span class="s2">&quot;secondarySourceLocations&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="s2">&quot;file&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;sourceFile.sol&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="s2">&quot;start&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">64</span><span class="p">,</span>
<span class="w">          </span><span class="s2">&quot;end&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">92</span><span class="p">,</span>
<span class="w">          </span><span class="s2">&quot;message&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Other declaration is here:&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">],</span>
<span class="w">      </span><span class="c1">// 强制：错误类型，如 “TypeError“， “InternalCompilerError“， “Exception” 等等。</span>
<span class="w">      </span><span class="c1">// 完整的类型清单见下文。</span>
<span class="w">      </span><span class="s2">&quot;type&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;TypeError&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 强制：发生错误的组件，例如“general”，“ewasm”等</span>
<span class="w">      </span><span class="s2">&quot;component&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;general&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 强制：错误的严重级别（“error”，“warning” 或 “info”，但请注意，这可能在未来被扩展。）</span>
<span class="w">      </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 可选：错误原因的唯一代码</span>
<span class="w">      </span><span class="s2">&quot;errorCode&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;3141&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 强制</span>
<span class="w">      </span><span class="s2">&quot;message&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Invalid keyword&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 可选：带错误源位置的格式化消息</span>
<span class="w">      </span><span class="s2">&quot;formattedMessage&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;sourceFile.sol:100: Invalid keyword&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">],</span>
<span class="w">  </span><span class="c1">// 这包含文件级的输出。</span>
<span class="w">  </span><span class="c1">// 它可以通过outputSelection设置进行限制/过滤。</span>
<span class="w">  </span><span class="s2">&quot;sources&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;sourceFile.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 标识符（用于源码映射）</span>
<span class="w">      </span><span class="s2">&quot;id&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// AST对象</span>
<span class="w">      </span><span class="s2">&quot;ast&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// 这里包含了合约级别的输出。</span>
<span class="w">  </span><span class="c1">// 它可以通过outputSelection设置进行限制/过滤。</span>
<span class="w">  </span><span class="s2">&quot;contracts&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;sourceFile.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 如果使用的语言没有合约名称，则该字段应该留空。</span>
<span class="w">      </span><span class="s2">&quot;ContractName&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 以太坊合约的应用二进制接口（ABI）。如果为空，则表示为空数组。</span>
<span class="w">        </span><span class="c1">// 请参阅 https://docs.soliditylang.org/en/develop/abi-spec.html</span>
<span class="w">        </span><span class="s2">&quot;abi&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">        </span><span class="c1">// 请参阅元数据输出文档（序列化的JSON字符串）</span>
<span class="w">        </span><span class="s2">&quot;metadata&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;{/* ... */}&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 用户文档（natspec）</span>
<span class="w">        </span><span class="s2">&quot;userdoc&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{},</span>
<span class="w">        </span><span class="c1">// 开发人员文档（natspec）</span>
<span class="w">        </span><span class="s2">&quot;devdoc&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{},</span>
<span class="w">        </span><span class="c1">// 中间表示形式 (string)</span>
<span class="w">        </span><span class="s2">&quot;ir&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 请参阅 &quot;存储布局&quot; 文档。</span>
<span class="w">        </span><span class="s2">&quot;storageLayout&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;storage&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="cm">/* ... */</span><span class="p">],</span><span class="w"> </span><span class="s2">&quot;types&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="c1">// EVM相关输出</span>
<span class="w">        </span><span class="s2">&quot;evm&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// 汇编 (string)</span>
<span class="w">          </span><span class="s2">&quot;assembly&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="c1">// 旧风格的汇编 (object)</span>
<span class="w">          </span><span class="s2">&quot;legacyAssembly&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{},</span>
<span class="w">          </span><span class="c1">// 字节码和相关细节</span>
<span class="w">          </span><span class="s2">&quot;bytecode&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 在函数层面上调试数据。</span>
<span class="w">            </span><span class="s2">&quot;functionDebugData&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="c1">// 接下来是一组函数，包括编译器内部的和用户定义的函数。</span>
<span class="w">              </span><span class="c1">// 这组函数不一定是完整的。</span>
<span class="w">              </span><span class="s2">&quot;@mint_13&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 函数的内部名称</span>
<span class="w">                </span><span class="s2">&quot;entryPoint&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">128</span><span class="p">,</span><span class="w"> </span><span class="c1">// 函数开始所在字节码的字节偏移量（可选）</span>
<span class="w">                </span><span class="s2">&quot;id&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">13</span><span class="p">,</span><span class="w"> </span><span class="c1">// 函数定义的AST ID，或者对于编译器内部的函数为空（可选）</span>
<span class="w">                </span><span class="s2">&quot;parameterSlots&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="c1">// 函数参数的EVM堆栈槽的数量（可选）</span>
<span class="w">                </span><span class="s2">&quot;returnSlots&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="c1">// 返回值的EVM堆栈槽的数量（可选）</span>
<span class="w">              </span><span class="p">}</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="c1">// 作为十六进制字符串的字节码。</span>
<span class="w">            </span><span class="s2">&quot;object&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;00fe&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="c1">// 操作码列表（字符串）</span>
<span class="w">            </span><span class="s2">&quot;opcodes&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="c1">// 作为一个字符串的源映射。参见源映射的定义。</span>
<span class="w">            </span><span class="s2">&quot;sourceMap&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="c1">// 由编译器生成的源文件的数组。目前只包含一个Yul文件。</span>
<span class="w">            </span><span class="s2">&quot;generatedSources&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">              </span><span class="c1">// Yul AST</span>
<span class="w">              </span><span class="s2">&quot;ast&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">},</span>
<span class="w">              </span><span class="c1">// 文本形式的源文件（可能包含注释）。</span>
<span class="w">              </span><span class="s2">&quot;contents&quot;</span><span class="o">:</span><span class="s2">&quot;{ function abi_decode(start, end) -&gt; data { data := calldataload(start) } }&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="c1">// 源文件ID，用于源引用，与Solidity源文件相同的 &quot;命名空间&quot;。</span>
<span class="w">              </span><span class="s2">&quot;id&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span>
<span class="w">              </span><span class="s2">&quot;language&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Yul&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;#utility.yul&quot;</span>
<span class="w">            </span><span class="p">}],</span>
<span class="w">            </span><span class="c1">// 如果给定，这就是一个非链接的对象。</span>
<span class="w">            </span><span class="s2">&quot;linkReferences&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="s2">&quot;libraryFile.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 在字节码中的字节偏移量。</span>
<span class="w">                </span><span class="c1">// 链接取代了位于那里的20个字节。</span>
<span class="w">                </span><span class="s2">&quot;Library1&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">                  </span><span class="p">{</span><span class="w"> </span><span class="s2">&quot;start&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;length&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">20</span><span class="w"> </span><span class="p">},</span>
<span class="w">                  </span><span class="p">{</span><span class="w"> </span><span class="s2">&quot;start&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">200</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;length&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">20</span><span class="w"> </span><span class="p">}</span>
<span class="w">                </span><span class="p">]</span>
<span class="w">              </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="s2">&quot;deployedBytecode&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* ..., */</span><span class="w"> </span><span class="c1">// 与上述布局相同。</span>
<span class="w">            </span><span class="s2">&quot;immutableReferences&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="c1">// 有两个对AST ID为3的不可变的引用，都是32字节长。</span>
<span class="w">              </span><span class="c1">// 一个在字节码偏移量42，另一个在字节码偏移量80。</span>
<span class="w">              </span><span class="s2">&quot;3&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="s2">&quot;start&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">42</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;length&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">32</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">&quot;start&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">80</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;length&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">32</span><span class="w"> </span><span class="p">}]</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="c1">// 函数哈希值的列表</span>
<span class="w">          </span><span class="s2">&quot;methodIdentifiers&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;delegate(address)&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;5c19a95c&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="c1">// 函数gas估计</span>
<span class="w">          </span><span class="s2">&quot;gasEstimates&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;creation&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="s2">&quot;codeDepositCost&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;420000&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="s2">&quot;executionCost&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;infinite&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="s2">&quot;totalCost&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;infinite&quot;</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="s2">&quot;external&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="s2">&quot;delegate(address)&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;25000&quot;</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="s2">&quot;internal&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="s2">&quot;heavyLifting()&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;infinite&quot;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="c1">// Ewasm相关的输出</span>
<span class="w">        </span><span class="s2">&quot;ewasm&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// S-expressions格式</span>
<span class="w">          </span><span class="s2">&quot;wast&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="c1">// 二进制格式（十六进制字符串）</span>
<span class="w">          </span><span class="s2">&quot;wasm&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="id10">
<h5>错误类型<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h5>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">JSONError</span></code>： JSON输入不符合所需格式，例如，输入不是JSON对象，不支持的语言等。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOError</span></code>： IO和导入处理错误，例如，在提供的源里包含无法解析的URL或哈希值不匹配。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParserError</span></code>： 源代码不符合语言规则。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DocstringParsingError</span></code>： 注释块中的NatSpec标签无法解析。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>： 语法错误，例如 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 在 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环外部使用。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DeclarationError</span></code>： 无效的，无法解析的或冲突的标识符名称 比如 <code class="docutils literal notranslate"><span class="pre">Identifier</span> <span class="pre">not</span> <span class="pre">found</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TypeError</span></code>： 类型系统内的错误，例如无效类型转换，无效赋值等。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UnimplementedFeatureError</span></code>： 当前编译器不支持该功能，但预计将在未来的版本中支持。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InternalCompilerError</span></code>： 在编译器中触发的内部错误 — 应将此报告为一个issue。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Exception</span></code>： 编译期间的未知失败 — 应将此报告为一个issue。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CompilerError</span></code>： 编译器堆栈的无效使用 — 应将此报告为一个issue。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FatalError</span></code>： 未正确处理致命错误 — 应将此报告为一个issue。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YulException</span></code>： 在Yul代码生成过程中出现错误 - 这应该作为一个问题报告。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Warning</span></code>： 警告，不会停止编译，但应尽可能处理。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Info</span></code>： 编译器认为用户可能会在其中发现有用的信息，并不危险，也不一定需要处理。</p></li>
</ol>
</section>
</section>
</section>
<section id="compiler-tools">
<span id="id11"></span><h3>编译器工具<a class="headerlink" href="#compiler-tools" title="此标题的永久链接"></a></h3>
<section id="solidity">
<h4>Solidity-升级<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">solidity-upgrade</span></code> 可以帮助您半自动地升级您的合约，以适应语言的变化。
虽然它没有也不可能为每一个中断的版本实现所有需要的变化，
但它仍然支持那些需要大量重复性手工调整的版本。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">solidity-upgrade</span></code> 在很大程度上进行了工作，但您的合约很可能需要进一步的手工调整。
我们建议为您的文件使用一个版本控制系统。这有助于审查和最终回滚所做的修改。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><code class="docutils literal notranslate"><span class="pre">solidity-upgrade</span></code> 并不被认为是完整的或没有漏洞的，所以请谨慎使用。</p>
</div>
<section id="id12">
<h5>它是如何工作的<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h5>
<p>您可以将 （一个或多个）Solidity 源文件传递给 <code class="docutils literal notranslate"><span class="pre">solidity-upgrade</span> <span class="pre">[files]</span></code>。
如果这些文件使用了 <code class="docutils literal notranslate"><span class="pre">import</span></code> 语句，指的是当前源文件目录以外的文件，
您需要通过 <code class="docutils literal notranslate"><span class="pre">--allow-paths</span> <span class="pre">[directory]</span></code> 来指定允许读取和导入文件的目录。
您可以通过传递 <code class="docutils literal notranslate"><span class="pre">--ignore-missing</span></code> 来忽略丢失的文件。</p>
<p><code class="docutils literal notranslate"><span class="pre">solidity-upgrade</span></code> 是基于 <code class="docutils literal notranslate"><span class="pre">libsolidity</span></code> 的，
可以解析，编译和分析您的源文件，并可能在其中找到适用的源升级。</p>
<p>源码升级被认为是对您的源代码的轻微的文字修改。
它们被应用于在内存中表示的给定源文件。默认情况下，相应的源文件会被更新，
但您可以通过 <code class="docutils literal notranslate"><span class="pre">--dry-run</span></code> 来模拟整个升级过程，而不写到任何文件中。</p>
<p>升级过程本身有两个阶段。在第一阶段，源文件被解析，
由于不可能在这个层面上升级源代码。错误被收集起来，
可以通过 <code class="docutils literal notranslate"><span class="pre">--verbose</span></code> 来记录。
没有源代码在这一点上可以升级。</p>
<p>在第二阶段，所有的源代码都被编译，
所有激活的升级分析模块都与编译同时运行。默认情况下，所有可用的模块都被激活。
请阅读 <a class="reference internal" href="#upgrade-modules"><span class="std std-ref">可用的模块</span></a> 的文档以了解更多细节。</p>
<p>这可能会导致编译错误，而这些错误可能会被源码升级所修复。
如果没有错误发生，就没有报告源码升级，您就完成了。
如果发生错误，并且一些升级模块报告了源码升级，
那么第一个报告的源码就会被应用，并且对所有给定的源码文件再次触发编译。
只要报告了源码升级，就会重复上一步。
如果仍然发生错误，您可以通过 <code class="docutils literal notranslate"><span class="pre">--verbose</span></code> 来记录它们。
如果没有错误发生，您的合约是最新的，可以用最新版本的编译器进行编译。</p>
</section>
<section id="upgrade-modules">
<span id="id13"></span><h5>可用的升级模块<a class="headerlink" href="#upgrade-modules" title="此标题的永久链接"></a></h5>
<table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 9%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>模块</p></th>
<th class="head"><p>版本</p></th>
<th class="head"><p>说明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">constructor</span></code></p></td>
<td><p>0.5.0</p></td>
<td><p>现在必须使用 <code class="docutils literal notranslate"><span class="pre">constructor</span></code> 关键字
来定义构造器。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">visibility</span></code></p></td>
<td><p>0.5.0</p></td>
<td><p>明确的函数可见性现在是强制的，
默认为 <code class="docutils literal notranslate"><span class="pre">public</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">abstract</span></code></p></td>
<td><p>0.6.0</p></td>
<td><p>如果一个合约没有实现其所有的功能，
就必须使用关键字 <code class="docutils literal notranslate"><span class="pre">abstract</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">virtual</span></code></p></td>
<td><p>0.6.0</p></td>
<td><p>在接口之外没有实现的函数
必须被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">override</span></code></p></td>
<td><p>0.6.0</p></td>
<td><p>当覆盖一个函数或修改器时，
必须使用新的关键字 <code class="docutils literal notranslate"><span class="pre">override</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">dotsyntax</span></code></p></td>
<td><p>0.7.0</p></td>
<td><p>以下语法已被弃用：
<code class="docutils literal notranslate"><span class="pre">f.gas(...)()</span></code>， <code class="docutils literal notranslate"><span class="pre">f.value(...)()</span></code> 和
<code class="docutils literal notranslate"><span class="pre">(new</span> <span class="pre">C).value(...)()</span></code>。
用 <code class="docutils literal notranslate"><span class="pre">f{gas:</span> <span class="pre">...，</span> <span class="pre">value:</span> <span class="pre">...}()</span></code> 和
<code class="docutils literal notranslate"><span class="pre">(new</span> <span class="pre">C){value:</span> <span class="pre">...}()</span></code> 来替代这些方法。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">now</span></code></p></td>
<td><p>0.7.0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">now</span></code> 关键字已被弃用。 Use
使用 <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> 代替。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">constructor-visibility</span></code></p></td>
<td><p>0.7.0</p></td>
<td><p>移除构造函数的可见性。</p></td>
</tr>
</tbody>
</table>
<p>更多详情，请参阅 <a class="reference internal" href="index.html#document-050-breaking-changes"><span class="doc">0.5.0 版本说明</span></a>,
<a class="reference internal" href="index.html#document-060-breaking-changes"><span class="doc">0.6.0 版本说明</span></a>,
<a class="reference internal" href="index.html#document-070-breaking-changes"><span class="doc">0.7.0 版本说明</span></a> 和 <a class="reference internal" href="index.html#document-080-breaking-changes"><span class="doc">0.8.0 版本说明</span></a>。</p>
</section>
<section id="id14">
<h5>简介<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>用法： solidity-upgrade [options] contract.sol

允许的选项：
    --help               显示帮助信息并退出。
    --version            显示版本并退出。
    --allow-paths path(s)
                         允许导入一个给定的路径。
                         可以通过用逗号分隔来提供一个路径列表。
    --ignore-missing     忽略缺失的文件。
    --modules module(s)  只激活一个特定的升级模块。
                         可以用逗号隔开提供一个模块的列表。
    --dry-run            只在内存中应用变化，不写到输入文件。
    --verbose            打印日志、错误和变化。缩短了升级补丁的输出。
    --unsafe             接受 *不安全* 的修改。
</pre></div>
</div>
</section>
<section id="id15">
<h5>错误报告/功能请求<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h5>
<p>如果您发现了一个错误，或者您有一个功能请求，请
<a class="reference external" href="https://github.com/ethereum/solidity/issues/new/choose">在Github上提交一个问题</a>。</p>
</section>
<section id="id16">
<h5>示例<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h5>
<p>假设您在 <code class="docutils literal notranslate"><span class="pre">Source.sol</span></code> 里有以下合约：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=cHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuNi40OwovLyDov5nlnKgwLjcuMOS5i+WQjuWwhuaXoOazlee8luivkeOAggovLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMApjb250cmFjdCBDIHsKICAgIC8vIEZJWE1FOiDnp7vpmaTmnoTpgKDlh73mlbDnmoTlj6/op4HmgKfvvIzlubbkvb/lkIjnuqbmiJDkuLogYWJzdHJhY3Qg5ZCI57qmCiAgICBjb25zdHJ1Y3RvcigpIGludGVybmFsIHt9Cn0KCmNvbnRyYWN0IEQgewogICAgdWludCB0aW1lOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gRklYTUU6IOWwhiBub3cg5pS55oiQIGJsb2NrLnRpbWVzdGFtcAogICAgICAgIHRpbWUgPSBub3c7CiAgICB9Cn0KCmNvbnRyYWN0IEUgewogICAgRCBkOwoKICAgIC8vIEZJWE1FOiDnp7vpmaTmnoTpgKDlh73mlbDnmoTlj6/op4HmgKcKICAgIGNvbnN0cnVjdG9yKCkgcHVibGljIHt9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgLy8gRklYTUU6IOWwhiAudmFsdWUoNSkg5pS55oiQICB7dmFsdWU6IDV9CiAgICAgICAgZC5mLnZhbHVlKDUpKCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">4</span><span class="p">;</span>
<span class="c1">// 这在0.7.0之后将无法编译。</span>
<span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="c1">// FIXME: 移除构造函数的可见性，并使合约成为 abstract 合约</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="k">internal</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">D</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">time</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="c1">// FIXME: 将 now 改成 block.timestamp</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">E</span> <span class="p">{</span>
    <span class="n">D</span> <span class="n">d</span><span class="p">;</span>

    <span class="c1">// FIXME: 移除构造函数的可见性</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="k">public</span> <span class="p">{}</span>

    <span class="kd">function</span> <span class="n">g</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// FIXME: 将 .value(5) 改成  {value: 5}</span>
        <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">5</span><span class="p">)();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="id17">
<h6>必要的改变<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h6>
<p>上述合约从0.7.0开始将不会被编译。为了使合约与当前的 Solidity 版本保持一致，
必须执行以下升级模块。 <code class="docutils literal notranslate"><span class="pre">constructor-visibility</span></code>， <code class="docutils literal notranslate"><span class="pre">now</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dotsyntax</span></code>。
请阅读 <a class="reference internal" href="#upgrade-modules"><span class="std std-ref">可用的模块</span></a> 的文件以了解更多细节。</p>
</section>
<section id="id18">
<h6>运行升级<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h6>
<p>建议通过使用 <code class="docutils literal notranslate"><span class="pre">--modules</span></code> 参数明确指定升级模块。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solidity-upgrade<span class="w"> </span>--modules<span class="w"> </span>constructor-visibility,now,dotsyntax<span class="w"> </span>Source.sol
</pre></div>
</div>
<p>上面的命令应用了如下所示的所有变化。请仔细查看（pragma必须手动更新）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwphYnN0cmFjdCBjb250cmFjdCBDIHsKICAgIC8vIEZJWE1FOiDnp7vpmaTmnoTpgKDlh73mlbDnmoTlj6/op4HmgKfvvIzlubbkvb/lkIjnuqbmiJDkuLogYWJzdHJhY3Qg5ZCI57qmCiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCmNvbnRyYWN0IEQgewogICAgdWludCB0aW1lOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gRklYTUU6IOWwhiBub3cg5pS55oiQIGJsb2NrLnRpbWVzdGFtcAogICAgICAgIHRpbWUgPSBibG9jay50aW1lc3RhbXA7CiAgICB9Cn0KCmNvbnRyYWN0IEUgewogICAgRCBkOwoKICAgIC8vIEZJWE1FOiDnp7vpmaTmnoTpgKDlh73mlbDnmoTlj6/op4HmgKcKICAgIGNvbnN0cnVjdG9yKCkge30KCiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICAvLyBGSVhNRTog5bCGIC52YWx1ZSg1KSDmlLnmiJAgIHt2YWx1ZTogNX0KICAgICAgICBkLmZ7dmFsdWU6IDV9KCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.7</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.9</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="k">abstract</span> <span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="c1">// FIXME: 移除构造函数的可见性，并使合约成为 abstract 合约</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">D</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">time</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="c1">// FIXME: 将 now 改成 block.timestamp</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">block.timestamp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">E</span> <span class="p">{</span>
    <span class="n">D</span> <span class="n">d</span><span class="p">;</span>

    <span class="c1">// FIXME: 移除构造函数的可见性</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kd">function</span> <span class="n">g</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// FIXME: 将 .value(5) 改成  {value: 5}</span>
        <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">{</span><span class="n">value</span><span class="o">:</span> <span class="mi">5</span><span class="p">}();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
</section>
<span id="document-analysing-compilation-output"></span><section id="index-0">
<span id="id1"></span><h2>分析编译器的输出结果<a class="headerlink" href="#index-0" title="此标题的永久链接"></a></h2>
<p>看一下编译器生成的汇编代码往往是有用的。生成的二进制文件，
即 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--bin</span> <span class="pre">contract.sol</span></code> 的输出，通常很难阅读。
建议使用标志 <code class="docutils literal notranslate"><span class="pre">--asm</span></code> 来分析汇编输出。
即使是很大的合约，看一下改变前后的汇编结果的差异，往往是很有启发的。</p>
<p>以下合约（命名为 <code class="docutils literal notranslate"><span class="pre">contract.sol</span></code> ）为例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG9uZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gMTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.9</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">one</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下是 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--asm</span> <span class="pre">contract.sol</span></code> 的输出</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>======= contract.sol:C =======
EVM assembly:
    /* &quot;contract.sol&quot;:0:86  contract C {... */
  mstore(0x40, 0x80)
  callvalue
  dup1
  iszero
  tag_1
  jumpi
  0x00
  dup1
  revert
tag_1:
  pop
  dataSize(sub_0)
  dup1
  dataOffset(sub_0)
  0x00
  codecopy
  0x00
  return
stop

sub_0: assembly {
        /* &quot;contract.sol&quot;:0:86  contract C {... */
      mstore(0x40, 0x80)
      callvalue
      dup1
      iszero
      tag_1
      jumpi
      0x00
      dup1
      revert
    tag_1:
      pop
      jumpi(tag_2, lt(calldatasize, 0x04))
      shr(0xe0, calldataload(0x00))
      dup1
      0x901717d1
      eq
      tag_3
      jumpi
    tag_2:
      0x00
      dup1
      revert
        /* &quot;contract.sol&quot;:17:84  function one() public pure returns (uint) {... */
    tag_3:
      tag_4
      tag_5
      jump  // in
    tag_4:
      mload(0x40)
      tag_6
      swap2
      swap1
      tag_7
      jump  // in
    tag_6:
      mload(0x40)
      dup1
      swap2
      sub
      swap1
      return
    tag_5:
        /* &quot;contract.sol&quot;:53:57  uint */
      0x00
        /* &quot;contract.sol&quot;:76:77  1 */
      0x01
        /* &quot;contract.sol&quot;:69:77  return 1 */
      swap1
      pop
        /* &quot;contract.sol&quot;:17:84  function one() public pure returns (uint) {... */
      swap1
      jump  // out
        /* &quot;#utility.yul&quot;:7:125   */
    tag_10:
        /* &quot;#utility.yul&quot;:94:118   */
      tag_12
        /* &quot;#utility.yul&quot;:112:117   */
      dup2
        /* &quot;#utility.yul&quot;:94:118   */
      tag_13
      jump  // in
    tag_12:
        /* &quot;#utility.yul&quot;:89:92   */
      dup3
        /* &quot;#utility.yul&quot;:82:119   */
      mstore
        /* &quot;#utility.yul&quot;:72:125   */
      pop
      pop
      jump  // out
        /* &quot;#utility.yul&quot;:131:353   */
    tag_7:
      0x00
        /* &quot;#utility.yul&quot;:262:264   */
      0x20
        /* &quot;#utility.yul&quot;:251:260   */
      dup3
        /* &quot;#utility.yul&quot;:247:265   */
      add
        /* &quot;#utility.yul&quot;:239:265   */
      swap1
      pop
        /* &quot;#utility.yul&quot;:275:346   */
      tag_15
        /* &quot;#utility.yul&quot;:343:344   */
      0x00
        /* &quot;#utility.yul&quot;:332:341   */
      dup4
        /* &quot;#utility.yul&quot;:328:345   */
      add
        /* &quot;#utility.yul&quot;:319:325   */
      dup5
        /* &quot;#utility.yul&quot;:275:346   */
      tag_10
      jump  // in
    tag_15:
        /* &quot;#utility.yul&quot;:229:353   */
      swap3
      swap2
      pop
      pop
      jump  // out
        /* &quot;#utility.yul&quot;:359:436   */
    tag_13:
      0x00
        /* &quot;#utility.yul&quot;:425:430   */
      dup2
        /* &quot;#utility.yul&quot;:414:430   */
      swap1
      pop
        /* &quot;#utility.yul&quot;:404:436   */
      swap2
      swap1
      pop
      jump  // out

    auxdata: 0xa2646970667358221220a5874f19737ddd4c5d77ace1619e5160c67b3d4bedac75fce908fed32d98899864736f6c637827302e382e342d646576656c6f702e323032312e332e33302b636f6d6d69742e65613065363933380058
}
</pre></div>
</div>
<p>另外，上述输出也可以从 <a class="reference external" href="https://remix.ethereum.org/">Remix</a> ，
在编译合约后的 &quot;编译细节&quot; 选项下获得。</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">asm</span></code> 输出以创建/构造器代码开始。
部署代码是作为子对象的一部分提供的（在上面的例子中，它是子对象 <code class="docutils literal notranslate"><span class="pre">sub_0</span></code> 的一部分）。
<code class="docutils literal notranslate"><span class="pre">auxdata</span></code> 字段对应于合约 <a class="reference internal" href="index.html#encoding-of-the-metadata-hash-in-the-bytecode"><span class="std std-ref">元数据</span></a> 。
汇编输出中的注释指向源文件的位置。注意 <code class="docutils literal notranslate"><span class="pre">#utility.yul</span></code> 是一个内部生成的实用函数文件，
可以使用标志 <code class="docutils literal notranslate"><span class="pre">--combined-json</span> <span class="pre">generated-sources,generated-sources-runtime</span></code> 获得。</p>
<p>类似地，可以通过 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--optimize</span> <span class="pre">--asm</span> <span class="pre">contract.sol</span></code> 命令获得优化后的程序集。
通常情况下，观察两个不同的Solidity源是否会产生相同的优化代码是很有趣的。
例如，查看表达式 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">*</span> <span class="pre">b)</span> <span class="pre">/</span> <span class="pre">c</span></code>， <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">/</span> <span class="pre">c</span></code> 是否生成相同的字节码。
在可能的话，在剥离引用源位置的注释之后，通过获取相应程序集输出的 <code class="docutils literal notranslate"><span class="pre">diff</span></code> 很容易做到这一点。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">--asm</span></code> 的输出不是设计成机器可读的。因此，在solc的各个小版本之间，输出可能会有重大的变化。</p>
</div>
</section>
<span id="document-ir-breaking-changes"></span><section id="solidity-codegen">
<span id="ir-breaking-changes"></span><h2>基于 Solidity 中间表征的 Codegen 变化<a class="headerlink" href="#solidity-codegen" title="此标题的永久链接"></a></h2>
<p>Solidity 可以通过两种不同的方式生成 EVM 字节码：
要么直接从 Solidity 到 EVM 操作码（“旧编码”），
要么通过在 Yul 中的中间表示法（“IR”）（“新编码” 或 “基于IR的编码”）。</p>
<p>引入基于 IR 的代码生成器的目的是，不仅使代码生成更加透明和可审计，
而且能够实现更强大的跨函数的优化通道。</p>
<p>您可以在命令行中使用 <code class="docutils literal notranslate"><span class="pre">--via-ir</span></code>
或在 standard-json 中使用 <code class="docutils literal notranslate"><span class="pre">{&quot;viaIR&quot;:</span> <span class="pre">true}</span></code> 选项来启用它，
我们鼓励大家尝试一下！</p>
<p>由于一些原因，旧的和基于 IR 的代码生成器之间存在着微小的语义差异，
主要是在那些我们无论如何也不会期望人们依赖这种行为的领域。
本节强调了旧的和基于IR的代码生成器之间的主要区别。</p>
<section id="id1">
<h3>仅有语义上的变化<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h3>
<p>本节列出了仅有语义的变化，从而有可能在现有的代码中隐藏新的和不同的行为。</p>
<ul>
<li><p>在继承的情况下，状态变量初始化的顺序已经改变。</p>
<p>以前的顺序是：</p>
<ul class="simple">
<li><p>所有的状态变量在开始时都被零初始化。</p></li>
<li><p>从最终派生合约到最基础的合约评估基础构造函数参数。</p></li>
<li><p>从最基础的继承关系到最终派生的继承关系初始化整个继承层次结构中的所有状态变量。</p></li>
<li><p>如果存在，在线性化层次结构中从最基础的合约到最终派生的合约依次运行构造函数。</p></li>
</ul>
<p>新的顺序：</p>
<ul class="simple">
<li><p>所有的状态变量在开始时都被零初始化。</p></li>
<li><p>从最终派生合约到最基础的合约评估基础构造函数参数。</p></li>
<li><p>对于每一个合约，按照从最基础到最终派生的合约的线性化层次结构的顺序执行：</p>
<ol class="arabic simple">
<li><p>初始化状态变量。</p></li>
<li><p>运行构造函数（如果存在）。</p></li>
</ol>
</li>
</ul>
<p>这导致了合约中的差异，即一个状态变量的初始值依赖于另一个合约中构造函数的结果：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjE7Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgeDsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIHggPSA0MjsKICAgIH0KICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQpjb250cmFjdCBCIGlzIEEgewogICAgdWludCBwdWJsaWMgeSA9IGYoKTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以前， <code class="docutils literal notranslate"><span class="pre">y</span></code> 会被设置为0。这是由于我们会先初始化状态变量：首先， <code class="docutils literal notranslate"><span class="pre">x</span></code> 被设置为0，当初始化 <code class="docutils literal notranslate"><span class="pre">y</span></code> 时， <code class="docutils literal notranslate"><span class="pre">f()</span></code> 将返回0，导致 <code class="docutils literal notranslate"><span class="pre">y</span></code> 也为0。
在新的规则下， <code class="docutils literal notranslate"><span class="pre">y</span></code> 将被设置为42。我们首先将 <code class="docutils literal notranslate"><span class="pre">x</span></code> 初始化为0，然后调用 A 的构造函数，将 <code class="docutils literal notranslate"><span class="pre">x</span></code> 设置为42。最后，在初始化 <code class="docutils literal notranslate"><span class="pre">y</span></code> 时， <code class="docutils literal notranslate"><span class="pre">f()</span></code> 返回42，导致 <code class="docutils literal notranslate"><span class="pre">y</span></code> 为42。</p>
</li>
<li><p>当存储结构被删除时，包含该结构成员的每个存储槽都被完全设置为零。
以前，填充空间是不被触动的。
因此，如果结构中的填充空间被用来存储数据（例如在合约升级的背景下），
您必须注意， <code class="docutils literal notranslate"><span class="pre">delete</span></code> 现在也会清除添加的成员（而在过去不会被清除）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjE7Cgpjb250cmFjdCBDIHsKICAgIHN0cnVjdCBTIHsKICAgICAgICB1aW50NjQgeTsKICAgICAgICB1aW50NjQgejsKICAgIH0KICAgIFMgczsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIC4uLgogICAgICAgIGRlbGV0ZSBzOwogICAgICAgIC8vIHPlj6rljaDnlKjkuoYzMuS4quWtl+iKguanveeahOWJjTE25Liq5a2X6IqCCiAgICAgICAgLy8gZGVsZXRlIOWwhuaKiumbtuWGmeWIsOWujOaVtOeahOaPkuanveS4rQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint64</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint64</span><span class="w"> </span><span class="nv">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>S<span class="w"> </span>s<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span>delete<span class="w"> </span>s<span class="p">;</span>
<span class="w">        </span><span class="c1">// s只占用了32个字节槽的前16个字节</span>
<span class="w">        </span><span class="c1">// delete 将把零写到完整的插槽中</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们对隐式删除也有同样的行为，例如当结构体的数组被缩短时。</p>
</li>
<li><p>关于函数参数和返回变量，函数修改器的实现方式略有不同。
如果占位符 <code class="docutils literal notranslate"><span class="pre">_;</span></code> 在一个修饰符中被多次使用，这尤其有影响。
在旧的代码生成器中，每个函数参数和返回变量在堆栈中都有一个固定的槽。
如果因为多次使用 <code class="docutils literal notranslate"><span class="pre">_;</span></code> 而使函数运行多次，或者在一个循环中使用，
那么函数参数或返回变量的值的变化在函数的下一次执行中是可见的。
新的代码生成器使用实际的函数来实现修改器，并将函数参数传递下去。
这意味着对一个函数主体的多次使用将得到相同的参数值，而对返回变量的影响是，
它们在每次执行时都被重置为其默认值（零）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjA7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHB1YmxpYyBwdXJlIG1vZCgpIHJldHVybnMgKHVpbnQgcikgewogICAgICAgIHIgPSBhKys7CiAgICB9CiAgICBtb2RpZmllciBtb2QoKSB7IF87IF87IH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>mod<span class="p">()</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>mod<span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>_<span class="p">;</span><span class="w"> </span>_<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您在旧的代码生成器中执行 <code class="docutils literal notranslate"><span class="pre">f(0)</span></code>，它将返回 <code class="docutils literal notranslate"><span class="pre">2</span></code>，
而在使用新的代码生成器时，它将返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBib29sIGFjdGl2ZSA9IHRydWU7CiAgICBtb2RpZmllciBtb2QoKQogICAgewogICAgICAgIF87CiAgICAgICAgYWN0aXZlID0gZmFsc2U7CiAgICAgICAgXzsKICAgIH0KICAgIGZ1bmN0aW9uIGZvbygpIGV4dGVybmFsIG1vZCgpIHJldHVybnMgKHVpbnQgcmV0KQogICAgewogICAgICAgIGlmIChhY3RpdmUpCiAgICAgICAgICAgIHJldCA9IDE7IC8vIOS4jiBgYHJldHVybiAxYGAg55u45ZCMCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nv">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>mod<span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">        </span>active<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>mod<span class="p">()</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>active<span class="p">)</span>
<span class="w">            </span>ret<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 与 ``return 1`` 相同</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">C.foo()</span></code> 返回以下值：</p>
<ul class="simple">
<li><p>旧的代码生成器： <code class="docutils literal notranslate"><span class="pre">1</span></code> 作为返回变量在第一次 <code class="docutils literal notranslate"><span class="pre">_;</span></code> 使用前只被初始化为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，
然后被 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">1;</span></code> 覆盖。在第二次 <code class="docutils literal notranslate"><span class="pre">_;</span></code> 使用时，它没有被再次初始化，
而且 <code class="docutils literal notranslate"><span class="pre">foo()</span></code> 也没有明确地分配给它（由于 <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">==</span> <span class="pre">false</span></code>），因此它保持了它的第一个值。</p></li>
<li><p>新的代码生成器： <code class="docutils literal notranslate"><span class="pre">0</span></code> 作为所有参数，包括返回参数，将在每次 <code class="docutils literal notranslate"><span class="pre">_;</span></code> 使用前被重新初始化。</p></li>
</ul>
</li>
<li id="index-0"><p>对于旧的代码生成器，表达式的评估顺序是没有规定的。
对于新的代码生成器，我们试图按照源顺序（从左到右）进行评估，但并不保证这一点。
这可能会导致语义上的差异。</p>
<p>例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gcHJlaW5jcl91OCh1aW50OCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50OCkgewogICAgICAgIHJldHVybiArK2EgKyBhOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.1</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">preincr_u8</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="o">++</span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>a<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">preincr_u8(1)</span></code> 返回以下值：</p>
<ul class="simple">
<li><p>旧的代码生成器：3 ( <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> )，但一般情况下返回值是不指定的</p></li>
<li><p>新的代码生成器：4 ( <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">2</span></code> )，但不能保证返回值</p></li>
</ul>
<p id="index-1">另一方面，除了全局函数 <code class="docutils literal notranslate"><span class="pre">addmod</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mulmod</span></code> 外，两个代码生成器对函数参数表达式的评估顺序是一样的。
例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gYWRkKHVpbnQ4IGEsIHVpbnQ4IGIpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4KSB7CiAgICAgICAgcmV0dXJuIGEgKyBiOwogICAgfQogICAgZnVuY3Rpb24gZyh1aW50OCBhLCB1aW50OCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50OCkgewogICAgICAgIHJldHVybiBhZGQoKythICsgKytiLCBhICsgYik7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.1</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">add</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>add<span class="p">(</span><span class="o">++</span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">++</span>b<span class="p">,</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">g(1,</span> <span class="pre">2)</span></code> 返回以下值：</p>
<ul class="simple">
<li><p>旧的代码生成器： <code class="docutils literal notranslate"><span class="pre">10</span></code> ( <code class="docutils literal notranslate"><span class="pre">add(2+3,</span> <span class="pre">2+3)</span></code> )，但返回值一般不指定。</p></li>
<li><p>新的代码生成器： <code class="docutils literal notranslate"><span class="pre">10</span></code>，但不能保证返回值</p></li>
</ul>
<p>全局函数 <code class="docutils literal notranslate"><span class="pre">addmod</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mulmod</span></code> 的参数由旧代码生成器从右向左评估，新代码生成器从左向右评估。
例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNTYgYU1vZCwgdWludDI1NiBtTW9kKSB7CiAgICAgICAgdWludDI1NiB4ID0gMzsKICAgICAgICAvLyDml6fnmoTku6PnoIHnlJ/miJDlmajvvJogYWRkL211bG1vZCg1LCA0LCAzKQogICAgICAgIC8vIOaWsOeahOS7o+eggeeUn+aIkOWZqO+8miBhZGQvbXVsbW9kKDQsIDUsIDUpCiAgICAgICAgYU1vZCA9IGFkZG1vZCgrK3gsICsreCwgeCk7CiAgICAgICAgbU1vZCA9IG11bG1vZCgrK3gsICsreCwgeCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.1</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">aMod</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">mMod</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 旧的代码生成器： add/mulmod(5, 4, 3)</span>
<span class="w">        </span><span class="c1">// 新的代码生成器： add/mulmod(4, 5, 5)</span>
<span class="w">        </span>aMod<span class="w"> </span><span class="o">=</span><span class="w"> </span>addmod<span class="p">(</span><span class="o">++</span>x<span class="p">,</span><span class="w"> </span><span class="o">++</span>x<span class="p">,</span><span class="w"> </span>x<span class="p">);</span>
<span class="w">        </span>mMod<span class="w"> </span><span class="o">=</span><span class="w"> </span>mulmod<span class="p">(</span><span class="o">++</span>x<span class="p">,</span><span class="w"> </span><span class="o">++</span>x<span class="p">,</span><span class="w"> </span>x<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">f()</span></code> 返回以下值：</p>
<ul class="simple">
<li><p>旧的代码生成器： <code class="docutils literal notranslate"><span class="pre">aMod</span> <span class="pre">=</span> <span class="pre">0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mMod</span> <span class="pre">=</span> <span class="pre">2</span></code></p></li>
<li><p>新的代码生成器： <code class="docutils literal notranslate"><span class="pre">aMod</span> <span class="pre">=</span> <span class="pre">4</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mMod</span> <span class="pre">=</span> <span class="pre">0</span></code></p></li>
</ul>
</li>
<li><p>新的代码生成器对自由内存指针施加了一个硬性限制 <code class="docutils literal notranslate"><span class="pre">type(uint64).max</span></code>
（ <code class="docutils literal notranslate"><span class="pre">0xffffffffffffffff</span></code>）。其增加值超过这个限制的分配会被恢复。
旧的代码生成器没有这个限制。</p>
<p>例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID4wLjguMDsKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICB1aW50W10gbWVtb3J5IGFycjsKICAgICAgICAvLyDliIbphY3nqbrpl7TvvJogNTc2NDYwNzUyMzAzNDIzNDgxCiAgICAgICAgLy8g5YGH6K6+ZnJlZU1lbVB0cuacgOWIneaMh+WQkTB4ODAKICAgICAgICB1aW50IHNvbFl1bE1heEFsbG9jYXRpb25CZWZvcmVNZW1QdHJPdmVyZmxvdyA9ICh0eXBlKHVpbnQ2NCkubWF4IC0gMHg4MCAtIDMxKSAvIDMyOwogICAgICAgIC8vIGZyZWVNZW1QdHIg5ZugIFVJTlQ2NF9NQVgg6ZmQ5Yi25rqi5Ye6CiAgICAgICAgYXJyID0gbmV3IHVpbnRbXShzb2xZdWxNYXhBbGxvY2F0aW9uQmVmb3JlTWVtUHRyT3ZlcmZsb3cpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="err">&gt;0.8.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>arr<span class="p">;</span>
<span class="w">        </span><span class="c1">// 分配空间： 576460752303423481</span>
<span class="w">        </span><span class="c1">// 假设freeMemPtr最初指向0x80</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">solYulMaxAllocationBeforeMemPtrOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>type<span class="p">(</span><span class="kt">uint64</span><span class="p">).</span>max<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">31</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">32</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// freeMemPtr 因 UINT64_MAX 限制溢出</span>
<span class="w">        </span>arr<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>solYulMaxAllocationBeforeMemPtrOverflow<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <cite>f()</cite> 的作用如下：</p>
<ul class="simple">
<li><p>旧的代码生成器：在大内存分配后对数组内容进行清零时耗尽了gas</p></li>
<li><p>新的代码生成器：由于自由内存指针溢出而还原（不会耗尽gas）。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id2">
<h3>内部结构<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<section id="id3">
<h4>内部函数指针<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<p id="index-2">旧的代码生成器对内部函数指针的值使用代码偏移量或标签。
这一点特别复杂，因为这些偏移量在构造时和部署后是不同的，而且这些值可以通过存储跨越这个边界。
正因为如此，这两个偏移量在构造时被编码为同一个值（进入不同的字节）。</p>
<p>在新的代码生成器中，函数指针使用依次分配的内部ID。
由于通过跳转的调用是不可能的，通过函数指针的调用总是要使用内部调度函数，
使用 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句来选择正确的函数。</p>
<p>ID <code class="docutils literal notranslate"><span class="pre">0</span></code> 是为未初始化的函数指针保留的，这些指针在被调用时，会引起调度函数的panic错误。</p>
<p>在旧的代码生成器中，内部函数指针是用一个特殊的函数初始化的，它总是引起panic错误。
这导致在构造时对存储中的内部函数指针进行存储写入。</p>
</section>
<section id="id4">
<h4>清理<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p id="index-3">旧的代码生成器只在操作前执行清理，而操作的结果可能会受到脏位值的影响。
新的代码生成器在任何可能导致脏位的操作之后执行清理。
我们希望优化器能够强大到足以消除多余的清理操作。</p>
<p>例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50OCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHIxLCB1aW50IHIyKQogICAgewogICAgICAgIGEgPSB+YTsKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIHIxIDo9IGEKICAgICAgICB9CiAgICAgICAgcjIgPSBhOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.1</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">r2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span>a<span class="p">;</span>
<span class="w">        </span>assembly<span class="w"> </span><span class="p">{</span>
<span class="w">            </span>r1<span class="w"> </span><span class="o">:=</span><span class="w"> </span>a
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span>r2<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">f(1)</span></code> 返回以下值：</p>
<ul class="simple">
<li><p>旧的代码生成器：（ <code class="docutils literal notranslate"><span class="pre">fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe</span></code>, <code class="docutils literal notranslate"><span class="pre">00000000000000000000000000000000000000000000000000000000000000fe</span></code>）</p></li>
<li><p>新的代码生成器：（ <code class="docutils literal notranslate"><span class="pre">00000000000000000000000000000000000000000000000000000000000000fe</span></code>, <code class="docutils literal notranslate"><span class="pre">00000000000000000000000000000000000000000000000000000000000000fe</span></code>）</p></li>
</ul>
<p>请注意，与新的代码生成器不同，旧的代码生成器在位取反赋值（ <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">~a</span></code> ）后没有进行清理。
这导致新旧代码生成器之间对返回值 <code class="docutils literal notranslate"><span class="pre">r1</span></code> 的赋值（在内联汇编块内）不同。
然而，两个代码生成器在 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的新值被分配到 <code class="docutils literal notranslate"><span class="pre">r2</span></code> 之前都进行了清理。</p>
</section>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-internals/layout_in_storage"></span><section id="index-0">
<span id="id1"></span><h2>存储中的状态变量储存结构<a class="headerlink" href="#index-0" title="此标题的永久链接"></a></h2>
<p id="storage-inplace-encoding">合约的状态变量以一种紧凑的方式存储，
这样多个值有时会使用同一个存储槽。
除了动态大小的数组和映射（见下文）之外，
数据是被逐项存储的，从第一个状态变量开始，
它被存储在槽 <code class="docutils literal notranslate"><span class="pre">0</span></code> 中。对于每个变量，
根据它的类型确定一个字节的大小。如果可能的话，需要少于32字节的多个连续项目被打包到一个存储槽中，
根据以下规则：</p>
<ul class="simple">
<li><p>存储插槽的第一项会以低位对齐（即右对齐）的方式储存。</p></li>
<li><p>值类型只使用存储它们所需的字节数。</p></li>
<li><p>如果一个值类型不适合一个存储槽的剩余部分，它将被存储在下一个存储槽。</p></li>
<li><p>结构和数组数据总是从一个新的存储槽开始，它们的项根据这些规则被紧密地打包。</p></li>
<li><p>结构或数组数据之后的变量总是开辟一个新的存储槽。</p></li>
</ul>
<p>对于使用继承的合约，状态变量的排序是从最基础的合约开始，由合约的C3线性化顺序决定的。
如果上述规则允许，来自不同合约的状态变量确实共享同一个存储槽。</p>
<p>结构体和数组中的元素都是顺序存储的，就像它们被明确给定的那样。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>当使用小于32字节的元素时，您的合约的气体用量可能会更高。
这是因为EVM每次对32字节进行操作。因此，如果元素小于这个大小，
EVM必须使用更多的操作，以便将元素的大小从32字节减少到所需的大小。</p>
<p>如果您处理的是存储值，使用缩小尺寸的类型可能是有益的，
因为编译器会将多个元素打包到一个存储槽中，
从而将多个读或写合并到一个操作中。
如果您不是在同一时间读取或写入一个槽中的所有值，
这可能会产生相反的效果，虽然。当一个值被写入一个多值存储槽时，
该存储槽必须先被读取，
然后与新值结合，这样同一槽中的其他数据就不会被破坏。</p>
<p>在处理函数参数或内存值时，因为编译器不会打包这些值，所以没有什么好处，</p>
<p>最后，为了让EVM对此进行优化，
确保您的存储变量和 <code class="docutils literal notranslate"><span class="pre">struct</span></code> 成员的顺序，使它们能够被紧密地包装起来。
例如，按照 <code class="docutils literal notranslate"><span class="pre">uint128,</span> <span class="pre">uint128,</span> <span class="pre">uint256</span></code> 的顺序声明您的存储变量，
而不是 <code class="docutils literal notranslate"><span class="pre">uint128,</span> <span class="pre">uint256,</span> <span class="pre">uint128</span></code>，因为前者只占用两个存储槽，
而后者则占用三个存储槽。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于存储指针可以传递给库，存储中的状态变量的结构被认为是 Solidity 外部接口的一部分。
这意味着对这一节中概述的规则的任何改变都被认为是对语言的重大改变，
由于它的关键性质，在执行之前应该非常仔细地考虑。
在发生这种重大变化的情况下，我们希望发布一种兼容模式，
在这种模式下，编译器将生成支持旧结构的字节码。</p>
</div>
<section id="id2">
<h3>映射和动态数组<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p id="storage-hashed-encoding">由于映射和动态数组的大小是不可预知的，他们不能被存储在其前后的状态变量之间。
相反，它们被认为只占用32个字节， 与 <a class="reference internal" href="#storage-inplace-encoding"><span class="std std-ref">上述规则</span></a> 有关，
它们所包含的元素被存储在一个不同的存储槽，该存储槽是用Keccak-256哈希计算的。</p>
<p>假设映射或数组的存储位置在适应了 <a class="reference internal" href="#storage-inplace-encoding"><span class="std std-ref">存储结构规则</span></a> 后，最终位于一个槽 <code class="docutils literal notranslate"><span class="pre">p</span></code>。
对于动态数组，这个槽存储了数组中的元素数量
（字节数组和字符串是一个例外，参见 <a class="reference internal" href="#bytes-and-string"><span class="std std-ref">下文</span></a>）。
对于映射来说，这个槽保持空的状态，
但是仍然需要它来确保即使有两个映射相邻，它们的内容最终也是在不同的存储位置。</p>
<p>数组数据从 <code class="docutils literal notranslate"><span class="pre">keccak256(p)</span></code> 开始，它的排列方式与静态大小的阵列数据相同：
一个元素接着一个元素，如果元素的长度不超过16字节，
就有可能共享存储槽。包含动态数组的动态数组递归地应用这一规则。
元素 <code class="docutils literal notranslate"><span class="pre">x[i][j]</span></code> 的位置为，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint24[][]</span></code> ，
计算方法如下（同样，假设 <code class="docutils literal notranslate"><span class="pre">x</span></code> 本身存储在槽 <code class="docutils literal notranslate"><span class="pre">p</span></code>）：
槽是 <code class="docutils literal notranslate"><span class="pre">keccak256(keccak256(p)+i)+</span> <span class="pre">floor(j</span> <span class="pre">/</span> <span class="pre">floor(256</span> <span class="pre">/</span> <span class="pre">24))</span></code>，
元素可以从槽数据 <code class="docutils literal notranslate"><span class="pre">v</span></code> 得到，使用 <code class="docutils literal notranslate"><span class="pre">(v</span> <span class="pre">&gt;&gt;</span> <span class="pre">((j</span> <span class="pre">%</span> <span class="pre">floor(256</span> <span class="pre">/</span> <span class="pre">24))</span> <span class="pre">*</span> <span class="pre">24))</span> <span class="pre">&amp;</span> <span class="pre">type(uint24).max</span></code>。</p>
<p>对应于映射键 <code class="docutils literal notranslate"><span class="pre">k</span></code> 的值位于 <code class="docutils literal notranslate"><span class="pre">keccak256(h(k)</span> <span class="pre">.</span> <span class="pre">p)</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">.</span></code> 是连接符， <code class="docutils literal notranslate"><span class="pre">h</span></code> 是一个函数，根据键的类型应用于键。</p>
<ul class="simple">
<li><p>对于值类型， 函数 <code class="docutils literal notranslate"><span class="pre">h</span></code> 将与在内存中存储值的相同方式来将值填充为32字节。</p></li>
<li><p>对于字符串和字节数组， <code class="docutils literal notranslate"><span class="pre">h(k)</span></code> 只是未填充的数据。</p></li>
</ul>
<p>如果映射类型的值是一个非值类型，则计算的槽会标记为数据的开始位置。
例如，如果值是结构体类型，您必须添加一个与结构体成员相对应的偏移量才能访问到该成员。</p>
<p>作为示例，参考以下合约：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKCmNvbnRyYWN0IEMgewogICAgc3RydWN0IFMgeyB1aW50MTYgYTsgdWludDE2IGI7IHVpbnQyNTYgYzsgfQogICAgdWludCB4OwogICAgbWFwcGluZyh1aW50ID0+IG1hcHBpbmcodWludCA9PiBTKSkgZGF0YTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint16</span><span class="w"> </span><span class="nv">a</span><span class="p">;</span><span class="w"> </span><span class="kt">uint16</span><span class="w"> </span><span class="nv">b</span><span class="p">;</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">c</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>S<span class="p">))</span><span class="w"> </span>data<span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>让我们计算一下 <code class="docutils literal notranslate"><span class="pre">data[4][9].c</span></code> 的存储位置。
映射本身的位置是 <code class="docutils literal notranslate"><span class="pre">1</span></code> （变量 <code class="docutils literal notranslate"><span class="pre">x</span></code> 前面有32字节）。
这意味着 <code class="docutils literal notranslate"><span class="pre">data[4]</span></code> 存储在 <code class="docutils literal notranslate"><span class="pre">keccak256(uint256(4)</span> <span class="pre">.</span> <span class="pre">uint256(1))</span></code>。
<code class="docutils literal notranslate"><span class="pre">data[4]</span></code> 的类型还是一个映射，
<code class="docutils literal notranslate"><span class="pre">data[4][9]</span></code> 的数据从 <code class="docutils literal notranslate"><span class="pre">keccak256(uint256(9)</span> <span class="pre">.</span> <span class="pre">keccak256(uint256(4)</span> <span class="pre">.</span> <span class="pre">uint256(1)))</span></code> 槽开始。
成员 <code class="docutils literal notranslate"><span class="pre">c</span></code> 在结构 <code class="docutils literal notranslate"><span class="pre">S</span></code> 中的槽位偏移是 <code class="docutils literal notranslate"><span class="pre">1</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 被装在一个槽位中。
这意味着 <code class="docutils literal notranslate"><span class="pre">data[4][9].c</span></code> 的插槽是 <code class="docutils literal notranslate"><span class="pre">keccak256(uint256(9)</span> <span class="pre">.</span> <span class="pre">keccak256(uint256(4)</span> <span class="pre">.</span> <span class="pre">uint256(1)))</span> <span class="pre">+</span> <span class="pre">1</span></code>。
该值的类型是 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>，所以它占用一个槽。</p>
<section id="bytes-string">
<span id="bytes-and-string"></span><h4><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code><a class="headerlink" href="#bytes-string" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 的编码是相同的。
一般来说，编码与 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 类似，即有一个槽用于存放数组本身和一个数据区，
这个数据区是用该槽的位置的 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 哈希值计算的。
然而，对于较短的值（短于32字节），数组元素与长度一起存储在同一个槽中。</p>
<p>特别是：如果数据最多只有 <code class="docutils literal notranslate"><span class="pre">31</span></code> 字节长，
元素被存储在高阶字节中（左对齐），最低阶字节存储值 <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">*</span> <span class="pre">2</span></code>。
对于存储数据长度为 <code class="docutils literal notranslate"><span class="pre">32</span></code> 或更多字节的字节数，主槽 <code class="docutils literal notranslate"><span class="pre">p</span></code> 存储 <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code>，
数据照常存储在 <code class="docutils literal notranslate"><span class="pre">keccak256(p)</span></code>。这意味着您可以通过检查最低位是否被设置来区分短数组和长数组：
短数组（未设置）和长数组（设置）。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>目前不支持处理无效编码的槽，但将来可能会加入。
如果您通过 IR 进行编译，读取一个无效编码的槽会导致 <code class="docutils literal notranslate"><span class="pre">Panic(0x22)</span></code> 错误。</p>
</div>
</section>
</section>
<section id="json">
<h3>JSON输出<a class="headerlink" href="#json" title="此标题的永久链接"></a></h3>
<p id="storage-layout-top-level">合约的存储结构可以通过 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准的JSON接口</span></a> 请求获得。
输出的是一个JSON对象，包含两个键， <code class="docutils literal notranslate"><span class="pre">storage</span></code> 和 <code class="docutils literal notranslate"><span class="pre">types</span></code>。
<code class="docutils literal notranslate"><span class="pre">storage</span></code> 对象是一个数组，每个元素都有以下形式：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint256&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的例子来自源于项目 <code class="docutils literal notranslate"><span class="pre">fileA</span></code> 的 <code class="docutils literal notranslate"><span class="pre">contract</span> <span class="pre">A</span> <span class="pre">{</span> <span class="pre">uint</span> <span class="pre">x;</span> <span class="pre">}</span></code> 的存储结构，并且</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">astId</span></code> 是状态变量声明的AST节点的ID</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">contract</span></code> 是合约的名称，包括其路径作为前缀</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">label</span></code> 是状态变量的名称</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code> 是根据编码在存储槽中的字节偏移量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> 是状态变量所在或开始的存储槽。这个数字可能非常大，因此它的JSON值被表示为一个字符串</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code> 是一个标识符，作为变量类型信息的关键（如下所述）</p></li>
</ul>
<p>给定的 <code class="docutils literal notranslate"><span class="pre">type</span></code>，在这里是 <code class="docutils literal notranslate"><span class="pre">t_uint256</span></code>，代表 <code class="docutils literal notranslate"><span class="pre">types</span></code> 中的一个元素，它的形式是：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encoding</span></code> 数据在存储中是如何编码的，可能的值是：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">inplace</span></code>： 数据在存储中是连续布置的（参见 <a class="reference internal" href="#storage-inplace-encoding"><span class="std std-ref">上文</span></a>）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapping</span></code>： 基于Keccak-256的哈希方法（参见 <a class="reference internal" href="#storage-hashed-encoding"><span class="std std-ref">上文</span></a>）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dynamic_array</span></code>： 基于Keccak-256的哈希方法（参见 <a class="reference internal" href="#storage-hashed-encoding"><span class="std std-ref">上文</span></a>）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bytes</span></code>： 单槽或基于Keccak-256哈希值，取决于数据大小（参见 <a class="reference internal" href="#bytes-and-string"><span class="std std-ref">上文</span></a>）。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">label</span></code> 是典型的类型名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numberOfBytes</span></code> 是使用的字节数（十进制字符串）。
注意，如果 <code class="docutils literal notranslate"><span class="pre">numberOfBytes</span> <span class="pre">&gt;</span> <span class="pre">32</span></code> 这意味着使用了一个以上的槽。</p></li>
</ul>
<p>除了上述四种类型外，有些类型还有额外的信息。
映射包含它的 <code class="docutils literal notranslate"><span class="pre">key</span></code> 和 <code class="docutils literal notranslate"><span class="pre">value</span></code> 类型（再次引用这个类型映射中的一个项），
数组有它的 <code class="docutils literal notranslate"><span class="pre">base</span></code> 类型，结构体会列出它们的 <code class="docutils literal notranslate"><span class="pre">成员</span></code>，
其格式与高层次的 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 相同（参见 <a class="reference internal" href="#storage-layout-top-level"><span class="std std-ref">上文</span></a>）。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>合约的存储结构的JSON输出格式仍被认为是实验性的，并且在Solidity的非重大版本中会有变化。</p>
</div>
<p>下面的例子显示了一个合约及其存储结构，包含值类型和引用类型，被编码打包的类型，以及嵌套的类型。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKICAgIHN0cnVjdCBTIHsKICAgICAgICB1aW50MTI4IGE7CiAgICAgICAgdWludDEyOCBiOwogICAgICAgIHVpbnRbMl0gc3RhdGljQXJyYXk7CiAgICAgICAgdWludFtdIGR5bkFycmF5OwogICAgfQoKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIFMgczsKICAgIGFkZHJlc3MgYWRkcjsKICAgIG1hcHBpbmcgKHVpbnQgPT4gbWFwcGluZyAoYWRkcmVzcyA9PiBib29sKSkgbWFwOwogICAgdWludFtdIGFycmF5OwogICAgc3RyaW5nIHMxOwogICAgYnl0ZXMgYjE7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint128</span><span class="w"> </span><span class="nv">a</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint128</span><span class="w"> </span><span class="nv">b</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span>staticArray<span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>dynArray<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span>
<span class="w">    </span>S<span class="w"> </span>s<span class="p">;</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">))</span><span class="w"> </span>map<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>array<span class="p">;</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="nv">s1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">b1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;storage&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint256&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint256&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;s&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_struct(S)13_storage&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;addr&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;6&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_address&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">28</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;map&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;7&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_mapping(t_uint256,t_mapping(t_address,t_bool))&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">31</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;array&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;8&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_array(t_uint256)dyn_storage&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">33</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;s1&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;9&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_string_storage&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;10&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_bytes_storage&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;types&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;t_address&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;address&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;20&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_array(t_uint256)2_storage&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;base&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint256&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256[2]&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;64&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_array(t_uint256)dyn_storage&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;base&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint256&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;dynamic_array&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256[]&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_bool&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_bytes_storage&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_mapping(t_address,t_bool)&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mapping&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_address&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mapping(address =&gt; bool)&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_bool&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_mapping(t_uint256,t_mapping(t_address,t_bool))&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mapping&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint256&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mapping(uint256 =&gt; mapping(address =&gt; bool))&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_mapping(t_address,t_bool)&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_string_storage&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_struct(S)13_storage&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;struct A.S&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;members&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint128&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_uint128&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;staticArray&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_array(t_uint256)2_storage&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;astId&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;contract&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;fileA:A&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;dynArray&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;slot&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;3&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t_array(t_uint256)dyn_storage&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">],</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;128&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_uint128&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint128&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;16&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;t_uint256&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;encoding&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;numberOfBytes&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;32&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<span id="document-internals/layout_in_memory"></span><section id="id1">
<h2>内存中的存储结构<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>Solidity保留了四个32字节的插槽，具体的字节范围（包括端点）使用如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x00</span></code> - <code class="docutils literal notranslate"><span class="pre">0x3f</span></code> （64字节）： 用于哈希方法的临时空间</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x40</span></code> - <code class="docutils literal notranslate"><span class="pre">0x5f</span></code> （32字节）： 当前分配的内存大小（又称空闲内存指针）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x60</span></code> - <code class="docutils literal notranslate"><span class="pre">0x7f</span></code> （32字节）： 0 值插槽</p></li>
</ul>
<p>临时空间可以在语句之间使用（即在内联汇编之中）。
0 值插槽则用来对动态内存数组进行初始化，且永远不会写入数据
（因而可用的初始内存指针为 <code class="docutils literal notranslate"><span class="pre">0x80</span></code>）。</p>
<p>Solidity 总会把新对象保存在空闲内存指针的位置，
所以这段内存实际上从来不会空闲（在未来可能会修改这个机制）。</p>
<p>Solidity中内存数组中的元素总是占据32字节的倍数
（对于 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 来说也是如此，但对于 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 来说不是这样）。
多维内存数组是指向内存数组的指针. 一个动态数组的长度被存储在数组的第一个槽里，后面是数组元素。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在Solidity中，有一些操作需要一个大于64字节的临时内存区域，
因此将不适合放在默认的临时空间中。它们将被放置在空闲内存指向的位置，
但由于这种数据的生命周期较短，这个指针不会即时更新。
这部分内存可能会被清零也可能不会。
所以我们不应该期望这些所谓的空闲内存总会被清零。</p>
<p>虽然使用 <code class="docutils literal notranslate"><span class="pre">msize</span></code> 来到达一个绝对清零的内存区域似乎是个好主意，
但在不更新空闲内存指针的情况下，非临时性地使用这样的指针会产生意想不到的结果。</p>
</div>
<section id="id2">
<h3>与存储结构的区别<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>如上所述，内存中的存储结构与 <a class="reference internal" href="index.html#storage-inplace-encoding"><span class="std std-ref">存储（storage）</span></a> 中的存储结构是不同的。
下面是一些例子。</p>
<section id="id3">
<h4>在数组中的差异的例子<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<p>下面的数组在存储中占用32字节（1个槽），但在内存中占用128字节（4项，每个32字节）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDhbNF0gYTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="p">[</span><span class="m m-Decimal">4</span><span class="p">]</span><span class="w"> </span>a<span class="p">;</span>
</pre></div>
</div>
</section>
<section id="id4">
<h4>在结构体中存储结构差异的例子<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p>以下结构体在存储中占用96字节（3个32字节的槽），
但在内存中占用128字节（4项，每个32字节）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=c3RydWN0IFMgewogICAgdWludCBhOwogICAgdWludCBiOwogICAgdWludDggYzsKICAgIHVpbnQ4IGQ7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">struct</span><span class="w"> </span><span class="nv">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">c</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<span id="document-internals/layout_in_calldata"></span><section id="id1">
<h2>调用数据的存储结构<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>一个函数调用的输入数据的格式被认为会遵循 <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI规范</span></a> 所定义的格式。
其中，ABI规范要求参数被填充为32字节的倍数。而内部函数调用会使用不同规则。</p>
<p>合约的构造函数的参数直接附加在合约的字节码末尾，
也是ABI编码的。构造函数将通过一个硬编码的偏移量来访问它们，
而不是通过使用 <code class="docutils literal notranslate"><span class="pre">codesize</span></code> 操作码，因为在向代码追加数据时它会发生改变。</p>
</section>
<span id="document-internals/variable_cleanup"></span><section id="id1">
<h2>清理变量<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>如果一个数值不足 256 位，那么在某些情况下，剩余的位必须被清理。
Solidity 编译器被设计为在执行任何操作之前清除这些剩余位中可能会造成不利影响的潜在垃圾。
例如，在将一个值写入内存之前，剩余的位需要被清除，因为内存的内容可以被用来计算哈希值或作为消息调用的数据发送。
同样地，在将一个值保存到存储中之前，剩余的位需要被清理，否则就会看到被混淆的数值。</p>
<p>注意，通过内联汇编的访问不被认为是这种操作。
如果您使用内联汇编来访问短于256位的Solidity变量，编译器不保证该值被正确清理。</p>
<p>此外，如果接下来的操作不受影响，我们就不清理这些位。
例如，由于任何非零值都被 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> 指令认为是 <code class="docutils literal notranslate"><span class="pre">true</span></code>，
所以在布尔值被用作 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> 的条件之前，我们不对它们进行清理。</p>
<p>除了上面的设计原则外，Solidity编译器在输入数据被加载到堆栈时也会对其进行清理。</p>
<p>不同的类型有不同的规则来清理无效的值：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>类型</p></th>
<th class="head"><p>有效的值</p></th>
<th class="head"><p>无效的值会导致</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>n 个成员的枚举</p></td>
<td><p>0 到 n - 1</p></td>
<td><p>异常报错（exception）</p></td>
</tr>
<tr class="row-odd"><td><p>布尔</p></td>
<td><p>0 或 1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>有符号整数</p></td>
<td><p>以符号开头的字</p></td>
<td><p>目前会直接打包；未来会抛出异常</p></td>
</tr>
<tr class="row-odd"><td><p>无符号整数</p></td>
<td><p>高位补 0</p></td>
<td><p>目前会直接打包；未来会抛出异常</p></td>
</tr>
</tbody>
</table>
</section>
<span id="document-internals/source_mappings"></span><section id="index-0">
<span id="id1"></span><h2>源代码映射<a class="headerlink" href="#index-0" title="此标题的永久链接"></a></h2>
<p>作为AST输出的一部分，编译器提供了AST中相应节点所代表的源代码的范围。
这可以用于各种目的，包括基于AST报告错误的静态分析工具和突出局部变量及其用途的调试工具。</p>
<p>此外，编译器还可以生成从字节码到生成该指令的源代码范围的映射。
这对于在字节码层次上操作的静态分析工具和在调试器中显示源代码中的当前位置或断点处理来说，
也是很重要的。这个映射还包含其他信息，如跳转类型和修改器深度（见下文）。</p>
<p>这两种源码映射都使用整数标识符来指代源码文件。源文件的标识符存储在 <code class="docutils literal notranslate"><span class="pre">output['sources'][sourceName]['id']</span></code> 中，
其中 <code class="docutils literal notranslate"><span class="pre">output</span></code> 是标准json编译器接口的输出，被解析成JSON。
对于一些实用程序，编译器会生成 &quot;内部&quot; 源文件，
这些文件不是原始输入的一部分，而是从源映射中引用的。
这些源文件及其标识符可以通过 <code class="docutils literal notranslate"><span class="pre">output['contracts'][sourceName][contractName]['evm']['bytecode']['generatedSources']</span></code> 获得。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果指令没有与任何特定的源文件相关联，源映射将分配一个整数标识符 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。
这可能发生在编译器生成的内联汇编语句所产生的字节码部分。</p>
</div>
<p>AST内部的源映射使用以下符号：</p>
<p><code class="docutils literal notranslate"><span class="pre">s:l:f</span></code></p>
<p>其中， <code class="docutils literal notranslate"><span class="pre">s</span></code> 是源代码文件中范围起始处的字节偏移量，
<code class="docutils literal notranslate"><span class="pre">l</span></code> 是以字节为单位的源代码范围的长度， <code class="docutils literal notranslate"><span class="pre">f</span></code> 是上述源代码索引。</p>
<p>源码映射中的字节码的编码更为复杂。它是一个由 <code class="docutils literal notranslate"><span class="pre">s:l:f:j:m</span></code> 组成的列表，用 <code class="docutils literal notranslate"><span class="pre">;</span></code> 分隔。
这些元素中的每一个都对应着一条指令，也就是说，您不能使用字节偏移量，
而必须使用指令偏移量（推送指令比单个字节长）。字段  <code class="docutils literal notranslate"><span class="pre">s</span></code> ， <code class="docutils literal notranslate"><span class="pre">l</span></code> 和 <code class="docutils literal notranslate"><span class="pre">f</span></code> 同上。
<code class="docutils literal notranslate"><span class="pre">j</span></code> 可以是 <code class="docutils literal notranslate"><span class="pre">i</span></code>,  <code class="docutils literal notranslate"><span class="pre">o</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code>，表示跳转指令是进入一个函数，
从一个函数返回，还是作为一个循环的一部分的普通跳转。
最后一个字段， <code class="docutils literal notranslate"><span class="pre">m</span></code>，是一个整数，表示 &quot;修改器深度&quot;。
当占位符语句( <code class="docutils literal notranslate"><span class="pre">_</span></code> )进入修改器时，这个深度会增加，当它再次离开时，深度会减少。
这使得调试器可以跟踪一些棘手的情况，如同一个修改器被使用两次，或在一个修改器中使用多个占位符语句。</p>
<p>为了压缩这些源码映射，特别是字节码的源码映射，使用了以下规则：</p>
<ul class="simple">
<li><p>如果一个字段为空，则使用前一个元素的值。</p></li>
<li><p>如果缺少 <code class="docutils literal notranslate"><span class="pre">:</span></code> ，以下所有字段都被认为是空的。</p></li>
</ul>
<p>这意味着下面的源码映射代表了相同的信息：</p>
<p><code class="docutils literal notranslate"><span class="pre">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">1:2:1;:9;2:1:2;;</span></code></p>
<p>需要注意的是，当使用 <a class="reference internal" href="index.html#yul-verbatim"><span class="std std-ref">逐字（verbatim）</span></a> 内建程序时，
源码映射将是无效的。内建程序被认为是一条指令，而不是潜在的多条指令。</p>
</section>
<span id="document-internals/optimizer"></span><section id="optimizer">
<span id="index-0"></span><span id="id1"></span><h2>优化器<a class="headerlink" href="#optimizer" title="此标题的永久链接"></a></h2>
<p>Solidity编译器使用两种不同的优化器模块。在操作码水平上操作的 &quot;旧&quot; 优化器
和在 Yul IR 代码上操作的 “新” 优化器。</p>
<p>基于操作码的优化器对操作码应用一套 <a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/libevmasm/RuleList.h">简化规则</a>。
它还结合了相等的代码集并删除了未使用的代码。</p>
<p>基于Yul的优化器要强大得多，因为它可以跨函数调用工作。
例如，任意跳转在Yul中是不可能的，
所以有可能计算每个函数的副作用。假设有两个函数调用，
其中第一个不修改存储，第二个修改存储。
如果它们的参数和返回值不相互依赖，我们就可以对函数调用重新排序。
同样地，如果一个函数是没有副作用的，而且其结果是乘以0的，就可以完全删除该函数调用。</p>
<p>目前，参数 <code class="docutils literal notranslate"><span class="pre">--optimize</span></code> 会为生成的字节码激活基于操作码的优化器，
并为内部生成的 Yul 代码激活 Yul 优化器，例如当使用 ABI coder v2 时。
您可以使用 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--ir</span> <span class="pre">optimized</span> <span class="pre">--optimize</span></code> 来为 Solidity 源码产生一个优化的 Yul IR。
同样地，您可以使用 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--strict-assembly</span> <span class="pre">--optimize</span></code> 来产生一个独立的 Yul 模式。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Peephole_optimization">窥视孔（peephole）优化器</a>
和内联器总是默认启用的，只能通过 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准 JSON 文件配置</span></a> 关闭。</p>
</div>
<p>您可以在下面找到关于这两个优化器模块及其优化步骤的更多细节。</p>
<section id="solidity">
<h3>优化Solidity代码的好处<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h3>
<p>总的来说，优化器试图简化复杂的表达式，从而减少代码大小和执行成本，
也就是说，它可以减少部署合约以及对合约进行外部调用所需的气体。
它还会对函数进行专业化或内联化优化。特别是当函数内联一个可能导致更大的代码操作时，
它经常这样做，因为这导致了更多简化的机会。</p>
</section>
<section id="id3">
<h3>优化和非优化代码之间的差异<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>一般来说，最明显的区别是常量表达式在编译时被评估。
当涉及到ASM输出时，人们也可以注意到等价或重复的代码块的减少（比较 <code class="docutils literal notranslate"><span class="pre">--asm</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--asm</span> <span class="pre">--optimize</span></code> 标志的输出）。
然而，当涉及到Yul/中间代表时，可能会有明显的差异，
例如，函数可能被内联，合并或重写以消除冗余等等（比较带有 <code class="docutils literal notranslate"><span class="pre">--ir</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--optimize</span> <span class="pre">--ir-optimized</span></code> 标志的输出）。</p>
</section>
<section id="optimizer-parameter-runs">
<span id="id4"></span><h3>优化器参数运行<a class="headerlink" href="#optimizer-parameter-runs" title="此标题的永久链接"></a></h3>
<p>运行次数（ <code class="docutils literal notranslate"><span class="pre">--optimize-runs</span></code> ）大致规定了在合约有效期内，
所部署的代码的每个操作码被执行的频率。
这意味着它是代码大小（部署成本）和代码执行成本（部署后的成本）之间的一个折衷参数。
一个 “运行” 参数为 “1” 将产生简短的合约但昂贵的执行代码。相反，
一个较大的 “运行” 参数将产生较大的合约但更省气体的执行代码。
该参数的最大值为 <code class="docutils literal notranslate"><span class="pre">2**32-1</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>一个常见的误解是，这个参数指定了优化器的迭代次数。这是不正确的。
优化器将始终运行尽可能多的次数来改进代码。</p>
</div>
</section>
<section id="id5">
<h3>基于操作码的优化器模块<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>基于操作码的优化器模块对汇编代码进行操作。
它在 <code class="docutils literal notranslate"><span class="pre">JUMPs</span></code> 和 <code class="docutils literal notranslate"><span class="pre">JUMPDESTs</span></code> 之间将指令序列分成基本块。
在这些块中，优化器分析指令，并将对堆栈、内存或存储的每一次修改记录为一个表达式，
该表达式由一条指令和一列参数组成，这些参数是指向其他表达式的指针。</p>
<p>此外，基于操作码的优化器使用了一个名为 “通用子表达式消除器” 的组件，
它除其他任务外，还能找到总是相等的表达式（在每个输入上），
并将它们合并为一个表达式类。它首先尝试在一个已经知道的表达式列表中找到每个新的表达式。
如果没有找到这样的匹配，
它就根据 <code class="docutils literal notranslate"><span class="pre">constant</span> <span class="pre">+</span> <span class="pre">constant</span> <span class="pre">=</span> <span class="pre">sum_of_constants</span></code> 或 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">X</span></code> 这样的规则简化表达式。
由于这是一个递归过程，如果第二个因素是一个更复杂的表达式，并且知道这个表达式的值总是为1，我们也可以应用后一个规则。</p>
<p>某些优化器步骤象征性地跟踪存储和内存位置。例如，
这些信息被用来计算Keccak-256哈希值，可以在编译时进行评估。
考虑一下这个序列：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PUSH 32
PUSH 0
CALLDATALOAD
PUSH 100
DUP2
MSTORE
KECCAK256
</pre></div>
</div>
<p>或着等同于Yul为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCmxldCB2YWx1ZSA6PSBrZWNjYWsyNTYoeCwgMzIp"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">mstore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="ow">let</span> <span class="nv">value</span> <span class="o">:=</span> <span class="nf">keccak256</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>在这种情况下，优化器跟踪位于内存位置 <code class="docutils literal notranslate"><span class="pre">calldataload(0)</span></code> 的值，
然后意识到Keccak-256哈希值可以在编译时被评估。
这只有在 <code class="docutils literal notranslate"><span class="pre">mstore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 之间没有其他指令修改内存时才有效。
因此，如果有一条指令写到内存（或存储），那么我们需要擦除对当前内存（或存储）的记忆。
然而，这种擦除有一个例外，当我们可以很容易地看到指令没有写到某个位置。</p>
<p>示例，</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCi8vIOW3suefpeW9k+WJjeWGheWtmOS9jee9rnggLT4gMTAwCmxldCB5IDo9IGFkZCh4LCAzMikKLy8g5rKh5pyJ5riF6ZmkIHggLT4gMTAwIOeahOiusOW/hu+8jOWboOS4unnlubbmsqHmnInlhpnliLBbeO+8jHgrMzLvvInjgIIKbXN0b3JlKHksIDIwMCkKLy8g546w5Zyo5Y+v5Lul5a+56L+Z5LiqS2VjY2FrLTI1Nui/m+ihjOiuoeeul+S6hgpsZXQgdmFsdWUgOj0ga2VjY2FrMjU2KHgsIDMyKQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">mstore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1">// 已知当前内存位置x -&gt; 100</span>
<span class="ow">let</span> <span class="nv">y</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="c1">// 没有清除 x -&gt; 100 的记忆，因为y并没有写到[x，x+32）。</span>
<span class="nf">mstore</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="c1">// 现在可以对这个Keccak-256进行计算了</span>
<span class="ow">let</span> <span class="nv">value</span> <span class="o">:=</span> <span class="nf">keccak256</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>因此，对存储和内存位置的修改，比如说位置 <code class="docutils literal notranslate"><span class="pre">l</span></code>，
必须擦除关于可能等于 <code class="docutils literal notranslate"><span class="pre">l</span></code> 的存储或内存位置的记忆。更具体地说，
对于存储，优化器必须删除所有可能等于 <code class="docutils literal notranslate"><span class="pre">l</span></code> 的符号位置的记忆，
对于内存，优化器必须删除所有可能不超过32字节的符号位置的记忆。
如果 <code class="docutils literal notranslate"><span class="pre">m</span></code> 表示一个任意的位置，那么这个擦除的决定是通过计算 <code class="docutils literal notranslate"><span class="pre">sub(l,</span> <span class="pre">m)</span></code> 的值来完成。
对于存储，如果这个值被评估为一个非零的值，那么关于 <code class="docutils literal notranslate"><span class="pre">m</span></code> 的记忆将被保留。
对于内存，如果这个值被评估为一个介于 <code class="docutils literal notranslate"><span class="pre">32</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2**256</span> <span class="pre">-</span> <span class="pre">32</span></code> 之间的值，那么关于 <code class="docutils literal notranslate"><span class="pre">m</span></code> 的记忆将被保留。
在所有其他情况下，关于 <code class="docutils literal notranslate"><span class="pre">m</span></code> 的记忆将被删除。</p>
<p>并且有一个对内存和存储的修改列表。
这些信息与基本代码块一起存储并用来链接它们。此外，
关于堆栈、存储和内存配置的记忆被转发给下一个（几个）块。</p>
<p>如果我们知道所有 <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 和 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> 指令的目标，
我们就可以构建一个完整的程序流程图。
如果只有一个我们不知道的目标（原则上可能发生，跳转目标可以基于输入来计算），
我们必须消除关于代码块输入状态的所有信息，因为它可能是未知的 <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 目标。
如果一个 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> 的条件等于一个常量，它将被转换为无条件跳转。</p>
<p>作为最后一步，每个块中的代码都会被完全重新生成。
然后优化器会从代码块的结尾处在栈上的表达式开始创建依赖关系图，
且不是该图组成部分的每个操作都会被丢弃。
这样生成的代码将按照原始代码中的顺序对内存和存储进行修改（舍弃不需要的修改）。
最后，它生成了所有需要在堆栈中的正确位置的值。</p>
<p>这些步骤适用于每个基本代码块，如果代码块较小，则新生成的代码将用作替换。
如果一个基本代码块在 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> 处被分割，且在分析过程中被评估为一个常数，
则会根据常量的值来替换 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code>，因此，类似于</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludCB4ID0gNzsKZGF0YVs3XSA9IDk7CmlmIChkYXRhW3hdICE9IHggKyAyKSAvLyDov5nkuKrmnaHku7bmsLjov5zkuI3kvJrmmK/nnJ/nmoQKICByZXR1cm4gMjsKZWxzZQogIHJldHVybiAxOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">;</span>
data<span class="p">[</span><span class="m m-Decimal">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">9</span><span class="p">;</span>
<span class="kt">if</span><span class="w"> </span><span class="p">(</span>data<span class="p">[</span>x<span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">)</span><span class="w"> </span><span class="c1">// 这个条件永远不会是真的</span>
<span class="w">  </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="kt">else</span>
<span class="w">  </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
</pre></div>
</div>
<p>简化为这样：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZGF0YVs3XSA9IDk7CnJldHVybiAxOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>data<span class="p">[</span><span class="m m-Decimal">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">9</span><span class="p">;</span>
<span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
</pre></div>
</div>
<section id="id6">
<h4>简单内联<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<p>从Solidity 0.8.2版本开始，有另一个优化步骤，
它用这些指令的拷贝来替换某些包含以 “跳转” 结束的 “简单” 指令的块的跳转。
这相当于对简单的、小的Solidity或Yul函数进行内联。特别是，
<code class="docutils literal notranslate"><span class="pre">PUSHTAG(tag)</span> <span class="pre">JUMP</span></code> 序列可以被替换，只要 <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 被标记为 &quot;进入&quot; 一个函数的跳转，
并且在 <code class="docutils literal notranslate"><span class="pre">tag</span></code> 后面有一个基本块（如上面描述的 “通用子表达式消除器”），
它以另一个 <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 结束，被标记为 “离开” 一个函数的跳转。</p>
<p>特别是，考虑以下为调用内部Solidity函数而生成的汇编的原型例子:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  tag_return
  tag_f
  jump      // 从此进入
tag_return:
  ...opcodes after call to f...

tag_f:
  ...body of function f...
  jump      // 从此退出
</pre></div>
</div>
<p>只要函数的主体是一个连续的基本块，“内联” 就可以用位于 <code class="docutils literal notranslate"><span class="pre">tag_f</span></code> 处的块来代替 <code class="docutils literal notranslate"><span class="pre">tag_f</span> <span class="pre">jump</span></code> ，结果是：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  tag_return
  ...body of function f...
  jump
tag_return:
  ...opcodes after call to f...

tag_f:
  ...body of function f...
  jump      // 从此退出
</pre></div>
</div>
<p>现在，理想情况下，上述的其他优化器步骤将导致返回标签的推送被移向剩余的跳转，从而导致：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  ...body of function f...
  tag_return
  jump
tag_return:
  ...opcodes after call to f...

tag_f:
  ...body of function f...
  jump      // 从此退出
</pre></div>
</div>
<p>在这种情况下，“窥视孔优化器（PeepholeOptimizer）” 将删除返回跳转。理想情况下，
所有对 <code class="docutils literal notranslate"><span class="pre">tag_f</span></code> 的引用都可以这样做，而不使用它，特别处理的话，它也可以被移除：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...body of function f...
...opcodes after call to f...
</pre></div>
</div>
<p>因此，对函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的调用是内联的，可以删除 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的原始定义。</p>
<p>无论何时，只要启发式算法表明，在合同的生命周期内，内联比不内联更便宜，就会尝试这样的内联。
这种启发式方法取决于函数体的大小、对其标记的其他引用的数量（近似于函数调用的数量）
以及合约的预期执行次数（全局优化器参数 &quot;runs&quot;）。</p>
</section>
</section>
<section id="yul">
<h3>基于Yul的优化器模块<a class="headerlink" href="#yul" title="此标题的永久链接"></a></h3>
<p>基于Yul的优化器由几个阶段和组件组成，它们都以语义等效的方式转换AST。
我们的目标是，最终的代码要么更短，要么至少略长，但允许进一步的优化步骤。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>由于优化器正在进行大量开发，这里的信息可能已经过时。
如果您依赖某项功能，请直接联系团队。</p>
</div>
<p>优化器目前遵循的是一种纯粹的贪婪策略，不做任何回溯。</p>
<p>下面将解释基于Yul的优化器模块的所有组件。
以下的转换步骤是主要的组成部分：</p>
<ul class="simple">
<li><p>SSA转换</p></li>
<li><p>通用子表达式消除器</p></li>
<li><p>表达式简化器</p></li>
<li><p>冗余赋值消除器</p></li>
<li><p>完全内联</p></li>
</ul>
<section id="id7">
<h4>优化器的步骤<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>这是按字母顺序排列的基于Yul的优化器的所有步骤的列表。
您可以在下面找到更多关于各个步骤和它们的顺序的信息。</p>
<ul class="simple">
<li><p><a class="reference internal" href="#block-flattener"><span class="std std-ref">块展平器</span></a>.</p></li>
<li><p><a class="reference internal" href="#circular-reference-pruner"><span class="std std-ref">循环引用程序</span></a>.</p></li>
<li><p><a class="reference internal" href="#common-subexpression-eliminator"><span class="std std-ref">通用子表达式消除器</span></a>.</p></li>
<li><p><a class="reference internal" href="#conditional-simplifier"><span class="std std-ref">条件简化器</span></a>.</p></li>
<li><p><a class="reference internal" href="#conditional-unsimplifier"><span class="std std-ref">有条件的非对称性放大器</span></a>.</p></li>
<li><p><a class="reference internal" href="#control-flow-simplifier"><span class="std std-ref">控制流简化器</span></a>.</p></li>
<li><p><a class="reference internal" href="#dead-code-eliminator"><span class="std std-ref">死代码消除器</span></a>.</p></li>
<li><p><a class="reference internal" href="#equal-store-eliminator"><span class="std std-ref">等价的存储清除器</span></a>.</p></li>
<li><p><a class="reference internal" href="#equivalent-function-combiner"><span class="std std-ref">等价函数组合器</span></a>.</p></li>
<li><p><a class="reference internal" href="#expression-joiner"><span class="std std-ref">表达式连接器</span></a>.</p></li>
<li><p><a class="reference internal" href="#expression-simplifier"><span class="std std-ref">表达式简化器</span></a>.</p></li>
<li><p><a class="reference internal" href="#expression-splitter"><span class="std std-ref">表达式拆分器</span></a>.</p></li>
<li><p><a class="reference internal" href="#for-loop-condition-into-body"><span class="std std-ref">循环条件进入正文</span></a>.</p></li>
<li><p><a class="reference internal" href="#for-loop-condition-out-of-body"><span class="std std-ref">体外循环条件</span></a>.</p></li>
<li><p><a class="reference internal" href="#for-loop-init-rewriter"><span class="std std-ref">循环初始重写器</span></a>.</p></li>
<li><p><a class="reference internal" href="#expression-inliner"><span class="std std-ref">表达式内联</span></a>.</p></li>
<li><p><a class="reference internal" href="#full-inliner"><span class="std std-ref">完全内联</span></a>.</p></li>
<li><p><a class="reference internal" href="#function-grouper"><span class="std std-ref">函数分组器</span></a>.</p></li>
<li><p><a class="reference internal" href="#function-hoister"><span class="std std-ref">函数提升器</span></a>.</p></li>
<li><p><a class="reference internal" href="#function-specializer"><span class="std std-ref">函数特殊化器</span></a>.</p></li>
<li><p><a class="reference internal" href="#literal-rematerialiser"><span class="std std-ref">字面意义上的再物质化器（LiteralRematerialiser）</span></a>.</p></li>
<li><p><a class="reference internal" href="#load-resolver"><span class="std std-ref">负载解析器</span></a>.</p></li>
<li><p><a class="reference internal" href="#loop-invariant-code-motion"><span class="std std-ref">循环不变代码模式</span></a>.</p></li>
<li><p><a class="reference internal" href="#redundant-assign-eliminator"><span class="std std-ref">冗余赋值消除器</span></a>.</p></li>
<li><p><a class="reference internal" href="#reasoning-based-simplifier"><span class="std std-ref">基于推理的简化器</span></a>.</p></li>
<li><p><a class="reference internal" href="#rematerialiser"><span class="std std-ref">再物质化</span></a>.</p></li>
<li><p><a class="reference internal" href="#ssa-reverser"><span class="std std-ref">SSA反转器</span></a>.</p></li>
<li><p><a class="reference internal" href="#ssa-transform"><span class="std std-ref">SSA转换</span></a>.</p></li>
<li><p><a class="reference internal" href="#structural-simplifier"><span class="std std-ref">结构简化器</span></a>.</p></li>
<li><p><a class="reference internal" href="#unused-function-parameter-pruner"><span class="std std-ref">未使用的函数参数管理器</span></a>.</p></li>
<li><p><a class="reference internal" href="#unused-pruner"><span class="std std-ref">未使用过的处理器</span></a>.</p></li>
<li><p><a class="reference internal" href="#var-decl-initializer"><span class="std std-ref">初始化程序</span></a>.</p></li>
</ul>
</section>
<section id="id8">
<h4>选择优化方案<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>默认情况下，优化器对生成的程序集应用其预定义的优化步骤序列。
您可以使用 <code class="docutils literal notranslate"><span class="pre">yul-optimizations</span></code> 选项覆盖这个序列并提供您自己的序列：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>--optimize<span class="w"> </span>--ir-optimized<span class="w"> </span>--yul-optimizations<span class="w"> </span><span class="s1">&#39;dhfoD[xarrscLMcCTU]uljmul&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[...]</span></code> 里面的序列将被循环应用多次，直到Yul代码保持不变或达到最大轮数（目前为12）。</p>
<p>可用的缩写列在 <a class="reference external" href="optimization-step-sequence">Yul 优化器文档</a> 中。</p>
</section>
<section id="id10">
<h4>预处理<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h4>
<p>预处理组件进行转换，使程序变成某种更容易操作的正常形式。
这种正常形式在剩下的优化过程中被保留。</p>
<section id="disambiguator">
<span id="id11"></span><h5>消歧器<a class="headerlink" href="#disambiguator" title="此标题的永久链接"></a></h5>
<p>消歧器获取AST并返回一个新拷贝，其中所有标识符在输入AST中都有唯一的名称。
这是所有其他优化器阶段的先决条件。
其中一个好处是，标识符查找不需要考虑作用域，
这简化了其他步骤所需的分析。</p>
<p>所有后续阶段都有一个属性，即所有的名字都保持唯一。
这意味着如果需要引入一个新的标识符，就会产生一个新的唯一名称。</p>
</section>
<section id="function-hoister">
<span id="id12"></span><h5>函数提升器<a class="headerlink" href="#function-hoister" title="此标题的永久链接"></a></h5>
<p>函数提升器将所有的函数定义移到最上面的块的末尾。
只要在消歧义阶段之后进行，这就是一个语义上的等价转换。
原因是，将一个定义移到更高层次的块中不能降低其可见性，
而且不可能引用在不同函数中定义的变量。</p>
<p>这个阶段的好处是，可以更容易地查找函数定义，
并且可以孤立地优化函数，而不必完全遍历AST。</p>
</section>
<section id="function-grouper">
<span id="id13"></span><h5>函数分组器<a class="headerlink" href="#function-grouper" title="此标题的永久链接"></a></h5>
<p>函数分组器必须在消歧义器和函数提升器之后应用。
它的作用是将所有不是函数定义的最上面的元素移到一个单一的块中，
这个块是根块的第一个语句。</p>
<p>在这一步之后，一个程序具有以下正常形式：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{ I F... }
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">I</span></code> 是一个（可能是空的）区块，不包含任何函数定义（甚至是递归的），
<code class="docutils literal notranslate"><span class="pre">F</span></code> 是一个函数定义的列表，使得没有一个函数包含函数定义。</p>
<p>这个阶段的好处是，我们总是知道功能列表的开始位置。</p>
</section>
<section id="for-loop-condition-into-body">
<span id="id14"></span><h5>循环条件进入正文<a class="headerlink" href="#for-loop-condition-into-body" title="此标题的永久链接"></a></h5>
<p>这种转换将for循环的循环迭代条件移动到循环体中。
我们需要这种转换，因为 <a class="reference internal" href="#expression-splitter"><span class="std std-ref">表达式拆分器</span></a> 将不适用于迭代条件表达式（以下示例中的 <code class="docutils literal notranslate"><span class="pre">C</span></code>）。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>for { Init... } C { Post... } {
    Body...
}
</pre></div>
</div>
<p>被转化为</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>for { Init... } 1 { Post... } {
    if iszero(C) { break }
    Body...
}
</pre></div>
</div>
<p>当与 <code class="docutils literal notranslate"><span class="pre">循环不变代码模式</span></code> 搭配时，这种转换也是有用的，因为循环不变条件中的不变量可以在循环之外进行。</p>
</section>
<section id="for-loop-init-rewriter">
<span id="id15"></span><h5>循环初始重写器<a class="headerlink" href="#for-loop-init-rewriter" title="此标题的永久链接"></a></h5>
<p>这种转换将for-loop的初始化部分移到循环之前：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>for { Init... } C { Post... } {
    Body...
}
</pre></div>
</div>
<p>被转化为</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Init...
for {} C { Post... } {
    Body...
}
</pre></div>
</div>
<p>这简化了其余的优化过程，
因为我们可以忽略for循环初始化块的复杂范围规则。</p>
</section>
<section id="var-decl-initializer">
<span id="id16"></span><h5>初始化程序<a class="headerlink" href="#var-decl-initializer" title="此标题的永久链接"></a></h5>
<p>这一步重写了变量声明，使所有的变量都被初始化。
像 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x,</span> <span class="pre">y</span></code> 这样的声明被分割成多个声明语句。</p>
<p>目前只支持用零值初始化。</p>
</section>
</section>
<section id="ssa">
<h4>伪SSA转换<a class="headerlink" href="#ssa" title="此标题的永久链接"></a></h4>
<p>这个组件的目的是让程序变成一个较长的形式，
以便其他组件能够更容易地与之配合。
最终的表现形式将类似于静态单一赋值（SSA）的形式，不同的是，
它不使用明确的 &quot;phi&quot; 函数来合并来自控制流不同分支的值，
因为Yul语言中不存在这样的功能。相反，当控制流合并时，
如果一个变量在其中一个分支中被重新赋值，就会声明一个新的SSA变量来保持它的当前值，
这样，下面的表达式仍然只需要引用SSA变量。</p>
<p>下面是一个转换的例子：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCiAgICBsZXQgYiA6PSBjYWxsZGF0YWxvYWQoMHgyMCkKICAgIGlmIGd0KGEsIDApIHsKICAgICAgICBiIDo9IG11bChiLCAweDIwKQogICAgfQogICAgYSA6PSBhZGQoYSwgMSkKICAgIHNzdG9yZShhLCBhZGQoYiwgMHgyMCkpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">b</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">gt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">b</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>应用以下所有转换步骤后，程序将如下所示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IF8xIDo9IDAKICAgIGxldCBhXzkgOj0gY2FsbGRhdGFsb2FkKF8xKQogICAgbGV0IGEgOj0gYV85CiAgICBsZXQgXzIgOj0gMHgyMAogICAgbGV0IGJfMTAgOj0gY2FsbGRhdGFsb2FkKF8yKQogICAgbGV0IGIgOj0gYl8xMAogICAgbGV0IF8zIDo9IDAKICAgIGxldCBfNCA6PSBndChhXzksIF8zKQogICAgaWYgXzQKICAgIHsKICAgICAgICBsZXQgXzUgOj0gMHgyMAogICAgICAgIGxldCBiXzExIDo9IG11bChiXzEwLCBfNSkKICAgICAgICBiIDo9IGJfMTEKICAgIH0KICAgIGxldCBiXzEyIDo9IGIKICAgIGxldCBfNiA6PSAxCiAgICBsZXQgYV8xMyA6PSBhZGQoYV85LCBfNikKICAgIGxldCBfNyA6PSAweDIwCiAgICBsZXQgXzggOj0gYWRkKGJfMTIsIF83KQogICAgc3N0b3JlKGFfMTMsIF84KQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">_1</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="ow">let</span> <span class="nv">a_9</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="n">_1</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="n">a_9</span>
    <span class="ow">let</span> <span class="nv">_2</span> <span class="o">:=</span> <span class="mh">0x20</span>
    <span class="ow">let</span> <span class="nv">b_10</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="n">_2</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">b</span> <span class="o">:=</span> <span class="n">b_10</span>
    <span class="ow">let</span> <span class="nv">_3</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="ow">let</span> <span class="nv">_4</span> <span class="o">:=</span> <span class="nf">gt</span><span class="p">(</span><span class="n">a_9</span><span class="p">,</span> <span class="n">_3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_4</span>
    <span class="p">{</span>
        <span class="ow">let</span> <span class="nv">_5</span> <span class="o">:=</span> <span class="mh">0x20</span>
        <span class="ow">let</span> <span class="nv">b_11</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">b_10</span><span class="p">,</span> <span class="n">_5</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">:=</span> <span class="n">b_11</span>
    <span class="p">}</span>
    <span class="ow">let</span> <span class="nv">b_12</span> <span class="o">:=</span> <span class="n">b</span>
    <span class="ow">let</span> <span class="nv">_6</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="ow">let</span> <span class="nv">a_13</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">a_9</span><span class="p">,</span> <span class="n">_6</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">_7</span> <span class="o">:=</span> <span class="mh">0x20</span>
    <span class="ow">let</span> <span class="nv">_8</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">b_12</span><span class="p">,</span> <span class="n">_7</span><span class="p">)</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">a_13</span><span class="p">,</span> <span class="n">_8</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，此代码段中唯一重新分配的变量是 <code class="docutils literal notranslate"><span class="pre">b</span></code>。
无法避免这种重新分配，因为根据控制流， <code class="docutils literal notranslate"><span class="pre">b</span></code> 具有不同的值。
所有其他变量在定义后都不会改变其值。
该属性的优点是，变量可以自由移动，
对它们的引用可以通过它们的初始值进行交换（反之亦然），
只要这些值在新上下文中仍然有效。</p>
<p>当然，这里的代码远远没有得到优化。相反，它要长得多。
我们希望这段代码更容易使用，此外，还有一些优化器步骤可以撤销这些更改，
并在最后使代码更加紧凑。</p>
<section id="expression-splitter">
<span id="id17"></span><h5>表达式拆分器<a class="headerlink" href="#expression-splitter" title="此标题的永久链接"></a></h5>
<p>表达式拆分器将诸如 <code class="docutils literal notranslate"><span class="pre">add(mload(0x123),</span> <span class="pre">mul(mload(0x456),</span> <span class="pre">0x20))</span></code>
这样的表达式变成一连串独特变量的声明，这些变量被分配给该表达式的子表达式，
这样每个函数调用只有变量作为参数。</p>
<p>上述内容将被转化为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IF8xIDo9IDB4MjAKICAgIGxldCBfMiA6PSAweDQ1NgogICAgbGV0IF8zIDo9IG1sb2FkKF8yKQogICAgbGV0IF80IDo9IG11bChfMywgXzEpCiAgICBsZXQgXzUgOj0gMHgxMjMKICAgIGxldCBfNiA6PSBtbG9hZChfNSkKICAgIGxldCB6IDo9IGFkZChfNiwgXzQpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">_1</span> <span class="o">:=</span> <span class="mh">0x20</span>
    <span class="ow">let</span> <span class="nv">_2</span> <span class="o">:=</span> <span class="mh">0x456</span>
    <span class="ow">let</span> <span class="nv">_3</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">_2</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">_4</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">_3</span><span class="p">,</span> <span class="n">_1</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">_5</span> <span class="o">:=</span> <span class="mh">0x123</span>
    <span class="ow">let</span> <span class="nv">_6</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">_5</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">z</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">_6</span><span class="p">,</span> <span class="n">_4</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，这种转换并不改变操作码或函数调用的顺序。</p>
<p>它不适用于循环迭代条件，因为循环控制流不允许在所有情况下 “概述” 内部表达式。
我们可以通过应用 <a class="reference internal" href="#for-loop-condition-into-body"><span class="std std-ref">循环条件进入正文</span></a> 将迭代条件移动到循环体中，从而避开这个限制。</p>
<p>最后一个程序的形式应确保（循环条件除外）函数调用不会嵌套在表达式中，
所有函数调用参数都必须是变量。</p>
<p>这种形式的好处是，更容易重新排列操作码序列，
也更容易执行函数调用内联。此外，
也更简单地替换表达式的各个部分或重新组织 “表达式树”。
缺点是这样的代码对我们来说更难阅读。</p>
</section>
<section id="ssa-transform">
<span id="id18"></span><h5>SSA转换<a class="headerlink" href="#ssa-transform" title="此标题的永久链接"></a></h5>
<p>这个阶段尽可能地用新变量的声明来取代对现有变量的重复赋值。
重新赋值仍然存在，但是所有对重新赋值的变量的引用都被新声明的变量所取代。</p>
<p>示例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IGEgOj0gMQogICAgbXN0b3JlKGEsIDIpCiAgICBhIDo9IDMKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nf">mstore</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="mi">3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>被转化为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIG1zdG9yZShhXzEsIDIpCiAgICBsZXQgYV8zIDo9IDMKICAgIGEgOj0gYV8zCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">a_1</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="n">a_1</span>
    <span class="nf">mstore</span><span class="p">(</span><span class="n">a_1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">a_3</span> <span class="o">:=</span> <span class="mi">3</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="n">a_3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>精确语义：</p>
<p>对于任何在代码中被分配到某处的变量 <code class="docutils literal notranslate"><span class="pre">a</span></code>
（带值声明且从未重新分配的变量不被修改），执行以下转换:</p>
<ul class="simple">
<li><p>将 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">a</span> <span class="pre">:=</span> <span class="pre">v</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">a_i</span> <span class="pre">:=</span> <span class="pre">v</span>&#160;&#160; <span class="pre">let</span> <span class="pre">a</span> <span class="pre">:=</span> <span class="pre">a_i</span></code></p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">v</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">a_i</span> <span class="pre">:=</span> <span class="pre">v</span>&#160;&#160; <span class="pre">a</span> <span class="pre">:=</span> <span class="pre">a_i</span></code>, 其中 <code class="docutils literal notranslate"><span class="pre">i</span></code> 是一个数字，使得 <code class="docutils literal notranslate"><span class="pre">a_i</span></code> 尚未使用。</p></li>
</ul>
<p>此外，总是记录用于 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的当前值，并用 <code class="docutils literal notranslate"><span class="pre">a_i</span></code> 替换对 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的每次引用。
变量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的当前值映射在每个分配给它的块结束时被清除，
如果它被分配在for循环体或post块内，则在for循环初始块结束时被清除。
如果一个变量的值根据上面的规则被清除，并且该变量被声明在块之外，
一个新的SSA变量将在控制流加入的位置被创建，这包括循环后/体块的开始和If/Switch/ForLoop/Block语句之后的位置。</p>
<p>在此阶段之后，建议使用冗余赋值消除器删除不必要的中间分配。</p>
<p>如果在这个阶段之前运行表达式拆分器和通用子表达式消除器，
那么这个阶段会提供最好的结果，因为这样就不会产生过多的变量。
另一方面，如果在SSA转换之后运行通用子表达式消除器，则效率更高。</p>
</section>
<section id="redundant-assign-eliminator">
<span id="id19"></span><h5>冗余赋值消除器<a class="headerlink" href="#redundant-assign-eliminator" title="此标题的永久链接"></a></h5>
<p>SSA转换总是生成 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">a_i</span></code> 形式的赋值，
尽管这些赋值在许多情况下可能是不必要的，比如下面的例子：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IGEgOj0gMQogICAgYSA6PSBtbG9hZChhKQogICAgYSA6PSBzbG9hZChhKQogICAgc3N0b3JlKGEsIDEpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SSA转换将这个片段转换为以下内容:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIGxldCBhXzIgOj0gbWxvYWQoYV8xKQogICAgYSA6PSBhXzIKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgYSA6PSBhXzMKICAgIHNzdG9yZShhXzMsIDEpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">a_1</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="n">a_1</span>
    <span class="ow">let</span> <span class="nv">a_2</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">a_1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="n">a_2</span>
    <span class="ow">let</span> <span class="nv">a_3</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">a_2</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="n">a_3</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">a_3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>冗余赋值消除器将删除对 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的所有三个赋值，因为未使用 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的值，
因此将此代码段转换为严格的SSA形式为：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYV8yIDo9IG1sb2FkKGFfMSkKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgc3N0b3JlKGFfMywgMSkKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">a_1</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="ow">let</span> <span class="nv">a_2</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">a_1</span><span class="p">)</span>
    <span class="ow">let</span> <span class="nv">a_3</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">a_2</span><span class="p">)</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">a_3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当然，确定分配是否多余的错综复杂的部分与加入控制流有关。</p>
<p>该组件的详细工作情况如下：</p>
<p>AST被遍历了两次：分别在在信息收集步骤和实际删除步骤中。
在信息收集过程中，我们维护了一个从赋值语句到 “未使用（unused）”，“未决定（undecided）” 和 “已使用（used）” 三种状态的映射，
这标志着分配的值是否会在以后被变量的引用使用。</p>
<p>当一个赋值被访问时，它被添加到处于 “未决定” 状态的映射中
（见下面关于for循环的注释），而其他每个仍处于 “未决定” 状态的对同一变量的赋值被改为 “未使用”。
当一个变量被引用时，任何对该变量的赋值仍处于 “未决定” 状态，其状态被改变为 “已使用”。</p>
<p>在控制流分叉的地方，映射的拷贝被移交给每个分支。
在控制流汇合的地方，来自两个分支的两个映射以下列方式合并：
只在一个映射中的语句或具有相同状态的语句不作改动地使用。
冲突的值以如下方式解决：</p>
<ul class="simple">
<li><p>“未使用”， “未决定” -&gt; “未决定”</p></li>
<li><p>“未使用”， “已使用” -&gt; “已使用”</p></li>
<li><p>“未决定”， “已使用” -&gt; “已使用”</p></li>
</ul>
<p>对于For循环，考虑到条件下的连接控制流，将对条件、主体和后部进行两次访问。
换句话说，我们创建了三条控制流路径：循环的零次运行、一次运行和两次运行，然后在最后合并它们。</p>
<p>不需要模拟第三次甚至更多的运行，这可以如下所示：</p>
<p>迭代开始时的赋值状态将决定性地导致该赋值在迭代结束时的状态。
假如这个状态映射函数被称为 <code class="docutils literal notranslate"><span class="pre">f</span></code>。如上所述，
三种不同状态 <code class="docutils literal notranslate"><span class="pre">unused（未使用）</span></code>， <code class="docutils literal notranslate"><span class="pre">undecided（未决定）</span></code> 和 <code class="docutils literal notranslate"><span class="pre">used（已使用）</span></code> 的组合是 <code class="docutils literal notranslate"><span class="pre">最多（max）</span></code> 操作，
其中 <code class="docutils literal notranslate"><span class="pre">unused</span> <span class="pre">=</span> <span class="pre">0</span></code>， <code class="docutils literal notranslate"><span class="pre">undecided</span> <span class="pre">=</span> <span class="pre">1</span></code>， <code class="docutils literal notranslate"><span class="pre">used</span> <span class="pre">=</span> <span class="pre">2</span></code>。</p>
<p>正确的方法是计算</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>max(s, f(s), f(f(s)), f(f(f(s))), ...)
</pre></div>
</div>
<p>作为循环后的状态。因为 <code class="docutils literal notranslate"><span class="pre">f</span></code> 只是有三个不同的值的范围，
迭代它必须在最多三个迭代后达到一个循环，
因此 <code class="docutils literal notranslate"><span class="pre">f(f(f(s)))</span></code> 必须等于 <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">f(s)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">f(f(s))</span></code> 其中之一，
因此</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>max(s, f(s), f(f(s))) = max(s, f(s), f(f(s)), f(f(f(s))), ...).
</pre></div>
</div>
<p>总之，最多运行两次循环就足够了，因为只有三种不同的状态。</p>
<p>对于有 &quot;默认&quot; 情况的switch语句，没有跳过switch的控制流部分。</p>
<p>当一个变量超出范围时，所有仍处于 &quot;未决定&quot; 状态的语句都被改为 &quot;未使用&quot;，
除非该变量是一个函数的返回参数--如何是这样，状态变为 &quot;已使用&quot;。</p>
<p>在第二次遍历中，所有处于 &quot;未使用&quot; 状态的赋值都被删除。</p>
<p>这一步通常是在SSA转换之后立即运行，以完成伪SSA的生成。</p>
</section>
</section>
<section id="id20">
<h4>工具<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h4>
<section id="id21">
<h5>可移动性<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h5>
<p>可移动性是表达式的一个属性。它大致上意味着表达式是没有副作用的，
它的评估只取决于变量的值和环境的调用常数状态。
大多数表达式都是可移动的。以下部分使表达式不可移动:</p>
<ul class="simple">
<li><p>函数调用（如果函数中的所有语句都是可移动的，未来可能会放宽）</p></li>
<li><p>有副作用的操作码（如 <code class="docutils literal notranslate"><span class="pre">call</span></code> 或 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code>）</p></li>
<li><p>读取或写入内存, 存储或外部状态信息的操作码</p></li>
<li><p>取决于当前PC、内存大小或返回数据大小的操作码</p></li>
</ul>
</section>
<section id="id22">
<h5>数据流分析器<a class="headerlink" href="#id22" title="此标题的永久链接"></a></h5>
<p>数据流分析器本身不是一个优化步骤，而是被其他组件作为工具使用。
在遍历AST时，它跟踪每个变量的当前值，
只要该值是一个可移动的表达式。
它记录了作为表达式一部分的变量，
这些表达式目前被分配给其他每个变量。在每次对变量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的赋值时，
<code class="docutils literal notranslate"><span class="pre">a</span></code> 的当前存储值被更新，只要 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是 <code class="docutils literal notranslate"><span class="pre">b</span></code> 当前存储表达式的一部分，
变量 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的所有存储值都被清除。</p>
<p>在控制流连接处，如果变量在任何控制流路径中已经或将要被分配，
那么关于这些变量的记忆就会被清除。例如，在进入for循环时，所有将在主体或后块中分配的变量都被清除。</p>
</section>
</section>
<section id="id23">
<h4>表达式的简化<a class="headerlink" href="#id23" title="此标题的永久链接"></a></h4>
<p>这些简化过程会改变表达式，并用等效的、希望更简单的表达式替换它们。</p>
<section id="common-subexpression-eliminator">
<span id="id24"></span><h5>通用子表达式消除器<a class="headerlink" href="#common-subexpression-eliminator" title="此标题的永久链接"></a></h5>
<p>这一步使用数据流分析器，用对某一变量的引用来替换语法上与该变量当前值相匹配的子表达式。
这是一个等价转换，因为这种子表达式必须是可移动的。</p>
<p>如果值是一个标识符，所有本身是标识符的子表达式都被其当前值替换。</p>
<p>上述两条规则的结合允许计算出一个局部值的编号，
这意味着如果两个变量有相同的值，其中一个将永远是未使用的。
然后，未使用过的处理器或冗余赋值消除器将能够完全消除此类变量。</p>
<p>如果之前运行过表达式拆分器，则此步骤尤其有效。
如果代码是伪SSA形式，那么变量值的可用时间更长，因此我们有更高的机会替换表达式。</p>
<p>如果通用子表达式消除器在它之前运行，
表达式简化器将能够进行更好的替换。</p>
</section>
<section id="expression-simplifier">
<span id="id25"></span><h5>表达式简化器<a class="headerlink" href="#expression-simplifier" title="此标题的永久链接"></a></h5>
<p>表达式简化器使用数据流分析器，
并利用表达式的等价变换列表，如 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">+</span> <span class="pre">0</span> <span class="pre">-&gt;</span> <span class="pre">X</span></code> 来简化代码。</p>
<p>它试图在每个子表达式上匹配诸如 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">+</span> <span class="pre">0</span></code> 的模式。
在匹配过程中，它将变量解析为当前分配的表达式，
以便能够匹配更深入的嵌套模式，
即使代码是伪SSA形式。</p>
<p>一些模式如 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">-&gt;</span> <span class="pre">0</span></code> 只能在表达式 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是可移动的情况下应用，
否则会删除其潜在的副作用。
由于变量引用总是可移动的，即使它们的当前值可能不是，
表达式简化器在拆分或伪SSA形式下又更加强大。</p>
</section>
<section id="literalrematerialiser">
<span id="literal-rematerialiser"></span><h5>字面意义上的再物质化器（LiteralRematerialiser）<a class="headerlink" href="#literalrematerialiser" title="此标题的永久链接"></a></h5>
<p>有待记录。</p>
</section>
<section id="load-resolver">
<span id="id26"></span><h5>负载解析器<a class="headerlink" href="#load-resolver" title="此标题的永久链接"></a></h5>
<p>优化阶段，分别将 <code class="docutils literal notranslate"><span class="pre">sload(x)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mload(x)</span></code> 类型的表达式替换为当前存储和内存中的值，如果已知的话。</p>
<p>如果代码是SSA形式的，效果最好。</p>
<p>先决条件：消歧器，循环初始重写器。</p>
</section>
<section id="reasoning-based-simplifier">
<span id="id27"></span><h5>基于推理的简化器<a class="headerlink" href="#reasoning-based-simplifier" title="此标题的永久链接"></a></h5>
<p>这个优化器使用SMT求解器来检查 <code class="docutils literal notranslate"><span class="pre">if</span></code> 条件是否为常数。</p>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">限制条件和条件</span></code> 是不满足的（UNSAT），那么条件永远不会是真的，整个主体可以被删除。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">限制条件和非限制条件</span></code> 是不满足的（UNSAT），那么条件永远是真的，可以用 <code class="docutils literal notranslate"><span class="pre">1</span></code> 代替。</p></li>
</ul>
<p>只有在条件是可移动的情况下，上面的简化才能适用。</p>
<p>它只对EVM语言有效，但在其他语言上使用是安全的。</p>
<p>先决条件：消歧器，SSA转换。</p>
</section>
</section>
<section id="id28">
<h4>声明规模的简化<a class="headerlink" href="#id28" title="此标题的永久链接"></a></h4>
<section id="circular-reference-pruner">
<span id="id29"></span><h5>循环引用程序<a class="headerlink" href="#circular-reference-pruner" title="此标题的永久链接"></a></h5>
<p>这个阶段删除了那些互相调用但既没有外部引用也没有从最外层上下文中引用的函数。</p>
</section>
<section id="conditional-simplifier">
<span id="id30"></span><h5>条件简化器<a class="headerlink" href="#conditional-simplifier" title="此标题的永久链接"></a></h5>
<p>如果可以从控制流中确定数值，条件简化器就会插入对条件变量的赋值。</p>
<p>销毁SSA表格。</p>
<p>目前，这个工具是非常有限的，主要是因为我们还没有支持布尔类型。
由于条件只检查表达式是否为非零，我们不能指定一个特定的值。</p>
<p>当前的特性：</p>
<ul class="simple">
<li><p>切换条件：插入 “&lt;条件&gt; := &lt;条件标签&gt;”</p></li>
<li><p>在带有终止控制流的if语句后，插入“&lt;条件&gt; : =0”</p></li>
</ul>
<p>未来的特性：</p>
<ul class="simple">
<li><p>允许用 &quot;1&quot; 替换</p></li>
<li><p>考虑到用户定义的终止函数</p></li>
</ul>
<p>如果之前已经运行过死代码的删除，那么使用SSA表单效果最好。</p>
<p>先决条件：消歧器。</p>
</section>
<section id="conditional-unsimplifier">
<span id="id31"></span><h5>有条件的非对称性放大器<a class="headerlink" href="#conditional-unsimplifier" title="此标题的永久链接"></a></h5>
<p>条件简化器的反面。</p>
</section>
<section id="control-flow-simplifier">
<span id="id32"></span><h5>控制流简化器<a class="headerlink" href="#control-flow-simplifier" title="此标题的永久链接"></a></h5>
<p>简化了几个控制流结构：</p>
<ul class="simple">
<li><p>用pop（条件）代替if，用空的程序体代替if</p></li>
<li><p>移除空的默认switch情况</p></li>
<li><p>如果不存在默认情况，则删除空的switch情况</p></li>
<li><p>用pop（表达式）代替没有条件的switch</p></li>
<li><p>把单例的switch变成if</p></li>
<li><p>用pop（表达式）和程序体代替switch，只用默认情况</p></li>
<li><p>用匹配的条件程序体的常量表达式替换switch</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">for</span></code> 替换为终止控制流，在没有其他 break/continue 的情况下替换为 <code class="docutils literal notranslate"><span class="pre">if</span></code></p></li>
<li><p>移除函数末尾的 <code class="docutils literal notranslate"><span class="pre">leave</span></code></p></li>
</ul>
<p>这些操作都不依赖于数据流。然而结构简化器执行类似的任务，确实依赖于数据流。</p>
<p>控制流简化器在其遍历过程中确实记录了是否存在 <code class="docutils literal notranslate"><span class="pre">break</span></code> 和 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 语句。</p>
<p>先决条件：消歧器，函数提升器， 循环初始重写器。
重要提示：引入了EVM操作代码，因此目前只能用于EVM代码。</p>
</section>
<section id="dead-code-eliminator">
<span id="id33"></span><h5>死代码消除器<a class="headerlink" href="#dead-code-eliminator" title="此标题的永久链接"></a></h5>
<p>这个优化阶段删除了不可到达的代码。</p>
<p>无法访问代码可以是一个块中的任何代码，
其前面有leave，return，invalid，break，continue，selfdestruct 或 revert。</p>
<p>函数定义被保留下来，因为它们可能被早期的代码调用，因此被认为是可访问的。</p>
<p>因为在for循环的init块中声明的变量，其范围会扩展到循环体，
所以我们要求 循环初始重写器 在此步骤之前运行。</p>
<p>先决条件： 循环初始重写器, 函数提升器, 函数分组器</p>
</section>
<section id="equal-store-eliminator">
<span id="id34"></span><h5>等价的存储清除器<a class="headerlink" href="#equal-store-eliminator" title="此标题的永久链接"></a></h5>
<p>如果之前有对 <code class="docutils literal notranslate"><span class="pre">mstore(k,</span> <span class="pre">v)</span></code> / <code class="docutils literal notranslate"><span class="pre">sstore(k,</span> <span class="pre">v)</span></code> 的调用，
但中间没有其他存储，并且 <code class="docutils literal notranslate"><span class="pre">k</span></code> 和 <code class="docutils literal notranslate"><span class="pre">v</span></code> 的值没有变化，
则该步骤将删除 <code class="docutils literal notranslate"><span class="pre">mstore(k,</span> <span class="pre">v)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sstore(k,</span> <span class="pre">v)</span></code> 的调用。</p>
<p>如果在SSA转换和通用子表达式消除器之后运行，这个简单的步骤是有效的，
因为SSA将确保变量不会改变，而通用子表达式消除器在已知值相同的情况下会重新使用完全相同的变量。</p>
<p>先决条件： 消歧器, 循环初始重写器</p>
</section>
<section id="unused-pruner">
<span id="id35"></span><h5>未使用过的处理器<a class="headerlink" href="#unused-pruner" title="此标题的永久链接"></a></h5>
<p>这一步删除了所有从未被引用的函数的定义。</p>
<p>它还删除了从未被引用的变量的声明。如果声明指定了一个不可移动的值，
表达式将被保留，但其值将被丢弃。</p>
<p>所有可移动的表达式语句（未被赋值的表达式）都被删除。</p>
</section>
<section id="structural-simplifier">
<span id="id36"></span><h5>结构简化器<a class="headerlink" href="#structural-simplifier" title="此标题的永久链接"></a></h5>
<p>这是一个一般的步骤，在结构层面上进行各种简化：</p>
<ul class="simple">
<li><p>用 <code class="docutils literal notranslate"><span class="pre">pop(条件)</span></code> 代替 if 语句的空程序体。</p></li>
<li><p>用其主体替换带有真实条件的if语句</p></li>
<li><p>删除带有错误条件的if语句</p></li>
<li><p>把单例的switch变成if</p></li>
<li><p>用 <code class="docutils literal notranslate"><span class="pre">pop(表达式)</span></code> 和程序体代替switch，只用默认情况</p></li>
<li><p>通过匹配的条件程序体，用字面表达式替换switch</p></li>
<li><p>用其初始化部分取代带有错误条件的for循环</p></li>
</ul>
<p>该组件使用数据流分析器。</p>
</section>
<section id="block-flattener">
<span id="id37"></span><h5>块展平器<a class="headerlink" href="#block-flattener" title="此标题的永久链接"></a></h5>
<p>这个阶段通过在外部块的适当位置插入内部块的语句来消除嵌套块。
它依赖于函数分组器，并不对最外层的块进行展平，以保持函数分组器产生的形式。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICB7CiAgICAgICAgICAgIGxldCB5IDo9IDMKICAgICAgICAgICAgbXN0b3JlKHgsIHkpCiAgICAgICAgfQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="p">{</span>
        <span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="mi">2</span>
        <span class="p">{</span>
            <span class="ow">let</span> <span class="nv">y</span> <span class="o">:=</span> <span class="mi">3</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>被转化为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICBsZXQgeSA6PSAzCiAgICAgICAgbXN0b3JlKHgsIHkpCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="p">{</span>
        <span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="mi">2</span>
        <span class="ow">let</span> <span class="nv">y</span> <span class="o">:=</span> <span class="mi">3</span>
        <span class="nf">mstore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>只要代码没有歧义，这就不会造成问题，因为变量的作用域只能增长。</p>
</section>
<section id="loop-invariant-code-motion">
<span id="id38"></span><h5>循环不变代码模式<a class="headerlink" href="#loop-invariant-code-motion" title="此标题的永久链接"></a></h5>
<p>这种优化将可移动的SSA变量声明移到循环之外。</p>
<p>只有在循环体或后块中的最高级别的语句被考虑，
即条件分支内的变量声明不会被移出循环。</p>
<p>要求：</p>
<ul class="simple">
<li><p>消歧器, 循环初始重写器和函数提升器必须提前运行。</p></li>
<li><p>表达式拆分器和SSA转换应在前期运行以获得更好的结果。</p></li>
</ul>
</section>
</section>
<section id="id39">
<h4>函数级的优化<a class="headerlink" href="#id39" title="此标题的永久链接"></a></h4>
<section id="function-specializer">
<span id="id40"></span><h5>函数特殊化器<a class="headerlink" href="#function-specializer" title="此标题的永久链接"></a></h5>
<p>这一步是用字面参数来实现函数的专业化。</p>
<p>如果一个函数，例如， <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(a,</span> <span class="pre">b)</span> <span class="pre">{</span> <span class="pre">sstore</span> <span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">}</span></code>，被调用时有字面参数，
例如， <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">5)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是一个标识符，可以通过创建一个新函数 <code class="docutils literal notranslate"><span class="pre">f_1</span></code> 来专门化，
该函数只需要一个参数，即：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gZl8xKGFfMSkgewogICAgbGV0IGJfMSA6PSA1CiAgICBzc3RvcmUoYV8xLCBiXzEpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">f_1</span><span class="p">(</span><span class="n">a_1</span><span class="p">)</span> <span class="p">{</span>
    <span class="ow">let</span> <span class="nv">b_1</span> <span class="o">:=</span> <span class="mi">5</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">a_1</span><span class="p">,</span> <span class="n">b_1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其他优化步骤将能够对函数进行更多的简化。
优化步骤主要对那些不会被内联的函数有用。</p>
<p>先决条件： 消歧器， 函数提升器</p>
<p>建议将字面意义上的再物质化器（LiteralRematerialiser）作为先决条件，尽管它不是正确性的必要条件。</p>
</section>
<section id="unused-function-parameter-pruner">
<span id="id41"></span><h5>未使用的函数参数管理器<a class="headerlink" href="#unused-function-parameter-pruner" title="此标题的永久链接"></a></h5>
<p>这一步是删除一个函数中未使用的参数。</p>
<p>如果一个参数没有使用，
比如在 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(a,b,c)</span> <span class="pre">-&gt;</span> <span class="pre">x,</span> <span class="pre">y</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">div(a,b)</span> <span class="pre">}</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code>，
我们删除该参数并创建一个新的 &quot;连接&quot; 函数，如下所示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gZihhLGIpIC0+IHggeyB4IDo9IGRpdihhLGIpIH0KZnVuY3Rpb24gZjIoYSxiLGMpIC0+IHgsIHkgeyB4IDo9IGYoYSxiKSB9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="nf">div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>
<span class="k">function</span> <span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>并将所有对 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的引用替换为 <code class="docutils literal notranslate"><span class="pre">f2</span></code>。
之后应该运行内联，以确保所有对 <code class="docutils literal notranslate"><span class="pre">f2</span></code> 的引用都被 <code class="docutils literal notranslate"><span class="pre">f</span></code> 替换。</p>
<p>先决条件： 消歧器， 函数提升器， 字面意义上的再物质化器</p>
<p>字面意义上的再物质化器这个步骤对于正确性来说不是必需的。
它有助于处理诸如以下情况：
<code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(x)</span> <span class="pre">-&gt;</span> <span class="pre">y</span> <span class="pre">{</span> <span class="pre">revert(y,</span> <span class="pre">y}</span> <span class="pre">}</span></code> 其中字面意思 <code class="docutils literal notranslate"><span class="pre">y</span></code>  将被其值 <code class="docutils literal notranslate"><span class="pre">0</span></code> 取代，
使我们能够重写该函数。</p>
</section>
<section id="equivalent-function-combiner">
<span id="id42"></span><h5>等价函数组合器<a class="headerlink" href="#equivalent-function-combiner" title="此标题的永久链接"></a></h5>
<p>如果两个函数在语法上是等价的，
同时允许变量重命名，但不允许任何重新排序，
那么对其中一个函数的任何引用都会被另一个函数取代。</p>
<p>实际删除的功能是由未使用过的处理器执行的。</p>
</section>
</section>
<section id="id43">
<h4>函数内联<a class="headerlink" href="#id43" title="此标题的永久链接"></a></h4>
<section id="expression-inliner">
<span id="id44"></span><h5>表达式内联<a class="headerlink" href="#expression-inliner" title="此标题的永久链接"></a></h5>
<p>优化器的这个组件通过内联可以在函数表达式中内联的函数来执行限制性的函数内联，函数为：</p>
<ul class="simple">
<li><p>返回一个单一的值。</p></li>
<li><p>有一个像 <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">:=</span> <span class="pre">&lt;函数表达式&gt;</span></code> 的主体。</p></li>
<li><p>既没有提到自己，也没有提到右边的 <code class="docutils literal notranslate"><span class="pre">r</span></code>。</p></li>
</ul>
<p>此外，对于所有的参数，以下各项都需要为真：</p>
<ul class="simple">
<li><p>参数是可移动的。</p></li>
<li><p>该参数在函数体中被引用不到两次，或者该参数相当便宜
（ &quot;成本&quot; 最多为1，就像一个0xff以下的常数）。</p></li>
</ul>
<p>例如：要被内联的函数的形式是： <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(...)</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">{</span> <span class="pre">r</span> <span class="pre">:=</span> <span class="pre">E</span> <span class="pre">}</span></code>
其中 <code class="docutils literal notranslate"><span class="pre">E</span></code> 是一个不引用 <code class="docutils literal notranslate"><span class="pre">r</span></code> 的表达式，函数调用中的所有参数都是可移动表达式。</p>
<p>这种内联的结果总是一个单一的表达式。</p>
<p>该组件只能用于具有唯一名称的源码。</p>
</section>
<section id="full-inliner">
<span id="id45"></span><h5>完全内联<a class="headerlink" href="#full-inliner" title="此标题的永久链接"></a></h5>
<p>完全内联用函数的主体取代了某些函数的调用。
这在大多数情况下是没有什么帮助的，因为它只是增加了代码的大小，但并没有什么好处。
此外，代码通常是非常昂贵的，我们往往宁愿要更短的代码而不是更有效的代码。
不过，在相同的情况下，内联一个函数可以对后续的优化步骤产生积极的影响。
例如，如果一个函数参数是一个常数，就会出现这种情况。</p>
<p>在内联过程中，一个启发式方法被用来判断函数调用是否应该被内联。
目前的启发式方法是不内联到 &quot;大&quot; 函数，除非被调用的函数很小。
只使用一次的函数以及中等大小的函数被内联，而带有常数参数的函数调用允许稍大的函数。</p>
<p>在未来，我们可能会加入一个回溯组件，
它不会立即对一个函数进行内联，而只是对其进行专业化处理，
这意味着会生成一个函数的拷贝，其中某个参数总是被一个常数取代。
之后，我们可以在这个专用函数上运行优化器。
如果结果有很大的收益，那么这个专门化的函数就被保留下来，否则就用原来的函数代替。</p>
</section>
</section>
<section id="id46">
<h4>清理<a class="headerlink" href="#id46" title="此标题的永久链接"></a></h4>
<p>清理工作是在优化器运行结束时进行的。
它试图将分割的表达式再次组合成深度嵌套的表达式，
并且通过尽可能地消除变量来提高堆栈机的 &quot;可编译性&quot;。</p>
<section id="expression-joiner">
<span id="id47"></span><h5>表达式连接器<a class="headerlink" href="#expression-joiner" title="此标题的永久链接"></a></h5>
<p>这是与表达式分割器相反的操作。它把正好有一个引用的变量声明序列变成一个复杂的表达式。
这个阶段完全保留了函数调用和操作码执行的顺序。它不使用任何关于操作码的互换性的信息；
如果将一个变量的值移到它的使用位置会改变任何函数调用或操作码执行的顺序，则不执行转换。</p>
<p>注意，组件不会移动变量赋值或被多次引用的变量的赋值。</p>
<p>片段 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(0,</span> <span class="pre">2)</span> <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(x,</span> <span class="pre">mload(2))</span></code> 不能转换，
因为它将导致调用操作码 <code class="docutils literal notranslate"><span class="pre">add</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mload</span></code> 的顺序被调换--尽管这不会有什么影响，
因为 <code class="docutils literal notranslate"><span class="pre">add</span></code> 是可移动的。</p>
<p>当像这样重排操作码时，变量引用和字面意义被忽略了。
因此，片段 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(0,</span> <span class="pre">2)</span> <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(x,</span> <span class="pre">3)</span></code> 被转换为
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(add(0,</span> <span class="pre">2),</span> <span class="pre">3)</span></code>，尽管 <code class="docutils literal notranslate"><span class="pre">add</span></code> 操作码将在计算字面意义 <code class="docutils literal notranslate"><span class="pre">3</span></code> 后执行。</p>
</section>
<section id="ssa-reverser">
<span id="id48"></span><h5>SSA反转器<a class="headerlink" href="#ssa-reverser" title="此标题的永久链接"></a></h5>
<p>这是一个微小的步骤，如果它与通用子表达式消除器和未使用过的处理器相结合，
则有助于扭转SSA转换的影响。</p>
<p>我们生成的SSA形式对EVM和WebAssembly的代码生成是不利的，
因为它生成了许多局部变量。最好的办法是用赋值重新使用现有的变量，
而不是用新的变量声明。</p>
<p>SSA转换改写</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZShhLCAxKQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">mstore</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IGFfMSA6PSBjYWxsZGF0YWxvYWQoMCkKbGV0IGEgOj0gYV8xCm1zdG9yZShhXzEsIDEpCmxldCBhXzIgOj0gY2FsbGRhdGFsb2FkKDB4MjApCmEgOj0gYV8y"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">a_1</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="n">a_1</span>
<span class="nf">mstore</span><span class="p">(</span><span class="n">a_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="ow">let</span> <span class="nv">a_2</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span>
<span class="n">a</span> <span class="o">:=</span> <span class="n">a_2</span>
</pre></div>
</div>
<p>问题是在引用 <code class="docutils literal notranslate"><span class="pre">a</span></code> 时使用了变量 <code class="docutils literal notranslate"><span class="pre">a_1</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">a</span></code>。
SSA转换改变了这种形式的语句，只需将声明和赋值互换。
上面的片段被转化为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCmxldCBhXzEgOj0gYQptc3RvcmUoYV8xLCAxKQphIDo9IGNhbGxkYXRhbG9hZCgweDIwKQpsZXQgYV8yIDo9IGE="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="ow">let</span> <span class="nv">a_1</span> <span class="o">:=</span> <span class="n">a</span>
<span class="nf">mstore</span><span class="p">(</span><span class="n">a_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span>
<span class="ow">let</span> <span class="nv">a_2</span> <span class="o">:=</span> <span class="n">a</span>
</pre></div>
</div>
<p>这是一个非常简单的等价转换，但是当我们现在运行通用子表达式消除器时，
它将用 <code class="docutils literal notranslate"><span class="pre">a</span></code> 替换所有出现的 <code class="docutils literal notranslate"><span class="pre">a_1</span></code> （直到 <code class="docutils literal notranslate"><span class="pre">a</span></code> 被重新赋值）。
然后，未使用过的处理器将完全消除变量 <code class="docutils literal notranslate"><span class="pre">a_1</span></code>，从而完全逆转SSA的转换。</p>
</section>
<section id="stack-compressor">
<span id="id49"></span><h5>堆栈压缩器<a class="headerlink" href="#stack-compressor" title="此标题的永久链接"></a></h5>
<p>让以太坊虚拟机的代码生成变得困难的一个问题是，
在表达式堆栈中，有16个插槽的硬性限制，可以向下延伸。
这或多或少转化为16个局部变量的限制。
堆栈压缩器采用Yul代码并将其编译为EVM字节码。
每当堆栈差异过大时，它就会记录发生在哪个函数中。</p>
<p>对于每一个造成这种问题的函数，再物质化都会被调用，
并提出特殊要求，以积极消除按其值的成本排序的特定变量。</p>
<p>一旦失败，这个程序会重复多次。</p>
</section>
<section id="rematerialiser">
<span id="id50"></span><h5>再物质化<a class="headerlink" href="#rematerialiser" title="此标题的永久链接"></a></h5>
<p>再物质化阶段试图用最后分配给变量的表达式来替换变量引用。
当然，这只有在这个表达式的评估费用相对较低的情况下才是有益的。
此外，只有当表达式的值在赋值点和使用点之间没有变化时，
它才具有语义上的等同性。这个阶段的主要好处是，
如果它导致一个变量被完全消除，它可以节省堆栈槽（见下文），
但是如果表达式非常便宜，它也可以在EVM上节省一个DUP操作码。</p>
<p>再物质化使用数据流分析器来跟踪变量的当前值，
这些变量总是可移动的。
如果数值非常便宜或者变量被明确要求消除，
那么变量的引用就会被其当前值所取代。</p>
</section>
<section id="for-loop-condition-out-of-body">
<span id="id51"></span><h5>体外循环条件<a class="headerlink" href="#for-loop-condition-out-of-body" title="此标题的永久链接"></a></h5>
<p>逆转体外循环条件的转换。</p>
<p>对于任何可移动的 <code class="docutils literal notranslate"><span class="pre">c</span></code>，它转换</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for { ... } 1 { ... } {
if iszero(c) { break }
...
}
</pre></div>
</div>
<p>为</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for { ... } c { ... } {
...
}
</pre></div>
</div>
<p>而它又转换</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for { ... } 1 { ... } {
if c { break }
...
}
</pre></div>
</div>
<p>为</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for { ... } iszero(c) { ... } {
...
}
</pre></div>
</div>
<p>字面意义上的再物质化器应在此步骤之前运行。</p>
</section>
</section>
<section id="webassembly">
<h4>特定的WebAssembly<a class="headerlink" href="#webassembly" title="此标题的永久链接"></a></h4>
<section id="id52">
<h5>主要功能<a class="headerlink" href="#id52" title="此标题的永久链接"></a></h5>
<p>将最上面的块改变为一个具有特定名称（“main”）的函数，它没有输入和输出。</p>
<p>取决于函数分组器。</p>
</section>
</section>
</section>
</section>
<span id="document-metadata"></span><section id="metadata">
<span id="id1"></span><h2>合约的元数据<a class="headerlink" href="#metadata" title="此标题的永久链接"></a></h2>
<p id="index-0">Solidity 编译器自动生成一个 JSON 文件，即合约元数据，
其中包含有关已编译合约的信息。您可以使用此文件来查询编译器版本，使用的源码，ABI 和 NatSpec 文档，
以便更安全地与合约交互并验证其源代码。</p>
<p>编译器默认将元数据文件的IPFS哈希附加到每个合约的字节码末尾（详见下文），
这样您就可以通过认证的方式来检索文件，而不必求助于中心化数据提供者。
其他可用的选项是Swarm哈希值和不将元数据哈希值附加到字节码上。
这些可以通过 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准 JSON 接口</span></a> 来配置。</p>
<p>您必须将元数据文件发布到IPFS，Swarm或其他服务，
以便其他人可以访问它。您可以通过使用 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--metadata</span></code> 命令
和 <code class="docutils literal notranslate"><span class="pre">--output-dir</span></code> 参数来创建该文件。如果没有这个参数，
元数据将被写到标准输出。
元数据包含 IPFS 和 Swarm 对源代码的引用，
所以除了元数据文件外，您还必须上传所有的源文件。
对于IPFS， <code class="docutils literal notranslate"><span class="pre">ipfs</span> <span class="pre">add</span></code> 返回的 CID 中包含的哈希值（不是文件的直接sha2-256哈希值）
应与字节码中包含的哈希值相匹配。</p>
<p>元数据文件有以下格式。下面的例子是以人类可读的方式呈现的。
正确的元数据格式应该正确地使用引号，
将空白减少到最低限度，并对所有对象的键进行排序，得出唯一的格式。
注释是不被允许的，在此仅用于解释目的。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 必选：元数据格式的版本</span>
<span class="w">  </span><span class="s2">&quot;version&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 必选：源代码的编程语言，一般会选择规范的“子版本”</span>
<span class="w">  </span><span class="s2">&quot;language&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Solidity&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 必选：编译器的详情，内容视语言而定。</span>
<span class="w">  </span><span class="s2">&quot;compiler&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 对 Solidity 来说是必选的：编译器的版本</span>
<span class="w">    </span><span class="s2">&quot;version&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.2+commit.661d1103&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// 可选： 生成此输出的编译器二进制文件的哈希值</span>
<span class="w">    </span><span class="s2">&quot;keccak256&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x123...&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// 必选：编译的源文件／源单元，键值为文件路径</span>
<span class="w">  </span><span class="s2">&quot;sources&quot;</span><span class="o">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;myDirectory/myFile.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 必选：源文件的 keccak256 哈希值</span>
<span class="w">      </span><span class="s2">&quot;keccak256&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x123...&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 必选：（除非使用 “content”，见下文）：已排序的源文件的URL，</span>
<span class="w">      </span><span class="c1">// 协议可以是任意的，</span>
<span class="w">      </span><span class="c1">// 但建议使用 IPFS URL</span>
<span class="w">      </span><span class="s2">&quot;urls&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;bzz-raw://7d7a...&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;dweb:/ipfs/QmN...&quot;</span><span class="w"> </span><span class="p">],</span>
<span class="w">      </span><span class="c1">// 可选：源文件中给出的 SPDX 许可证标识符。</span>
<span class="w">      </span><span class="s2">&quot;license&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MIT&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="s2">&quot;destructible&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 必选：源文件的 keccak256 哈希值</span>
<span class="w">      </span><span class="s2">&quot;keccak256&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x234...&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 必选（除非定义了“urls”）： 源文件的字面内容</span>
<span class="w">      </span><span class="s2">&quot;content&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;contract destructible is owned { function destroy() { if (msg.sender == owner) selfdestruct(owner); } }&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// 必选：编译器的设置</span>
<span class="w">  </span><span class="s2">&quot;settings&quot;</span><span class="o">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 对 Solidity 来说是必选的：已排序的导入重映射列表</span>
<span class="w">    </span><span class="s2">&quot;remappings&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;:g=/dir&quot;</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="c1">// 可选：优化器设置。“enabled” 和 &quot;runs&quot; 这两个字段已被废弃，</span>
<span class="w">    </span><span class="c1">// 这里只是为了向后兼容而给出。</span>
<span class="w">    </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;enabled&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;runs&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">500</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;details&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 默认值为 “true“</span>
<span class="w">        </span><span class="s2">&quot;peephole&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 内联器默认值为 “true“</span>
<span class="w">        </span><span class="s2">&quot;inliner&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 跳转目的地移除器默认为 “true“</span>
<span class="w">        </span><span class="s2">&quot;jumpdestRemover&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;orderLiterals&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;deduplicate&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;cse&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;constantOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;yul&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 可选：只在 “yul“ 为 “true“ 时出现</span>
<span class="w">        </span><span class="s2">&quot;yulDetails&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="s2">&quot;stackAllocation&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">          </span><span class="s2">&quot;optimizerSteps&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;dhfoDgvulfnTUtnIf...&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="s2">&quot;metadata&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 显示输入 json 中使用的设置，默认为 “false”</span>
<span class="w">      </span><span class="s2">&quot;useLiteralContent&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 显示输入json中使用的设置，默认为 “ipfs“</span>
<span class="w">      </span><span class="s2">&quot;bytecodeHash&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ipfs&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 对 Solidity 来说是必选的：用以生成该元数据的文件路径和合约名或库名</span>
<span class="w">    </span><span class="s2">&quot;compilationTarget&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;myDirectory/myFile.sol&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MyContract&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 对 Solidity 来说是必须的：所使用的库合约的地址</span>
<span class="w">    </span><span class="s2">&quot;libraries&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;MyLib&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0x123123...&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// 必选：合约的生成信息</span>
<span class="w">  </span><span class="s2">&quot;output&quot;</span><span class="o">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 必选：合约的 ABI 定义，见 “合约 ABI 规范”</span>
<span class="w">    </span><span class="s2">&quot;abi&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="cm">/* ... */</span><span class="p">],</span>
<span class="w">    </span><span class="c1">// 必选：合约的开发者 NatSpec 文档</span>
<span class="w">    </span><span class="s2">&quot;devdoc&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;version&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="c1">// NatSpec 版本</span>
<span class="w">      </span><span class="s2">&quot;kind&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;dev&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 合约中 @author NatSpec 字段的内容</span>
<span class="w">      </span><span class="s2">&quot;author&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;John Doe&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 合约中 @title NatSpec 字段的内容</span>
<span class="w">      </span><span class="s2">&quot;title&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MyERC20: an example ERC20&quot;</span>
<span class="w">      </span><span class="c1">// 合约中 @dev NatSpec 字段的内容</span>
<span class="w">      </span><span class="s2">&quot;details&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Interface of the ERC20 standard as defined in the EIP. See https://eips.ethereum.org/EIPS/eip-20 for details&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;methods&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;transfer(address,uint256)&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// 方法的 @dev NatSpec 字段的内容</span>
<span class="w">          </span><span class="s2">&quot;details&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Returns a boolean value indicating whether the operation succeeded. Must be called by the token holder address&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="c1">// 方法的 @param NatSpec 字段的内容</span>
<span class="w">          </span><span class="s2">&quot;params&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;_value&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The amount tokens to be transferred&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;_to&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The receiver address&quot;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="c1">// 方法的 @return NatSpec 字段的内容</span>
<span class="w">          </span><span class="s2">&quot;returns&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 如果存在，返回var名称（这里是 “success”）。如果返回的var是未命名的，“_0” 作为键。</span>
<span class="w">            </span><span class="s2">&quot;success&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;a boolean value indicating whether the operation succeeded&quot;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="s2">&quot;stateVariables&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;owner&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// 状态变量的 @dev NatSpec 字段的内容</span>
<span class="w">          </span><span class="s2">&quot;details&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Must be set during contract creation. Can then only be changed by the owner&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="s2">&quot;events&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="s2">&quot;Transfer(address,address,uint256)&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="s2">&quot;details&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Emitted when `value` tokens are moved from one account (`from`) toanother (`to`).&quot;</span>
<span class="w">           </span><span class="s2">&quot;params&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="s2">&quot;from&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The sender address&quot;</span>
<span class="w">             </span><span class="s2">&quot;to&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The receiver address&quot;</span>
<span class="w">             </span><span class="s2">&quot;value&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The token amount&quot;</span>
<span class="w">           </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="c1">// 必选：合约的用户 NatSpec 文档</span>
<span class="w">    </span><span class="s2">&quot;userdoc&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;version&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="c1">// NatSpec 版本</span>
<span class="w">      </span><span class="s2">&quot;kind&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;user&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;methods&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;transfer(address,uint256)&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="s2">&quot;notice&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Transfers `_value` tokens to address `_to`&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="s2">&quot;events&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;Transfer(address,address,uint256)&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="s2">&quot;notice&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;`_value` tokens have been moved from `from` to `to`&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>由于产生的合约的字节码默认包含元数据哈希值，
对元数据的任何改变都可能导致字节码的改变。
这包括对文件名或路径的改变，而且由于元数据包括所有使用的源的哈希值，
一个空白的改变就会导致不同的元数据和不同的字节码。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>上面的ABI定义没有固定的顺序。它可以随着编译器的版本而改变。
不过，从Solidity 0.5.12版本开始，该数组保持一定的顺序。</p>
</div>
<section id="encoding-of-the-metadata-hash-in-the-bytecode">
<span id="id2"></span><h3>在字节码中对元数据哈希值进行编码<a class="headerlink" href="#encoding-of-the-metadata-hash-in-the-bytecode" title="此标题的永久链接"></a></h3>
<p>因为我们将来可能会支持其他方式来检索元数据文件，
所以映射 <code class="docutils literal notranslate"><span class="pre">{&quot;ipfs&quot;:</span> <span class="pre">&lt;IPFS</span> <span class="pre">哈希值&gt;,</span> <span class="pre">&quot;solc&quot;:</span> <span class="pre">&lt;编译器版本&gt;}</span></code> 将以
<a class="reference external" href="https://tools.ietf.org/html/rfc7049">CBOR</a>-编码来存储。
由于映射可能包含更多的键（见下文），而且该编码的开头不容易找到，
所以添加两个字节来表述其长度，以大端方式编码。
当前版本的 Solidity 编译器通常在部署的字节码的末尾添加以下内容</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0xa2
0x64 &#39;i&#39; &#39;p&#39; &#39;f&#39; &#39;s&#39; 0x58 0x22 &lt;34字节的IPFS哈希值&gt;
0x64 &#39;s&#39; &#39;o&#39; &#39;l&#39; &#39;c&#39; 0x43 &lt;3字节的版本编码&gt;
0x00 0x33
</pre></div>
</div>
<p>因此，为了检索数据，可以检查已部署字节码的末尾以匹配该模式，
并且可以使用 IPFS 哈希值来检索文件（如果固定/发布）。</p>
<p>SOLC的发布版本使用如上所示的3个字节的版本编码
（主要、次要和补丁版本号各一个字节），
而预发布版本将使用一个完整的版本字符串，包括提交哈希和构建日期。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>CBOR映射也可以包含其他的键，所以最好是完全解码，
而不是依靠它以 <code class="docutils literal notranslate"><span class="pre">0xa264</span></code> 开始。
例如，如果使用了任何影响代码生成的实验性功能，
映射也将包含 <code class="docutils literal notranslate"><span class="pre">&quot;experimental&quot;:</span> <span class="pre">true</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>编译器目前默认使用元数据的IPFS哈希值，
但将来也可能使用bzzr1哈希值或其他哈希值，
所以不要依赖这个序列以 <code class="docutils literal notranslate"><span class="pre">0xa2</span> <span class="pre">0x64</span> <span class="pre">'i'</span> <span class="pre">'p'</span> <span class="pre">'f'</span> <span class="pre">'s'</span></code> 开始。
我们还可能向这个CBOR结构添加额外的数据，
所以最好的选择是使用一个合适的CBOR解析器。</p>
</div>
</section>
<section id="natspec">
<h3>自动化接口生成和NatSpec 的使用方法<a class="headerlink" href="#natspec" title="此标题的永久链接"></a></h3>
<p>元数据的使用方式如下：一个想要与合约交互的组件
（例如钱包）会检索合约的代码。
它对包含元数据文件的 IPFS/Swarm 哈希的 CBOR 编码部分进行解码。
通过该哈希值，元数据文件被检索出来。该文件被 JSON 解码成一个类似于上述的结构。</p>
<p>然后，该组件可以使用ABI为合约自动生成一个基本的用户界面。</p>
<p>此外，钱包可以使用 NatSpec 用户文档，每当用户与合约交互时，
就会向用户显示一条可读的确认信息，同时要求对交易签名进行授权。</p>
<p>有关其他信息，请阅读 <a class="reference internal" href="index.html#document-natspec-format"><span class="doc">以太坊自然语言规范（NatSpec）格式</span></a>。</p>
</section>
<section id="id3">
<h3>源代码验证的用法<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>为了验证编译，可以通过元数据文件中的链接从IPFS/Swarm检索源码。
正确版本的编译器（应该为“官方”编译器之一）以指定的设置在该输入上被调用。
产生的字节码与创建交易的数据或 <code class="docutils literal notranslate"><span class="pre">CREATE</span></code> 操作码数据进行比较。
这将自动验证元数据，因为其哈希值是字节码的一部分。
多余的数据对应于构造器的输入数据，应该根据接口进行解码并呈现给用户。</p>
<p>在资源库 <a class="reference external" href="https://github.com/ethereum/sourcify">sourcify</a>
(<a class="reference external" href="https://www.npmjs.com/package/source-verify">npm package</a>)，
您可以看到如何使用这一功能的示例代码。</p>
</section>
</section>
<span id="document-abi-spec"></span><section id="abi">
<span id="index-0"></span><span id="id1"></span><h2>合约ABI规范<a class="headerlink" href="#abi" title="此标题的永久链接"></a></h2>
<section id="id2">
<h3>基本设计<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>合约应用二进制接口（ABI）是在以太坊生态系统中与合约交互的标准方式，
包括从区块链外部和合约间的交互。数据根据其类型进行编码，如本规范中所述。
编码不是自描述的，因此需要一种特定的概要（schema）来进行解码。</p>
<p>我们假设合约的接口函数是强类型的，在编译时就知道，并且是静态的。
我们假设所有合约在编译时都有它们所调用的任何合约的接口定义。</p>
<p>本规范不涉及其接口是动态的或其他只有在运行时才知道的合约。</p>
<span class="target" id="abi-function-selector"></span></section>
<section id="index-1">
<span id="id3"></span><h3>函数选择器<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>一个函数调用数据的前四个字节指定了要调用的函数。
它是函数签名的 Keccak-256 哈希值的前4字节（高位在左的大端序）。
签名被定义为基本原型的典型表达，没有数据位置的指定，
也就是带有括号的参数类型列表的函数名。参数类型由一个逗号分割 - 不使用空格。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>一个函数的返回类型不是这个签名的一部分。在 <a class="reference internal" href="index.html#overload-function"><span class="std std-ref">Solidity的函数重载</span></a> 中，
返回类型不被考虑。原因是为了保持函数调用解析与上下文无关。
然而 <a class="reference internal" href="#abi-json"><span class="std std-ref">JSON描述的ABI</span></a> 却同时包含了输入和输出。</p>
</div>
</section>
<section id="id4">
<h3>参数编码<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>从第5字节开始是被编码的参数。这种编码也被用在其他地方，
比如，返回值和事件的参数也会被用同样的方式进行编码，
而用来指定函数的4个字节则不需要再进行编码。</p>
</section>
<section id="id5">
<h3>类型<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>以下是基础类型：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint&lt;M&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">M</span></code> 位的无符号整数， <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">256</span></code>， <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">%</span> <span class="pre">8</span> <span class="pre">==</span> <span class="pre">0</span></code>。例如： <code class="docutils literal notranslate"><span class="pre">uint32</span></code>， <code class="docutils literal notranslate"><span class="pre">uint8</span></code>， <code class="docutils literal notranslate"><span class="pre">uint256</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int&lt;M&gt;</span></code>： 以 2 的补码作为符号的 <code class="docutils literal notranslate"><span class="pre">M</span></code> 位整数， <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">256</span></code>， <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">%</span> <span class="pre">8</span> <span class="pre">==</span> <span class="pre">0</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code>： 除了字面上的意思和语言类型的区别以外，等价于 <code class="docutils literal notranslate"><span class="pre">uint160</span></code>，
在计算和函数选择器中，通常使用 <code class="docutils literal notranslate"><span class="pre">address</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint</span></code>， <code class="docutils literal notranslate"><span class="pre">int</span></code>： <code class="docutils literal notranslate"><span class="pre">uint256</span></code>， <code class="docutils literal notranslate"><span class="pre">int256</span></code> 各自的同义词.
在计算和函数选择器中，通常使用 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int256</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>： 等价于 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>，取值限定为 0 或 1。在计算和函数选择器中，通常使用 <code class="docutils literal notranslate"><span class="pre">bool</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed&lt;M&gt;x&lt;N&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">M</span></code> 位的有符号的固定小数位的十进制数字， <code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">&lt;=</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">256</span></code>，
<code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">%</span> <span class="pre">8</span> <span class="pre">==</span> <span class="pre">0</span></code>， 且 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">80</span></code>， 其中值 <code class="docutils literal notranslate"><span class="pre">v</span></code> 是 <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">/</span> <span class="pre">(10</span> <span class="pre">**</span> <span class="pre">N)</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ufixed&lt;M&gt;x&lt;N&gt;</span></code>： 无符号的 <code class="docutils literal notranslate"><span class="pre">fixed&lt;M&gt;x&lt;N&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed</span></code>， <code class="docutils literal notranslate"><span class="pre">ufixed</span></code>：  <code class="docutils literal notranslate"><span class="pre">fixed128x18</span></code>， <code class="docutils literal notranslate"><span class="pre">ufixed128x18</span></code> 各自的同义词。
在计算和函数选择器中，通常使用 <code class="docutils literal notranslate"><span class="pre">fixed128x18</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ufixed128x18</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bytes&lt;M&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">M</span></code> 字节的二进制类型， <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code>： 一个地址（20 字节）之后紧跟一个函数选择器 （4 字节）。编码之后等价于 <code class="docutils literal notranslate"><span class="pre">bytes24</span></code>。</p></li>
</ul>
<p>以下是定长数组类型：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;type&gt;[M]</span></code>： 有 <code class="docutils literal notranslate"><span class="pre">M</span></code> 个元素的定长数组， <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>，数组元素为给定类型。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>虽然这个ABI规范可以表达零元素的固定长度数组，但编译器不支持它们。</p>
</div>
</li>
</ul>
<p>以下是非定长类型：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bytes</span></code>： 动态大小的字节序列。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code>： 动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;type&gt;[]</span></code>： 元素为给定类型的变长数组。</p></li>
</ul>
<p>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个元组（tuple）：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(T1,T2,...,Tn)</span></code>： 由 <code class="docutils literal notranslate"><span class="pre">T1</span></code>，...， <code class="docutils literal notranslate"><span class="pre">Tn</span></code>， <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 构成的 元组</p></li>
</ul>
<p>用元组构成元组，用元组构成数组等等也是可能的。另外也可以构成零元组（当 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code> 时）。</p>
<section id="solidityabi">
<h4>将Solidity映射到ABI类型<a class="headerlink" href="#solidityabi" title="此标题的永久链接"></a></h4>
<p>Solidity 支持上面介绍的除了元祖之外的所有同名类型。
另一方面，一些 Solidity 类型不被 ABI 支持。
下表在左栏显示了不属于ABI的Solidity类型，在右栏显示了代表它们的ABI类型。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solidity</p></th>
<th class="head"><p>ABI</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="index.html#address"><span class="std std-ref">address payable</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">address</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="index.html#contracts"><span class="std std-ref">合约</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">address</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="index.html#enums"><span class="std std-ref">枚举</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="index.html#user-defined-value-types"><span class="std std-ref">用户自定义类型</span></a></p></td>
<td><p>其基本值类型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="index.html#structs"><span class="std std-ref">结构体</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">元组（tuple）</span></code></p></td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">0.8.0</span></code> 版本之前，枚举可以有超过256个成员，并由最小的整数类型表示，其大小刚好可以容纳任何成员的值。</p>
</div>
</section>
</section>
<section id="id6">
<h3>编码的设计标准<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<p>编码被设计为具有以下属性，如果一些参数是嵌套的数组，这些属性特别有用：</p>
<ol class="arabic simple">
<li><p>访问一个值所需的读取次数最多是参数数组结构内的值的深度，
即需要四次读取次数来检索 <code class="docutils literal notranslate"><span class="pre">a_i[k][l][r]</span></code>。
在ABI的前一个版本中，在最坏的情况下，读取次数的数量与动态参数的总数成线性比例。</p></li>
<li><p>变量或数组元素的数据不与其他数据交错，它是可重定位的，即它只使用相对的 “地址”。</p></li>
</ol>
</section>
<section id="id7">
<h3>编码的形式化规范<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<p>我们区分了静态和动态类型。静态类型是直接编码的，
而动态类型是在当前块之后的一个单独分配的位置进行编码。</p>
<p><strong>定义：</strong> 以下类型被称为“动态”：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p></li>
<li><p>任意类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的数组 <code class="docutils literal notranslate"><span class="pre">T[]</span></code></p></li>
<li><p>任意动态类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的定长数组 <code class="docutils literal notranslate"><span class="pre">T[k]</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></p></li>
<li><p>由动态的 <code class="docutils literal notranslate"><span class="pre">Ti</span></code> （ <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span></code> ）构成的元组 <code class="docutils literal notranslate"><span class="pre">(T1,...,Tk)</span></code></p></li>
</ul>
<p>所有其他类型都被称为“静态”。</p>
<p><strong>定义：</strong> <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> 是一个二进制字符串 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的字节长度。
<code class="docutils literal notranslate"><span class="pre">len(a)</span></code> 的类型被呈现为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>。</p>
<p>我们把实际的编码 <code class="docutils literal notranslate"><span class="pre">enc</span></code> 定义为一个由ABI类型到二进制字符串的值的映射，
因而，当且仅当 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的类型是动态的， <code class="docutils literal notranslate"><span class="pre">len(enc(X))</span></code> 才会依赖于 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的值。</p>
<p><strong>定义：</strong> 对任意ABI值 <code class="docutils literal notranslate"><span class="pre">X</span></code>，我们根据 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的实际类型递归地定义 <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code>。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">(T1,...,Tk)</span></code> 对于 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 且任意类型 <code class="docutils literal notranslate"><span class="pre">T1</span></code>， ...， <code class="docutils literal notranslate"><span class="pre">Tk</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">head(X(1))</span> <span class="pre">...</span> <span class="pre">head(X(k))</span> <span class="pre">tail(X(1))</span> <span class="pre">...</span> <span class="pre">tail(X(k))</span></code></p>
<p>这里， <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">(X(1),</span> <span class="pre">...,</span> <span class="pre">X(k))</span></code> 并且
<code class="docutils literal notranslate"><span class="pre">head</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tail</span></code> 被定义为如下 <code class="docutils literal notranslate"><span class="pre">Ti</span></code> ：</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">Ti</span></code> 是静态类型：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">head(X(i))</span> <span class="pre">=</span> <span class="pre">enc(X(i))</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tail(X(i))</span> <span class="pre">=</span> <span class="pre">&quot;&quot;</span></code> （空字符串）</p>
</div></blockquote>
<p>否则，即 <code class="docutils literal notranslate"><span class="pre">Ti</span></code> 是动态类型时，它们被定义为：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">head(X(i))</span> <span class="pre">=</span> <span class="pre">enc(len(</span> <span class="pre">head(X(1))</span> <span class="pre">...</span> <span class="pre">head(X(k))</span> <span class="pre">tail(X(1))</span> <span class="pre">...</span> <span class="pre">tail(X(i-1))</span> <span class="pre">))</span></code>
<code class="docutils literal notranslate"><span class="pre">tail(X(i))</span> <span class="pre">=</span> <span class="pre">enc(X(i))</span></code></p>
</div></blockquote>
<p>注意，在动态类型的情况下，由于 head 部分的长度仅取决于类型而非值，所以 <code class="docutils literal notranslate"><span class="pre">head(X(i))</span></code> 是定义明确的。
它的值是从 <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code> 的开始算起的， <code class="docutils literal notranslate"><span class="pre">tail(X(i))</span></code> 的起始位在 <code class="docutils literal notranslate"><span class="pre">head(X(i))</span></code> 中的偏移量。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">T[k]</span></code> 对于任意 <code class="docutils literal notranslate"><span class="pre">T</span></code> 和 <code class="docutils literal notranslate"><span class="pre">k</span></code>：</p>
<p><code class="docutils literal notranslate"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc((X[0],</span> <span class="pre">...,</span> <span class="pre">X[k-1]))</span></code></p>
<p>即，它就像是个由相同类型的 <code class="docutils literal notranslate"><span class="pre">k</span></code> 个元素组成的元组那样被编码的。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">T[]</span></code> 当 <code class="docutils literal notranslate"><span class="pre">X</span></code> 有 <code class="docutils literal notranslate"><span class="pre">k</span></code> 个元素 （ <code class="docutils literal notranslate"><span class="pre">k</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>）：</p>
<p><code class="docutils literal notranslate"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc(k)</span> <span class="pre">enc([X[0],</span> <span class="pre">...,</span> <span class="pre">X[k-1]])</span></code></p>
<p>即，它就像是个由静态大小 <code class="docutils literal notranslate"><span class="pre">k</span></code> 的数组那样被编码的，且由元素的个数作为前缀。</p>
</li>
<li><p>具有 <code class="docutils literal notranslate"><span class="pre">k</span></code> 字节长度的 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>， （假设其类型为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>）：</p>
<p><code class="docutils literal notranslate"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc(k)</span> <span class="pre">pad_right(X)</span></code>，即，字节数被编码为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>，紧跟着实际的 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的字节码序列，
再在前边（左边）补上可以使 <code class="docutils literal notranslate"><span class="pre">len(enc(X))</span></code> 成为 32 的倍数的最少数量的 0 值字节数据。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code>：</p>
<p><code class="docutils literal notranslate"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc(enc_utf8(X))</span></code>， 即 <code class="docutils literal notranslate"><span class="pre">X</span></code> 被 UTF-8 编码，且在后续编码中将这个值解释为 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 类型。
注意，在随后的编码中使用的长度是其 UTF-8 编码的字符串的字节数，而不是其字符数。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint&lt;M&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code> 是在 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的大端序编码的高位（左侧）补充若干 0 值字节以使其长度成为 32 字节。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code>： 与 <code class="docutils literal notranslate"><span class="pre">uint160</span></code> 的情况相同。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int&lt;M&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code> 是在 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的大端序的 2 的补码编码的高位（左侧）添加若干字节数据以使其长度成为 32 字节；
对于负数，添加值为 <code class="docutils literal notranslate"><span class="pre">0xff</span></code> 的字节数据，对于正数，添加 0 值字节数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>： 与 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 的情况相同， <code class="docutils literal notranslate"><span class="pre">1</span></code> 用来表示 <code class="docutils literal notranslate"><span class="pre">true</span></code>， <code class="docutils literal notranslate"><span class="pre">0</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed&lt;M&gt;x&lt;N&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">enc(X</span> <span class="pre">*</span> <span class="pre">10**N)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">10**N</span></code> 可以理解为 <code class="docutils literal notranslate"><span class="pre">int256</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed</span></code>： 与 <code class="docutils literal notranslate"><span class="pre">fixed128x18</span></code> 的情况相同。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ufixed&lt;M&gt;x&lt;N&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">enc(X</span> <span class="pre">*</span> <span class="pre">10**N)</span></code> ，其中 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">10**N</span></code> 可以理解为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ufixed</span></code>： 与 <code class="docutils literal notranslate"><span class="pre">ufixed128x18</span></code> 的情况相同。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bytes&lt;M&gt;</span></code>： <code class="docutils literal notranslate"><span class="pre">enc(X)</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">X</span></code> 的字节序列加上为使长度成为 32 字节而添加的若干 0 值字节。</p></li>
</ul>
<p>注意，对于任意的 <code class="docutils literal notranslate"><span class="pre">X</span></code>， <code class="docutils literal notranslate"><span class="pre">len(enc(X))</span></code> 都是 32 的倍数。</p>
</section>
<section id="id8">
<h3>函数选择器和参数编码<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h3>
<p>总而言之，对带有参数 <code class="docutils literal notranslate"><span class="pre">a_1,</span> <span class="pre">...,</span> <span class="pre">a_n</span></code> 的函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的调用被编码为：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">function_selector(f)</span> <span class="pre">enc((a_1,</span> <span class="pre">...,</span> <span class="pre">a_n))</span></code></p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> 的返回值 <code class="docutils literal notranslate"><span class="pre">v_1,</span> <span class="pre">...,</span> <span class="pre">v_k</span></code> 会被编码为：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">enc((v_1,</span> <span class="pre">...,</span> <span class="pre">v_k))</span></code></p>
</div></blockquote>
<p>也就是说，返回值会被组合为一个元组（tuple）进行编码。</p>
</section>
<section id="id9">
<h3>示例<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h3>
<p>给定一个合约：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEZvbyB7CiAgICBmdW5jdGlvbiBiYXIoYnl0ZXMzWzJdIG1lbW9yeSkgcHVibGljIHB1cmUge30KICAgIGZ1bmN0aW9uIGJheih1aW50MzIgeCwgYm9vbCB5KSBwdWJsaWMgcHVyZSByZXR1cm5zIChib29sIHIpIHsgciA9IHggPiAzMiB8fCB5OyB9CiAgICBmdW5jdGlvbiBzYW0oYnl0ZXMgbWVtb3J5LCBib29sLCB1aW50W10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7fQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">bar</span><span class="p">(</span>bytes3<span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">baz</span><span class="p">(</span><span class="kt">uint32</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">32</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>y<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sam</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>因此，对于我们的例子 <code class="docutils literal notranslate"><span class="pre">Foo</span></code>，如果我们想用 <code class="docutils literal notranslate"><span class="pre">69</span></code> 和 <code class="docutils literal notranslate"><span class="pre">true</span></code> 做参数调用 <code class="docutils literal notranslate"><span class="pre">baz</span></code>，
我们总共需要传送 68 字节，可以分解为：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0xcdcd77c0</span></code>： 方法ID。这源自ASCII格式的 <code class="docutils literal notranslate"><span class="pre">baz(uint32,bool)</span></code> 签名的 Keccak 哈希的前 4 字节。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000045</span></code>： 第一个参数，
一个被用 0 值字节补充到 32 字节的 uint32 值 <code class="docutils literal notranslate"><span class="pre">69</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>： 第二个参数，
一个被用 0 值字节补充到 32 字节的 boolean 值 <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></li>
</ul>
<p>合起来就是:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001
</pre></div>
</div>
<p>它返回一个 <code class="docutils literal notranslate"><span class="pre">bool</span></code>。比如它返回 <code class="docutils literal notranslate"><span class="pre">false</span></code>，
那么它的输出将是一个字节数组 <code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000000</span></code>，
一个 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 值。</p>
<p>如果我们想用 <code class="docutils literal notranslate"><span class="pre">[&quot;abc&quot;,</span> <span class="pre">&quot;def&quot;]</span></code> 做参数调用 <code class="docutils literal notranslate"><span class="pre">bar</span></code>，我们总共需要传送 68 字节，可以分解为：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0xfce353f6</span></code>： 方法ID。源自 <code class="docutils literal notranslate"><span class="pre">bar(bytes3[2])</span></code> 的签名。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x6162630000000000000000000000000000000000000000000000000000000000</span></code>： 第一个参数的第一部分，
一个 <code class="docutils literal notranslate"><span class="pre">bytes3</span></code> 值 <code class="docutils literal notranslate"><span class="pre">&quot;abc&quot;</span></code> （左对齐）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x6465660000000000000000000000000000000000000000000000000000000000</span></code>： 第一个参数的第二部分，
一个 <code class="docutils literal notranslate"><span class="pre">bytes3</span></code> 值 <code class="docutils literal notranslate"><span class="pre">&quot;def&quot;</span></code> （左对齐）。</p></li>
</ul>
<p>合起来就是:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000
</pre></div>
</div>
<p>如果我们想用 <code class="docutils literal notranslate"><span class="pre">&quot;dave&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">true</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code> 作为参数调用 <code class="docutils literal notranslate"><span class="pre">sam</span></code>，
我们总共需要传送 292 字节，可以分解为：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0xa5643bf2</span></code>： 方法ID。这是从签名 <code class="docutils literal notranslate"><span class="pre">sam(bytes,bool,uint256[])</span></code> 中导出的。注意， <code class="docutils literal notranslate"><span class="pre">uint</span></code> 被替换为其典型代表 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000060</span></code>： 第一个参数（动态类型）的数据部分的位置，即从参数编码块开始位置算起的字节数。在这里，是 <code class="docutils literal notranslate"><span class="pre">0x60</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>： 第二个参数：boolean 的 true。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x00000000000000000000000000000000000000000000000000000000000000a0</span></code>： 第三个参数（动态类型）的数据部分的位置，由字节数计量。在这里，是 <code class="docutils literal notranslate"><span class="pre">0xa0</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000004</span></code>： 第一个参数的数据部分，以字节数组的元素个数作为开始，在这里，是 4。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x6461766500000000000000000000000000000000000000000000000000000000</span></code>： 第一个参数的内容： <code class="docutils literal notranslate"><span class="pre">&quot;dave&quot;</span></code> 的 UTF-8 编码（在这里等同于 ASCII 编码），并在右侧（低位）用 0 值字节补充到 32 字节。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code>： 第三个参数的数据部分，以数组的元素个数作为开始，在这里，是 3。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>： 第三个参数的第一个数组元素。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code>： 第三个参数的第二个数组元素。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code>： 第三个参数的第三个数组元素。</p></li>
</ul>
<p>合起来就是:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
</pre></div>
</div>
</section>
<section id="id10">
<h3>动态类型的使用<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<p>用值为 <code class="docutils literal notranslate"><span class="pre">(0x123,</span> <span class="pre">[0x456,</span> <span class="pre">0x789],</span> <span class="pre">&quot;1234567890&quot;,</span> <span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;)</span></code> 的签名参数调用
函数 <code class="docutils literal notranslate"><span class="pre">f(uint256,uint32[],bytes10,bytes)</span></code>，其的编码方式如下：</p>
<p>取得 <code class="docutils literal notranslate"><span class="pre">sha3(&quot;f(uint256,uint32[],bytes10,bytes)&quot;)</span></code> 的前 4 字节，也就是 <code class="docutils literal notranslate"><span class="pre">0x8be65246</span></code>。
然后我们对所有 4 个参数的头部进行编码。 对静态类型 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytes10</span></code>，
这些我们可以直接传递的值，对于动态类型 <code class="docutils literal notranslate"><span class="pre">uint32[]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>，
我们使用的字节数偏移量是它们的数据区域的起始位置，
由需编码的值的开始位置算起（也就是说，不计算包含了函数签名的前 4 字节），这就是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000123</span></code> （ <code class="docutils literal notranslate"><span class="pre">0x123</span></code> 补充到 32 字节）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000080</span></code> （第二个参数的数据部分起始位置的偏移量，4*32 字节，正好是头部的大小）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x3132333435363738393000000000000000000000000000000000000000000000</span></code> （ <code class="docutils literal notranslate"><span class="pre">&quot;1234567890&quot;</span></code> 从右边补充到 32 字节）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x00000000000000000000000000000000000000000000000000000000000000e0</span></code> （第四个参数的数据部分起始位置的偏移量 = 第一个动态参数的数据部分起始位置的偏移量 + 第一个动态参数的数据部分的长度 = 4*32 + 3*32，参考后文）</p></li>
</ul>
<p>在此之后，跟着第一个动态参数的数据部分， <code class="docutils literal notranslate"><span class="pre">[0x456,</span> <span class="pre">0x789]</span></code> ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code> （数组元素个数，2）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000456</span></code> （第一个数组元素）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000789</span></code> （第二个数组元素）</p></li>
</ul>
<p>最后，我们将第二个动态参数的数据部分 <code class="docutils literal notranslate"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></code> 进行编码：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x000000000000000000000000000000000000000000000000000000000000000d</span></code> （元素个数，在这里是字节数：13）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span></code> （ <code class="docutils literal notranslate"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></code> 从右边补充到 32 字节）</p></li>
</ul>
<p>最后，合并到一起的编码就是（为了清晰，在函数选择器和每 32 字节之后加了换行）：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8be65246
  0000000000000000000000000000000000000000000000000000000000000123
  0000000000000000000000000000000000000000000000000000000000000080
  3132333435363738393000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000e0
  0000000000000000000000000000000000000000000000000000000000000002
  0000000000000000000000000000000000000000000000000000000000000456
  0000000000000000000000000000000000000000000000000000000000000789
  000000000000000000000000000000000000000000000000000000000000000d
  48656c6c6f2c20776f726c642100000000000000000000000000000000000000
</pre></div>
</div>
<p>让我们使用相同的原理来对一个签名为 <code class="docutils literal notranslate"><span class="pre">g(uint256[][],string[])</span></code> ，参数值为
<code class="docutils literal notranslate"><span class="pre">([[1,</span> <span class="pre">2],</span> <span class="pre">[3]],</span> <span class="pre">[&quot;one&quot;,</span> <span class="pre">&quot;two&quot;,</span> <span class="pre">&quot;three&quot;])</span></code> 的函数来进行编码；但从最原子的部分开始：</p>
<p>首先我们将第一个根数组 <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3]]</span></code> 的第一个嵌入的动态数组 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> 的长度和数据进行编码：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code>  (第一个数组中的元素数量 2；元素本身是 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>  (第一个元素)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code>  (第二个元素)</p></li>
</ul>
<p>然后我们对第一个根数组 <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3]]</span></code> 的第二个嵌入式动态数组 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 的长度和数据进行编码：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code> (第二个数组中的元素数量 1；元素数据是 <code class="docutils literal notranslate"><span class="pre">3</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code>  (第一个元素)</p></li>
</ul>
<p>然后我们需要为各自的动态数组 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 找到偏移量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code>。
为了计算偏移量，我们可以看一下第一个根数组的编码数据 <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3]]</span></code> 在编码中枚举每一行。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 - a                                                                - [1, 2] 的偏移量
1 - b                                                                - [3] 的偏移量
2 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 数组的计数
3 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码
4 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码
5 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 数组的计数
6 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码
</pre></div>
</div>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 指向数组 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> 内容的开始位置，即第 2 行的开始（64 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0x0000000000000000000000000000000000000000000000000000000000000040</span></code>。</p>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">b</span></code> 指向数组 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 内容的开始位置，即第 5 行的开始（160 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">0x00000000000000000000000000000000000000000000000000000000000000a0</span></code>。</p>
<p>然后我们对第二个根数组的嵌入字符串进行编码：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code> (单词 <code class="docutils literal notranslate"><span class="pre">&quot;one&quot;</span></code> 中的字符个数)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x6f6e650000000000000000000000000000000000000000000000000000000000</span></code> (单词 <code class="docutils literal notranslate"><span class="pre">&quot;one&quot;</span></code> 的 utf8 编码)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code> (单词 <code class="docutils literal notranslate"><span class="pre">&quot;two&quot;</span></code> 中的字符个数)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x74776f0000000000000000000000000000000000000000000000000000000000</span></code> (单词 <code class="docutils literal notranslate"><span class="pre">&quot;two&quot;</span></code> 的 utf8 编码)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000005</span></code> (单词 <code class="docutils literal notranslate"><span class="pre">&quot;three&quot;</span></code> 中的字符个数)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x7468726565000000000000000000000000000000000000000000000000000000</span></code> (单词 <code class="docutils literal notranslate"><span class="pre">&quot;three&quot;</span></code> 的 utf8 编码)</p></li>
</ul>
<p>作为与第一个根数组的并列，因为字符串也属于动态元素，我们也需要找到它们的偏移量 <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code> 和 <code class="docutils literal notranslate"><span class="pre">e</span></code>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 - c                                                                - &quot;one&quot; 的偏移量
1 - d                                                                - &quot;two&quot; 的偏移量
2 - e                                                                - &quot;three&quot; 的偏移量
3 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;one&quot; 的字符计数
4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - &quot;one&quot; 的编码
5 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;two&quot; 的字符计数
6 - 74776f0000000000000000000000000000000000000000000000000000000000 - &quot;two&quot; 的编码
7 - 0000000000000000000000000000000000000000000000000000000000000005 - &quot;three&quot; 的字符计数
8 - 7468726565000000000000000000000000000000000000000000000000000000 - &quot;three&quot; 的编码
</pre></div>
</div>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">c</span></code> 指向字符串 <code class="docutils literal notranslate"><span class="pre">&quot;one&quot;</span></code> 内容的开始位置，即第 3 行的开始（96 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">0x0000000000000000000000000000000000000000000000000000000000000060</span></code>。</p>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">d</span></code> 指向字符串 <code class="docutils literal notranslate"><span class="pre">&quot;two&quot;</span></code> 内容的开始位置，即第 5 行的开始（160 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">0x00000000000000000000000000000000000000000000000000000000000000a0</span></code>。</p>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">e</span></code> 指向字符串 <code class="docutils literal notranslate"><span class="pre">&quot;three&quot;</span></code> 内容的开始位置，即第 7 行的开始（224 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">0x00000000000000000000000000000000000000000000000000000000000000e0</span></code>。</p>
<p>注意，根数组的嵌入元素的编码并不互相依赖，且具有对于函数签名 <code class="docutils literal notranslate"><span class="pre">g(string[],uint256[][])</span></code> 所相同的编码。</p>
<p>然后我们对第一个根数组的长度进行编码：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code> (第一个根数组的元素数量 2；这些元素本身是 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[3]</span></code>)</p></li>
</ul>
<p>而后我们对第二个根数组的长度进行编码：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code>  (第二个根数组的元素数量 3；这些字符串本身是 <code class="docutils literal notranslate"><span class="pre">&quot;one&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">&quot;two&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;three&quot;</span></code>)</p></li>
</ul>
<p>最后，我们找到根动态数组元素 <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3]]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[&quot;one&quot;,</span> <span class="pre">&quot;two&quot;,</span> <span class="pre">&quot;three&quot;]</span></code> 的偏移量 <code class="docutils literal notranslate"><span class="pre">f</span></code> 和 <code class="docutils literal notranslate"><span class="pre">g</span></code>。
汇编数据的正确顺序如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x2289b18c                                                            - 函数签名
 0 - f                                                                - [[1, 2], [3]] 的偏移量
 1 - g                                                                - [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] 的偏移量
 2 - 0000000000000000000000000000000000000000000000000000000000000002 - [[1, 2], [3]] 的元素计数
 3 - 0000000000000000000000000000000000000000000000000000000000000040 - [1, 2] 的偏移量
 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - [3] 的偏移量
 5 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的元素计数
 6 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码
 7 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码
 8 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的元素计数
 9 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码
10 - 0000000000000000000000000000000000000000000000000000000000000003 - [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] 的元素计数
11 - 0000000000000000000000000000000000000000000000000000000000000060 - 的偏移量&quot;one&quot;
12 - 00000000000000000000000000000000000000000000000000000000000000a0 - 的偏移量&quot;two&quot;
13 - 00000000000000000000000000000000000000000000000000000000000000e0 - 的偏移量&quot;three&quot;
14 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;one&quot; 的字符计数
15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - &quot;one&quot; 的编码
16 - 0000000000000000000000000000000000000000000000000000000000000003 - &quot;two&quot; 的字符计数
17 - 74776f0000000000000000000000000000000000000000000000000000000000 - &quot;two&quot; 的编码
18 - 0000000000000000000000000000000000000000000000000000000000000005 - &quot;three&quot; 的字符计数
19 - 7468726565000000000000000000000000000000000000000000000000000000 - &quot;three&quot; 的编码
</pre></div>
</div>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">f</span></code> 指向数组 <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3]]</span></code> 内容的开始位置，即第 2 行的开始（64 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">0x0000000000000000000000000000000000000000000000000000000000000040</span></code>。</p>
<p>偏移量 <code class="docutils literal notranslate"><span class="pre">g</span></code> 指向数组 <code class="docutils literal notranslate"><span class="pre">[&quot;one&quot;,</span> <span class="pre">&quot;two&quot;,</span> <span class="pre">&quot;three&quot;]</span></code> 内容的开始位置，即第 10 行的开始（320 字节）；
所以 <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">0x0000000000000000000000000000000000000000000000000000000000000140</span></code>。</p>
</section>
<section id="abi-events">
<span id="id11"></span><h3>事件<a class="headerlink" href="#abi-events" title="此标题的永久链接"></a></h3>
<p>事件是Ethereum日志/事件观察协议的一个抽象。日志条目提供了合约的地址，
一系列最多四个主题和一些任意长度的二进制数据。
事件利用现有的函数ABI，以便将其（连同接口规范）解释为一个正确的类型化结构。</p>
<p>给定一个事件名称和一系列的事件参数，我们把它们分成两个子系列：那些有索引的和那些没有索引的。
那些被索引的参数，可能多达3个（对于非匿名事件）或4个（对于匿名事件），
与事件签名的Keccak散列一起使用，形成日志条目的主题。
那些没有索引的则构成事件的字节数组。</p>
<p>实际上，使用该ABI的日志条目被描述为:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code>： 合约的地址（由以太坊真正提供）;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">topics[0]</span></code>： <code class="docutils literal notranslate"><span class="pre">keccak(EVENT_NAME+&quot;(&quot;+EVENT_ARGS.map(canonical_type_of).join(&quot;,&quot;)+&quot;)&quot;)</span></code>
<code class="docutils literal notranslate"><span class="pre">canonical_type_of</span></code> 是一个可以返回给定参数的权威类型的函数，例如，对 <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">indexed</span> <span class="pre">foo</span></code> 它会返回 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>）。
如果事件被声明为 <code class="docutils literal notranslate"><span class="pre">anonymous</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">topics[0]</span></code> 不会被生成；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">topics[n]</span></code>： 如果事件没有被声明为 <code class="docutils literal notranslate"><span class="pre">anonymous</span></code>， 则为 <code class="docutils literal notranslate"><span class="pre">abi_encode(EVENT_INDEXED_ARGS[n</span> <span class="pre">-</span> <span class="pre">1])</span></code>
或者如果它被声明为该类型，则为 <code class="docutils literal notranslate"><span class="pre">abi_encode(EVENT_INDEXED_ARGS[n])</span></code>
（ <code class="docutils literal notranslate"><span class="pre">EVENT_INDEXED_ARGS</span></code> 是被索引的 <code class="docutils literal notranslate"><span class="pre">EVENT_ARGS</span></code> 的系列）;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>： <code class="docutils literal notranslate"><span class="pre">EVENT_NON_INDEXED_ARGS</span></code> 的ABI编码
（ <code class="docutils literal notranslate"><span class="pre">EVENT_NON_INDEXED_ARGS</span></code> 是一系列没有索引的 <code class="docutils literal notranslate"><span class="pre">EVENT_ARGS</span></code>， <code class="docutils literal notranslate"><span class="pre">abi_encode</span></code> 是ABI编码函数，
用于从一个函数返回一系列类型的值，如上所述）。</p></li>
</ul>
<p>对于所有长度不超过32字节的类型， <code class="docutils literal notranslate"><span class="pre">EVENT_INDEXED_ARGS</span></code> 数组直接包含数值，填充或符号扩展（对于有符号整数）到32字节，
就像常规ABI编码一样。然而，对于所有 “复杂” 类型或动态长度的类型，包括所有数组， <code class="docutils literal notranslate"><span class="pre">string</span></code>， <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和结构，
<code class="docutils literal notranslate"><span class="pre">EVENT_INDEXED_ARGS</span></code> 将包含 <em>Keccak散列</em> 的特殊就地编码值（见 <a class="reference internal" href="#indexed-event-encoding"><span class="std std-ref">索引事件参数的编码</span></a>），
而不是直接编码的值。这允许应用程序有效地查询动态长度类型的值（通过设置编码值的哈希值作为主题），
但使应用程序无法解码他们没有查询到的索引值。对于动态长度类型，
应用程序开发人员面临着对预定值的快速搜索（如果参数有索引）和任意值的可读性之间的权衡（这要求参数不被索引）。
开发者可以通过定义具有两个参数的事件 -- 一个是索引的，一个是不索引的 -- 来克服这种权衡，实现高效搜索和任意可读性。</p>
<span class="target" id="abi-errors"></span></section>
<section id="index-2">
<span id="id12"></span><h3>错误<a class="headerlink" href="#index-2" title="此标题的永久链接"></a></h3>
<p>在合约内部发生故障的情况下，合约可以使用一个特殊的操作码来中止执行，并恢复所有的状态变化。
除了这些效果之外，描述性数据可以返回给调用者。
这种描述性数据是对一个错误及其参数的编码，其方式与函数调用的数据相同。</p>
<p>作为一个例子，让我们考虑以下合约，它的 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 函数总是以 &quot;余额不足&quot; 的自定义错误返回。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgLyp0byovLCB1aW50IGFtb3VudCkgcHVibGljIHB1cmUgewogICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKDAsIGFtb3VudCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">TestToken</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>error<span class="w"> </span>InsufficientBalance<span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">available</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">required</span><span class="p">);</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="cm">/*to*/</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>revert<span class="w"> </span>InsufficientBalance<span class="p">(</span><span class="m m-Decimal">0</span><span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>返回数据的编码方式与函数 <code class="docutils literal notranslate"><span class="pre">InsufficientBalance(0,</span> <span class="pre">amount)</span></code>
对函数 <code class="docutils literal notranslate"><span class="pre">InsufficientBalance(uint256,uint256)</span></code> 的调用方式相同。
即 <code class="docutils literal notranslate"><span class="pre">0xcf479181</span></code>， <code class="docutils literal notranslate"><span class="pre">uint256(0)</span></code>， <code class="docutils literal notranslate"><span class="pre">uint256(amount)</span></code>。</p>
<p>错误选择器 <code class="docutils literal notranslate"><span class="pre">0x00000000</span></code> 和 <code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code> 是保留给将来使用的。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>永远不要相信错误数据。
默认情况下，错误数据通过外部调用在链向上冒泡产生，
这意味着一个合约可能会收到一个它直接调用的任何合约中没有定义的错误。
此外，任何合约都可以通过返回与错误签名相匹配的数据来伪造任何错误，即使该错误没有在任何地方定义。</p>
</div>
</section>
<section id="json">
<span id="abi-json"></span><h3>JSON<a class="headerlink" href="#json" title="此标题的永久链接"></a></h3>
<p>合约接口的JSON格式是由一个函数，事件和错误描述的数组给出的。
一个函数描述是一个带有字段的JSON对象：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>： <code class="docutils literal notranslate"><span class="pre">&quot;function&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">&quot;constructor&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">&quot;receive&quot;</span></code> （ <a class="reference internal" href="index.html#receive-ether-function"><span class="std std-ref">&quot;接收以太币&quot; 函数</span></a> ） 或者 <code class="docutils literal notranslate"><span class="pre">&quot;fallback&quot;</span></code> （ <a class="reference internal" href="index.html#fallback-function"><span class="std std-ref">&quot;默认&quot; 函数</span></a>）；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>： 函数名称；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code>： 数组对象，每个数组对象会包含：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>： 参数名称；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>： 参数的权威类型（详见下文）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">components</span></code>： 供元组（tuple） 类型使用（详见下文）</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">outputs</span></code>： 一个类似于 <code class="docutils literal notranslate"><span class="pre">inputs</span></code> 的数组对象。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stateMutability</span></code>： 为下列值之一： <code class="docutils literal notranslate"><span class="pre">pure</span></code> （<a class="reference internal" href="index.html#pure-functions"><span class="std std-ref">指定为不读取区块链状态</span></a>），
<code class="docutils literal notranslate"><span class="pre">view</span></code> （<a class="reference internal" href="index.html#view-functions"><span class="std std-ref">指定为不修改区块链状态</span></a>），
<code class="docutils literal notranslate"><span class="pre">nonpayable</span></code> （函数不接受以太币 - 默认选项） 和 <code class="docutils literal notranslate"><span class="pre">payable</span></code> （函数可接收以太币）。</p></li>
</ul>
<p>Constructor 和 fallback 函数没有 <code class="docutils literal notranslate"><span class="pre">name</span></code> 或 <code class="docutils literal notranslate"><span class="pre">outputs</span></code>。Fallback 函数也没有 <code class="docutils literal notranslate"><span class="pre">inputs</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>向不接收以太币函数发送非零的以太币将使交易回滚。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在Solidity中，状态可变性 <code class="docutils literal notranslate"><span class="pre">不可支付</span></code> 是完全不指定状态可变性时的修饰语。</p>
</div>
<p>一个事件描述是一个有极其相似字段的 JSON 对象：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>： 总是 <code class="docutils literal notranslate"><span class="pre">&quot;event&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>： 事件名称；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code>： 对象数组，每个数组对象会包含：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>： 参数名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>： 参数的权威类型（相见下文）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">components</span></code>： 供元组（tuple） 类型使用（详见下文）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">indexed</span></code>： 如果此字段是日志的一个主题，则为 <code class="docutils literal notranslate"><span class="pre">true</span></code>， 否则为 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">anonymous</span></code>： 如果事件被声明为 <code class="docutils literal notranslate"><span class="pre">anonymous</span></code>，则为 <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></li>
</ul>
<p>错误消息如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>： 总是 <code class="docutils literal notranslate"><span class="pre">&quot;error&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>： 错误名称；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code>： 对象数组，每个数组对象会包含：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>： 参数名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>： 参数的权威类型（相见下文）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">components</span></code>： 供元组（tuple） 类型使用（详见下文）。</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 JSON 数组中可能有多个具有相同名称的错误，甚至具有相同的签名；
例如，如果错误源自合约中的不同文件或从另一个合约引用。
对于ABI来说，只有错误本身的名称是相关的，而不是它的定义位置。</p>
</div>
<p>例如，</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCgpjb250cmFjdCBUZXN0IHsKICAgIGNvbnN0cnVjdG9yKCkgeyBiID0gaGV4IjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyIjsgfQogICAgZXZlbnQgRXZlbnQodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBldmVudCBFdmVudDIodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIGZvbyh1aW50IGEpIHB1YmxpYyB7IGVtaXQgRXZlbnQoYSwgYik7IH0KICAgIGJ5dGVzMzIgYjsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;12345678901234567890123456789012&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Event</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>a<span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">b</span><span class="p">);</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Event2</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>a<span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">b</span><span class="p">);</span>
<span class="w">    </span>error<span class="w"> </span>InsufficientBalance<span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">available</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">required</span><span class="p">);</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>emit<span class="w"> </span>Event<span class="p">(</span>a<span class="p">,</span><span class="w"> </span>b<span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可由如下 JSON 来表示：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">[{</span>
<span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
<span class="nt">&quot;inputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;available&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;uint256&quot;</span><span class="p">},{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;required&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;uint256&quot;</span><span class="p">}],</span>
<span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;InsufficientBalance&quot;</span>
<span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;event&quot;</span><span class="p">,</span>
<span class="nt">&quot;inputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;uint256&quot;</span><span class="p">,</span><span class="nt">&quot;indexed&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">},{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;bytes32&quot;</span><span class="p">,</span><span class="nt">&quot;indexed&quot;</span><span class="p">:</span><span class="kc">false</span><span class="p">}],</span>
<span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;Event&quot;</span>
<span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;event&quot;</span><span class="p">,</span>
<span class="nt">&quot;inputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;uint256&quot;</span><span class="p">,</span><span class="nt">&quot;indexed&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">},{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;bytes32&quot;</span><span class="p">,</span><span class="nt">&quot;indexed&quot;</span><span class="p">:</span><span class="kc">false</span><span class="p">}],</span>
<span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;Event2&quot;</span>
<span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;function&quot;</span><span class="p">,</span>
<span class="nt">&quot;inputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;uint256&quot;</span><span class="p">}],</span>
<span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span>
<span class="nt">&quot;outputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span>
<span class="p">}]</span>
</pre></div>
</div>
<section id="id13">
<h4>处理元组类型<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h4>
<p>尽管名称被有意地不作为 ABI 编码的一部分，但将它们包含进 JSON 来显示给最终用户是非常合理的。
其结构会按下列方式进行嵌套：</p>
<p>一个拥有 <code class="docutils literal notranslate"><span class="pre">name</span></code>， <code class="docutils literal notranslate"><span class="pre">type</span></code> 和潜在的 <code class="docutils literal notranslate"><span class="pre">components</span></code> 成员的对象描述了某种类型的变量。
直至到达一个元组（tuple） 类型且到那点的存储在 <code class="docutils literal notranslate"><span class="pre">type</span></code> 属性中的字符串以 <code class="docutils literal notranslate"><span class="pre">tuple</span></code> 为前缀，
也就是说，在 <code class="docutils literal notranslate"><span class="pre">tuple</span></code> 之后紧跟一个 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 或有整数 <code class="docutils literal notranslate"><span class="pre">k</span></code> 的 <code class="docutils literal notranslate"><span class="pre">[k]</span></code>，才
能确定一个元组。 元组的组件元素会被存储在成员 <code class="docutils literal notranslate"><span class="pre">components</span></code> 中，
它是一个数组类型，且与顶级对象具有同样的结构，只是在这里不允许 <code class="docutils literal notranslate"><span class="pre">已索引的（indexed）</span></code> 数组元素。</p>
<p>示例代码：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjUgPDAuOS4wOwpwcmFnbWEgYWJpY29kZXIgdjI7Cgpjb250cmFjdCBUZXN0IHsKICAgIHN0cnVjdCBTIHsgdWludCBhOyB1aW50W10gYjsgVFtdIGM7IH0KICAgIHN0cnVjdCBUIHsgdWludCB4OyB1aW50IHk7IH0KICAgIGZ1bmN0aW9uIGYoUyBtZW1vcnksIFQgbWVtb3J5LCB1aW50KSBwdWJsaWMgcHVyZSB7fQogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKFMgbWVtb3J5LCBUIG1lbW9yeSwgdWludCkge30KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.5</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
pragma<span class="w"> </span>abicoder<span class="w"> </span>v2<span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">;</span><span class="w"> </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>b<span class="p">;</span><span class="w"> </span>T<span class="p">[]</span><span class="w"> </span>c<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span>S<span class="w"> </span><span class="kt">memory</span><span class="p">,</span><span class="w"> </span>T<span class="w"> </span><span class="kt">memory</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>S<span class="w"> </span><span class="kt">memory</span><span class="p">,</span><span class="w"> </span>T<span class="w"> </span><span class="kt">memory</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可由如下 JSON 来表示：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;f&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;function&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;inputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;s&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;components&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256[]&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;c&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;tuple[]&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;components&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">              </span><span class="p">{</span>
<span class="w">                </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span>
<span class="w">              </span><span class="p">},</span>
<span class="w">              </span><span class="p">{</span>
<span class="w">                </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span>
<span class="w">              </span><span class="p">}</span>
<span class="w">            </span><span class="p">]</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;components&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;uint256&quot;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nt">&quot;outputs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="abi-packed-mode">
<span id="id14"></span><h3>严格的编码模式<a class="headerlink" href="#abi-packed-mode" title="此标题的永久链接"></a></h3>
<p>严格的编码模式是指导致与上述正式规范中定义的编码完全相同的模式。
这意味着偏移量必须尽可能小，同时还不能在数据区域产生重叠，
因此不允许有间隙。</p>
<p>通常，ABI 解码器是通过遵循偏移指针以简单的方式编写的，
但有些解码器可能会强制执行严格模式。
Solidity ABI 解码器目前并不强制执行严格模式，但编码器总是以严格模式创建数据。</p>
</section>
<section id="id15">
<h3>非标准打包模式<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h3>
<p>通过 <code class="docutils literal notranslate"><span class="pre">abi.encodePacked()</span></code>，Solidity支持一种非标准的打包模式，其中：</p>
<ul class="simple">
<li><p>短于32字节的类型直接连接，没有填充或符号扩展。</p></li>
<li><p>动态类型是直接编码的，没有长度。</p></li>
<li><p>数组元素被填充，但仍被是直接编码</p></li>
</ul>
<p>此外，不支持结构以及嵌套数组。</p>
<p>例如，对 <code class="docutils literal notranslate"><span class="pre">int16(-1),</span> <span class="pre">bytes1(0x42),</span> <span class="pre">uint16(0x03),</span> <span class="pre">string(&quot;Hello,</span> <span class="pre">world!&quot;)</span></code> 进行编码将生成如下结果</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0xffff42000348656c6c6f2c20776f726c6421
  ^^^^                                 int16(-1)
      ^^                               bytes1(0x42)
        ^^^^                           uint16(0x03)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^ 字符串（&quot;Hello, world!&quot;） 没有长度字段
</pre></div>
</div>
<p>更具体地说：</p>
<ul class="simple">
<li><p>在编码过程中，所有东西都是直接编码的。这意味着没有像ABI编码那样区分头和尾，也没有对数组的长度进行编码。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code> 的直接参数被编码，
只要不是数组（或 <code class="docutils literal notranslate"><span class="pre">string</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> ），就不需要填充。</p></li>
<li><p>一个数组的编码是其元素的编码 <strong>与</strong> 填充的连接。</p></li>
<li><p>动态大小的类型，如 <code class="docutils literal notranslate"><span class="pre">string</span></code>， <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">uint[]</span></code>，在编码时没有长度字段。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 的编码不会在末尾应用填充，
除非它是数组或结构体的一部分（然后它被填充为32字节的倍数）。</p></li>
</ul>
<p>一般来说，只要有两个动态大小的元素，编码就会模糊不清，因为缺少长度字段。</p>
<p>如果需要填充，可以使用明确的类型转换： <code class="docutils literal notranslate"><span class="pre">abi.encodePacked(uint16(0x12))</span> <span class="pre">==</span> <span class="pre">hex&quot;0012&quot;</span></code>。</p>
<p>由于在调用函数时不使用打包编码，所以没有特别支持预留函数选择器。
由于编码是模糊的，所以没有解码功能。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果使用 <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encodePacked(a，b))</span></code> 并且 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 都是动态类型，
那么通过将 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的部分移动到 <code class="docutils literal notranslate"><span class="pre">b</span></code> 中，很容易在哈希值中产生冲突，反之亦然。
更具体地说， <code class="docutils literal notranslate"><span class="pre">abi.encodePacked(&quot;a&quot;,</span> <span class="pre">&quot;bc&quot;)</span> <span class="pre">==</span> <span class="pre">abi.encodePacked(&quot;ab&quot;,</span> <span class="pre">&quot;c&quot;)</span></code>。
如果你使用 <code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code> 进行签名、认证或数据完整性，确保总是使用相同的类型，
并检查其中最多一个是动态的。除非有令人信服的理由，否则应首选 <code class="docutils literal notranslate"><span class="pre">abi.encode</span></code>。</p>
</div>
</section>
<section id="indexed-event-encoding">
<span id="id16"></span><h3>索引事件参数的编码<a class="headerlink" href="#indexed-event-encoding" title="此标题的永久链接"></a></h3>
<p>不属于值类型的索引事件参数，即数组和结构，不直接存储，
而是存储一个编码的 Keccak-256 哈希值。这个编码的定义如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 值的编码只是字符串的内容，没有任何填充或长度前缀。</p></li>
<li><p>结构的编码是其成员编码的串联，总是填充为32字节的倍数（甚至是 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code>）。</p></li>
<li><p>数组的编码（包括动态和静态大小）是其元素编码的连接，
总是填充为32字节的倍数（甚至是 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code>），没有任何长度前缀。</p></li>
</ul>
<p>在上面，像往常一样，一个负数被填充符号扩展，而不是零填充。
<code class="docutils literal notranslate"><span class="pre">bytesNN</span></code> 类型被填充在右边，而 <code class="docutils literal notranslate"><span class="pre">uintNN</span></code> / <code class="docutils literal notranslate"><span class="pre">intNN</span></code> 被填充在左边。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果一个结构包含一个以上的动态大小的数组，那么它的编码是不明确的。
正因为如此，要经常重新检查事件数据，不要只依赖基于索引参数的搜索结果。</p>
</div>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-050-breaking-changes"></span><section id="solidity-v0-5-0">
<h2>Solidity v0.5.0 突破性变化<a class="headerlink" href="#solidity-v0-5-0" title="此标题的永久链接"></a></h2>
<p>本节强调了 Solidity 0.5.0 版本中引入的主要突破性变化，
以及这些变化背后的原因和如何更新受影响的代码。
对于完整的列表，请查看 <a class="reference external" href="https://github.com/ethereum/solidity/releases/tag/v0.5.0">版本更新日志</a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>用 Solidity v0.5.0 编译的合约仍然可以与合约甚至用旧版本编译的库对接，
而无需重新编译或重新部署。
将接口更改为包含数据位置，可见性和可变性说明符就足够了。
参见下面的 <a class="reference internal" href="#interoperability"><span class="std std-ref">与旧合约的互操作性</span></a> 部分。</p>
</div>
<section id="id2">
<h3>仅有语义上的变化<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>本节仅列出了语义的变化，因此有可能在现有代码中隐藏新的且不同的行为。</p>
<ul class="simple">
<li><p>有符号的右移现在使用正确的算术移位，即向负无穷大取整，而不是向零取整。
有符号和无符号移位在 君士坦丁堡（Constantinople）版本将有专门的操作码，
目前由Solidity模拟。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">do...while</span></code> 循环中的 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 语句现在跳转到条件，这是在这种情况下的常见行为。
以前是跳到循环主体。因此，如果条件是假的，循环就终止了。</p></li>
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>， <code class="docutils literal notranslate"><span class="pre">.delegatecall()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.staticcall()</span></code> 在给定一个 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 参数时，
不再进行填充。</p></li>
<li><p>如果EVM的版本是 拜占庭（Byzantium） 或更高版本，
现在调用 pure 和 view 函数时使用操作码 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">CALL</span></code>。
这不允许在EVM层面上改变状态。</p></li>
<li><p>当在外部函数调用和 <code class="docutils literal notranslate"><span class="pre">abi.encode</span></code> 中使用时，
ABI编码器现在可以正确地对来自 calldata（ <code class="docutils literal notranslate"><span class="pre">msg.data</span></code> 和外部函数参数）的字节数组和字符串进行填充。
对于未填充的编码，请使用 <code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code>。</p></li>
<li><p>如果传入的 calldata 太短或指向界外，ABI解码器会在函数的开头和 <code class="docutils literal notranslate"><span class="pre">abi.decode()</span></code> 中回退。
注意，脏的高阶位仍然会被忽略。</p></li>
<li><p>从蜜桔前哨（Tangerine Whistle）开始，用外部功能调用转发所有可用气体。</p></li>
</ul>
</section>
<section id="id3">
<h3>语义和语法的变化<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>本节重点介绍影响语法和语义的变化。</p>
<ul class="simple">
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>， <code class="docutils literal notranslate"><span class="pre">.delegatecall()</span></code>， <code class="docutils literal notranslate"><span class="pre">staticcall()</span></code>， <code class="docutils literal notranslate"><span class="pre">keccak256()</span></code>， <code class="docutils literal notranslate"><span class="pre">sha256()</span></code>
和 <code class="docutils literal notranslate"><span class="pre">ripemd160()</span></code> 现在只接受一个 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 参数。此外，该参数没有被填充。
这样做是为了使参数的连接方式更加明确和清晰。
将每个 <code class="docutils literal notranslate"><span class="pre">.call()</span></code> (和家族)改为 <code class="docutils literal notranslate"><span class="pre">.call(&quot;&quot;)</span></code>，
将每个 <code class="docutils literal notranslate"><span class="pre">.call(signature,</span> <span class="pre">a,b,</span> <span class="pre">c)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">.call(abi.encodeWithSignature(signature,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code>
（最后一项只对值类型有效）。
将每个 <code class="docutils literal notranslate"><span class="pre">keccak256(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encodePacked(a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code>。
尽管这不是一个突破性的改变，建议开发者将 <code class="docutils literal notranslate"><span class="pre">x.call(bytes4(keccak256(&quot;f(uint256)&quot;)),</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
改为 <code class="docutils literal notranslate"><span class="pre">x.call(abi.encodeWithSignature(&quot;f(uint256)&quot;,</span> <span class="pre">a,</span> <span class="pre">b))</span></code>。</p></li>
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>， <code class="docutils literal notranslate"><span class="pre">.delegatecall()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.staticcall()</span></code>
现在返回 <code class="docutils literal notranslate"><span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code> 以提供对返回数据的访问。
将 <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">success</span> <span class="pre">=</span> <span class="pre">otherContract.call(&quot;f&quot;)</span></code> 改为
<code class="docutils literal notranslate"><span class="pre">(bool</span> <span class="pre">success,</span> <span class="pre">bytes</span> <span class="pre">memory</span> <span class="pre">data)</span> <span class="pre">=</span> <span class="pre">otherContract.call(&quot;f&quot;)</span></code>。</p></li>
<li><p>Solidity 现在为函数局部变量实现了C99风格的范围规则，
也就是说，变量只能在它们被声明后使用，并且只能在相同或嵌套的范围内使用。
在 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环的初始化块中声明的变量在循环内部的任何一点都是有效的。</p></li>
</ul>
</section>
<section id="id4">
<h3>明确性要求<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>本节列出了现在的代码需要更加明确的变化。
对于大多数的主题，编译器会提供建议。</p>
<ul class="simple">
<li><p>明确的函数可见性现在是强制性的。 在每个函数和构造函数中添加 <code class="docutils literal notranslate"><span class="pre">public</span></code>，
在每个未指定可见性的回退或接口函数中添加 <code class="docutils literal notranslate"><span class="pre">external</span></code>。</p></li>
<li><p>所有结构，数组或映射类型的变量的明确数据位置现在是强制性的。
这也适用于函数参数和返回变量。 例如，将 <code class="docutils literal notranslate"><span class="pre">uint[]</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">z</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">uint[]</span> <span class="pre">storage</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">z</span></code>，
将 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(uint[]</span> <span class="pre">[]</span> <span class="pre">x)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(uint[]</span> <span class="pre">[]</span> <span class="pre">memory</span> <span class="pre">x)</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 是数据位置，可以相应地替换为 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 或 <code class="docutils literal notranslate"><span class="pre">calldata</span></code>。
注意， <code class="docutils literal notranslate"><span class="pre">external</span></code> 函数要求参数的数据位置为 <code class="docutils literal notranslate"><span class="pre">calldata</span></code>。</p></li>
<li><p>合约类型不再包括 <code class="docutils literal notranslate"><span class="pre">address</span></code> 成员，以便分离命名空间。
因此，现在有必要在使用 <code class="docutils literal notranslate"><span class="pre">address</span></code> 成员之前，明确地将合约类型的值转换为地址。
例如：如果 <code class="docutils literal notranslate"><span class="pre">c</span></code> 是一个合约，把 <code class="docutils literal notranslate"><span class="pre">c.transfer(...)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">address(c).transfer(...)</span></code>，
把  <code class="docutils literal notranslate"><span class="pre">c.balance</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">address(c).balance</span></code>。</p></li>
<li><p>现在不允许在不相关的合约类型之间进行显式的转换。您只能从一个合约类型转换到它的一个基础或祖先类型。
如果您确定一个合约与您想转换的合约类型是兼容的，尽管它没有继承它，
您可以通过先转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 来解决这个问题。
例如：如果 <code class="docutils literal notranslate"><span class="pre">A</span></code> 和 <code class="docutils literal notranslate"><span class="pre">B</span></code> 是合约类型， <code class="docutils literal notranslate"><span class="pre">B</span></code> 不继承 <code class="docutils literal notranslate"><span class="pre">A</span></code>，而 <code class="docutils literal notranslate"><span class="pre">b</span></code> 是 <code class="docutils literal notranslate"><span class="pre">B</span></code> 类型的合约，
您仍然可以用 <code class="docutils literal notranslate"><span class="pre">A(address(b))</span></code> 将 <code class="docutils literal notranslate"><span class="pre">b</span></code> 转换成 <code class="docutils literal notranslate"><span class="pre">A</span></code> 类型。
请注意，您仍然需要注意匹配的payable修饰的回退函数，如下文所述。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code> 类型被分成 <code class="docutils literal notranslate"><span class="pre">address</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，
其中只有 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 提供 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 功能。
一个 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 可以直接转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code>，
但不允许以其他方式转换。将 <code class="docutils literal notranslate"><span class="pre">address</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 是可以通过 <code class="docutils literal notranslate"><span class="pre">uint160</span></code> 转换的。
如果 <code class="docutils literal notranslate"><span class="pre">c</span></code> 是一个合约， 只有当 <code class="docutils literal notranslate"><span class="pre">c</span></code> 有一个 payable 修饰的回退函数时，
<code class="docutils literal notranslate"><span class="pre">address(c)</span></code> 的结果是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。
如果您使用 <a class="reference internal" href="index.html#withdrawal-pattern"><span class="std std-ref">取回模式</span></a>，您很可能不必改变您的代码，
因为 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 只用于 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 而不是存储地址，
而且 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型。</p></li>
<li><p>现在不允许不同位数的 <code class="docutils literal notranslate"><span class="pre">bytesX</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uintY</span></code> 之间的转换了，
因为 <code class="docutils literal notranslate"><span class="pre">bytesX</span></code> 会在右侧填充， <code class="docutils literal notranslate"><span class="pre">uintY</span></code> 会在左侧填充，这可能导致意外的转换结果。
现在在转换前必须在类型内调整位数。 例如，
您想要将 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> （4字节）转换为 <code class="docutils literal notranslate"><span class="pre">uint64</span></code> （8字节），
首先将 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 变量转换为 <code class="docutils literal notranslate"><span class="pre">bytes8</span></code>，然后再转换为 <code class="docutils literal notranslate"><span class="pre">uint64</span></code>。
当通过 <code class="docutils literal notranslate"><span class="pre">uint32</span></code> 转换时，您会得到相反的填充结果。
在v0.5.0之前，任何 <code class="docutils literal notranslate"><span class="pre">bytesX</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uintY</span></code> 之间的转换都要通过 <code class="docutils literal notranslate"><span class="pre">uint8X</span></code>。
例如， <code class="docutils literal notranslate"><span class="pre">uint8(bytes3(0x291807))</span></code> 将被转换为 <code class="docutils literal notranslate"><span class="pre">uint8(uint24(bytes3(0x291807)))</span></code>
（结果是 <code class="docutils literal notranslate"><span class="pre">0x07</span></code>）。</p></li>
<li><p>在非payable函数中使用 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> （或通过修改器引入）是不允许的，因为这是一个安全特性。
将该函数变成 <code class="docutils literal notranslate"><span class="pre">payable</span></code>，或为程序逻辑创建一个新的内部函数，使用 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code>。</p></li>
<li><p>为了清晰起见，如果使用标准输入作为源，命令行界面现在需要 <code class="docutils literal notranslate"><span class="pre">-</span></code>。</p></li>
</ul>
</section>
<section id="id5">
<h3>废弃的元素<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>这一节列出了废弃以前的功能或语法的变化。 请注意，其中许多变化已经在实验模式 <code class="docutils literal notranslate"><span class="pre">v0.5.0</span></code> 中启用。</p>
<section id="json">
<h4>命令行和JSON接口<a class="headerlink" href="#json" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>命令行选项 <code class="docutils literal notranslate"><span class="pre">--formal</span></code> （用于生成Why3输出以进一步形式化验证）已被废弃，现在已被删除。
一个新的形式化验证模块，SMTChecker，可以通过 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">SMTChecker;</span></code> 启用。</p></li>
<li><p>由于中间语言 <code class="docutils literal notranslate"><span class="pre">Julia</span></code> 更名为 <code class="docutils literal notranslate"><span class="pre">Yul</span></code>，命令行选项 <code class="docutils literal notranslate"><span class="pre">--julia</span></code> 被更名为 <code class="docutils literal notranslate"><span class="pre">--yul</span></code>。</p></li>
<li><p>删除了 <code class="docutils literal notranslate"><span class="pre">--clone-bin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--combined-json</span> <span class="pre">clone-bin</span></code> 命令行选项。</p></li>
<li><p>不允许使用空前缀的重映射。</p></li>
<li><p>JSON AST字段 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 和 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 被删除。
这些信息现在出现在 <code class="docutils literal notranslate"><span class="pre">stateMutability</span></code> 字段中。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FunctionDefinition</span></code> 节点的JSON AST字段 <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code> 被一个名为 <code class="docutils literal notranslate"><span class="pre">kind</span></code> 的字段取代，
该字段的值可以是  <code class="docutils literal notranslate"><span class="pre">&quot;constructor&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">&quot;fallback&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;function&quot;</span></code>。</p></li>
<li><p>在非链接的二进制十六进制文件中，库地址占位符现在是完全等同的库名的keccak256哈希值的前36个十六进制字符，
用 <code class="docutils literal notranslate"><span class="pre">$...$</span></code> 包围。以前，只使用完全等同的库名。这减少了碰撞的机会，特别是在使用长路径的时候。
二进制文件现在也包含一个从这些占位符到完全等同名称的映射列表。</p></li>
</ul>
</section>
<section id="id6">
<h4>构造函数<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>现在必须使用 <code class="docutils literal notranslate"><span class="pre">constructor</span></code> 关键字来定义构造函数。</p></li>
<li><p>现在不允许在没有括号的情况下调用基本构造函数。</p></li>
<li><p>现在不允许在同一继承层次中多次指定基本构造函数参数。</p></li>
<li><p>现在不允许调用有参数但参数个数错误的构造函数。
如果您只是想指定一个继承关系而不是给参数，完全不要提供括号。</p></li>
</ul>
</section>
<section id="id7">
<h4>函数<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">callcode</span></code> 现在被禁止使用（改用 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>）。
但仍然可以通过内联汇编使用它。</p></li>
<li><p>现在不允许使用 <code class="docutils literal notranslate"><span class="pre">suicide</span></code> （改用 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code>）。</p></li>
<li><p>现在不允许使用 <code class="docutils literal notranslate"><span class="pre">sha3</span></code> （改用 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code>）。</p></li>
<li><p>现在不允许使用 <code class="docutils literal notranslate"><span class="pre">throw</span></code> （改用 <code class="docutils literal notranslate"><span class="pre">revert</span></code>， <code class="docutils literal notranslate"><span class="pre">require</span></code> 和 <code class="docutils literal notranslate"><span class="pre">assert</span></code>）。</p></li>
</ul>
</section>
<section id="id8">
<h4>转换<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>现在不允许从数字到 <code class="docutils literal notranslate"><span class="pre">bytesXX</span></code> 类型的显性和隐性转换。</p></li>
<li><p>现在不允许从十六进制字数到不同大小的 <code class="docutils literal notranslate"><span class="pre">bytesXX</span></code> 类型的显性和隐性转换。</p></li>
</ul>
</section>
<section id="id9">
<h4>字面常量和后缀<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>由于闰年的复杂性和混乱性，现在不允许使用单位名称 <code class="docutils literal notranslate"><span class="pre">years</span></code>。</p></li>
<li><p>现在不允许出现后面没有数字的尾部圆点。</p></li>
<li><p>现在不允许将十六进制数字与单位值相结合（例如： <code class="docutils literal notranslate"><span class="pre">0x1e</span> <span class="pre">wei</span></code>）。</p></li>
<li><p>十六进制数字的前缀 <code class="docutils literal notranslate"><span class="pre">0X</span></code> 是不允许的，只能是 <code class="docutils literal notranslate"><span class="pre">0x</span></code>。</p></li>
</ul>
</section>
<section id="id10">
<h4>变量<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>为了清晰起见，现在不允许声明空结构。</p></li>
<li><p>现在不允许使用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 关键字，以利于明确性。</p></li>
<li><p>现在不允许在具有不同组件数量的元组之间进行分配。</p></li>
<li><p>不允许使用不属于编译时常量的常量值。</p></li>
<li><p>现在不允许出现数值不匹配的多变量声明。</p></li>
<li><p>现在不允许出现未初始化的存储变量。</p></li>
<li><p>现在不允许使用空元组。</p></li>
<li><p>检测变量和结构中的循环依赖关系，在递归中被限制为256个。</p></li>
<li><p>现在不允许长度为零的固定长度数组。</p></li>
</ul>
</section>
<section id="id11">
<h4>语法<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>现在不允许使用 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 作为函数状态的可变性修饰符。</p></li>
<li><p>布尔表达式不能使用算术运算。</p></li>
<li><p>现在不允许使用单数的 <code class="docutils literal notranslate"><span class="pre">+</span></code> 操作符。</p></li>
<li><p>如果没有事先转换为明确的类型，字面量不能再使用 <code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code>。</p></li>
<li><p>现在不允许有一个或多个返回值的函数的空返回语句。</p></li>
<li><p>现在完全不允许使用 &quot;松散汇编&quot; 语法，也就是说，
不能再使用跳转标签，跳转和非功能指令。使用新的 <code class="docutils literal notranslate"><span class="pre">while</span></code>， <code class="docutils literal notranslate"><span class="pre">switch</span></code> 和 <code class="docutils literal notranslate"><span class="pre">if</span></code> 结构代替。</p></li>
<li><p>没有实现的函数不能再使用修改器。</p></li>
<li><p>现在不允许具有命名返回值的函数类型。</p></li>
<li><p>现在不允许在不是程序块的 if/while/for 语句体中进行单语句变量声明。</p></li>
<li><p>新的关键字： <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 和 <code class="docutils literal notranslate"><span class="pre">constructor</span></code>。</p></li>
<li><p>新的保留关键字： <code class="docutils literal notranslate"><span class="pre">alias</span></code>， <code class="docutils literal notranslate"><span class="pre">apply</span></code>， <code class="docutils literal notranslate"><span class="pre">auto</span></code>， <code class="docutils literal notranslate"><span class="pre">copyof</span></code>，
<code class="docutils literal notranslate"><span class="pre">define</span></code>， <code class="docutils literal notranslate"><span class="pre">immutable</span></code>， <code class="docutils literal notranslate"><span class="pre">implements</span></code>， <code class="docutils literal notranslate"><span class="pre">macro</span></code>， <code class="docutils literal notranslate"><span class="pre">mutable</span></code>，
<code class="docutils literal notranslate"><span class="pre">override</span></code>， <code class="docutils literal notranslate"><span class="pre">partial</span></code>， <code class="docutils literal notranslate"><span class="pre">promise</span></code>， <code class="docutils literal notranslate"><span class="pre">reference</span></code>， <code class="docutils literal notranslate"><span class="pre">sealed</span></code>，
<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>， <code class="docutils literal notranslate"><span class="pre">supports</span></code>， <code class="docutils literal notranslate"><span class="pre">typedef</span></code> 和 <code class="docutils literal notranslate"><span class="pre">unchecked</span></code>。</p></li>
</ul>
</section>
</section>
<section id="interoperability">
<span id="id12"></span><h3>与旧合约的互操作性<a class="headerlink" href="#interoperability" title="此标题的永久链接"></a></h3>
<p>通过为它们定义接口，仍然可以与为0.5.0之前的Solidity版本编写的合于对接（或者反过来）。
考虑到您已经部署了以下0.5.0之前的合约：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIOWcqDAuNC4yNeeJiOacrOeahOe8luivkeWZqOS5i+WJje+8jOi/meWwhuaKpeWRiuS4gOS4quitpuWRigovLyDov5nlnKgwLjUuMOS5i+WQjuWwhuaXoOazlee8luivkeOAggpjb250cmFjdCBPbGRDb250cmFjdCB7CiAgICBmdW5jdGlvbiBzb21lT2xkRnVuY3Rpb24odWludDggYSkgewogICAgICAgIC8vLi4uCiAgICB9CiAgICBmdW5jdGlvbiBhbm90aGVyT2xkRnVuY3Rpb24oKSBjb25zdGFudCByZXR1cm5zIChib29sKSB7CiAgICAgICAgLy8uLi4KICAgIH0KICAgIC8vIC4uLgp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.4.25</span><span class="p">;</span>
<span class="c1">// 在0.4.25版本的编译器之前，这将报告一个警告</span>
<span class="c1">// 这在0.5.0之后将无法编译。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">OldContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">someOldFunction</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">anotherOldFunction</span><span class="p">()</span><span class="w"> </span><span class="kt">constant</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这将不再在Solidity 0.5.0版本中进行编译。然而，您可以为它定义一个兼容的接口：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwppbnRlcmZhY2UgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIGV4dGVybmFsOwogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCk7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
interface<span class="w"> </span>OldContract<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">someOldFunction</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">anotherOldFunction</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，我们没有声明 <code class="docutils literal notranslate"><span class="pre">anotherOldFunction</span></code> 是 <code class="docutils literal notranslate"><span class="pre">view</span></code>，尽管它在原始合约中被声明为 <code class="docutils literal notranslate"><span class="pre">constant</span></code>。
这是由于从Solidity 0.5.0版本开始，<code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 被用来调用 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数。
在 0.5.0 版本之前， <code class="docutils literal notranslate"><span class="pre">constant</span></code> 关键字没有被强制执行，
所以用 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 调用一个被声明为 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 的函数仍然可能被还原，
因为 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 函数仍然可能试图修改存储。因此，当为旧合约定义接口时，
您应该只使用 <code class="docutils literal notranslate"><span class="pre">view</span></code> 来代替 <code class="docutils literal notranslate"><span class="pre">constant</span></code>，以防您绝对确定该函数能与 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 一起工作。</p>
<p>有了上面定义的接口，您现在可以很容易地使用已经部署的 0.5.0 之前的合约：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKaW50ZXJmYWNlIE9sZENvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIHNvbWVPbGRGdW5jdGlvbih1aW50OCBhKSBleHRlcm5hbDsKICAgIGZ1bmN0aW9uIGFub3RoZXJPbGRGdW5jdGlvbigpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBkb1NvbWV0aGluZyhPbGRDb250cmFjdCBhKSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIGEuc29tZU9sZEZ1bmN0aW9uKDB4NDIpOwogICAgICAgIHJldHVybiBhLmFub3RoZXJPbGRGdW5jdGlvbigpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

interface<span class="w"> </span>OldContract<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">someOldFunction</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">anotherOldFunction</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">NewContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">doSomething</span><span class="p">(</span>OldContract<span class="w"> </span>a<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>a<span class="p">.</span>someOldFunction<span class="p">(</span><span class="mh">0x42</span><span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="p">.</span>anotherOldFunction<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同样，0.5.0以前的库可以通过定义库的功能而不需要实现，
并在连接时提供0.5.0以前的库的地址来使用
（关于如何使用命令行编译器进行连接，请参见 <a class="reference internal" href="index.html#commandline-compiler"><span class="std std-ref">使用命令行编译器</span></a>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8g6L+Z5ZyoMC42LjDniYjmnKzkuYvlkI7lsIbml6Dms5XnvJbor5HjgIIKLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKCmxpYnJhcnkgT2xkTGlicmFyeSB7CiAgICBmdW5jdGlvbiBzb21lRnVuY3Rpb24odWludDggYSkgcHVibGljIHJldHVybnMoYm9vbCk7Cn0KCmNvbnRyYWN0IE5ld0NvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIGYodWludDggYSkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICByZXR1cm4gT2xkTGlicmFyeS5zb21lRnVuY3Rpb24oYSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这在0.6.0版本之后将无法编译。</span>
<span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.5.0</span><span class="p">;</span>

<span class="kt">library</span><span class="w"> </span>OldLibrary<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">someFunction</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">NewContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>OldLibrary<span class="p">.</span>someFunction<span class="p">(</span>a<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id13">
<h3>示例<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h3>
<p>下面的例子显示了Solidity 0.5.0 版本的合约及其更新版本，其中包括本节中列出的一些变化。</p>
<p>Old version:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIOi/meWcqDAuNS4w54mI5pys5LmL5ZCO5bCG5peg5rOV57yW6K+R44CCCgpjb250cmFjdCBPdGhlckNvbnRyYWN0IHsKICAgIHVpbnQgeDsKICAgIGZ1bmN0aW9uIGYodWludCB5KSBleHRlcm5hbCB7CiAgICAgICAgeCA9IHk7CiAgICB9CiAgICBmdW5jdGlvbigpIHBheWFibGUgZXh0ZXJuYWwge30KfQoKY29udHJhY3QgT2xkIHsKICAgIE90aGVyQ29udHJhY3Qgb3RoZXI7CiAgICB1aW50IG15TnVtYmVyOwoKICAgIC8vIOayoeacieaPkOS+m+WHveaVsOeahOWPr+WPmOaAp++8jOS4jeaYr+mUmeivr+OAggogICAgZnVuY3Rpb24gc29tZUludGVnZXIoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50KSB7IHJldHVybiAyOyB9CgogICAgLy8g5rKh5pyJ5o+Q5L6b5Ye95pWw55qE5Y+v6KeB5oCn77yM5LiN5piv6ZSZ6K+v44CCCiAgICAvLyDmsqHmnInmj5Dkvpvlh73mlbDnmoTlj6/lj5jmgKfvvIzkuI3mmK/plJnor6/jgIIKICAgIGZ1bmN0aW9uIGYodWludCB4KSByZXR1cm5zIChieXRlcykgewogICAgICAgIC8vIOWcqOi/meS4queJiOacrOS4re+8jHZhcuaYr+WPr+S7peS9v+eUqOeahOOAggogICAgICAgIHZhciB6ID0gc29tZUludGVnZXIoKTsKICAgICAgICB4ICs9IHo7CiAgICAgICAgLy8g5Zyo6L+Z5Liq54mI5pys5Lit77yMdGhyb3fmmK/lj6/ku6Xkvb/nlKjnmoTjgIIKICAgICAgICBpZiAoeCA+IDEwMCkKICAgICAgICAgICAgdGhyb3c7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoeCk7CiAgICAgICAgeSA9IC0zID4+IDE7CiAgICAgICAgLy8geSA9PSAtMe+8iOmUme+8jOW6lOivpeaYry0y77yJ44CCCiAgICAgICAgZG8gewogICAgICAgICAgICB4ICs9IDE7CiAgICAgICAgICAgIGlmICh4ID4gMTApIGNvbnRpbnVlOwogICAgICAgICAgICAvLyAnQ29udGludWUnIOS8muWvvOiHtOaXoOmZkOW+queOr+OAggogICAgICAgIH0gd2hpbGUgKHggPCAxMSk7CiAgICAgICAgLy8g6LCD55So5Y+q6L+U5Zue5LiA5Liq5biD5bCU5YC844CCCiAgICAgICAgYm9vbCBzdWNjZXNzID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIOWxgOmDqOWPmOmHj+WPr+S7peWcqOWFtuS9v+eUqOWQjuWjsOaYjuOAggogICAgICAgICAgICBpbnQgeTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGI7CiAgICB9CgogICAgLy/kuI3pnIDopoHkuLonYXJyJ+iuvue9ruaYjuehrueahOaVsOaNruS9jee9rgogICAgZnVuY3Rpb24gZyh1aW50W10gYXJyLCBieXRlczggeCwgT3RoZXJDb250cmFjdCBvdGhlckNvbnRyYWN0KSBwdWJsaWMgewogICAgICAgIG90aGVyQ29udHJhY3QudHJhbnNmZXIoMSBldGhlcik7CgogICAgICAgIC8vIOeUseS6jnVpbnQzMu+8iDTkuKrlrZfoioLvvInlsI/kuo5ieXRlOO+8iDjkuKrlrZfoioLvvInvvIwKICAgICAgICAvLyB455qE5YmNNOS4quWtl+iKguWwhuiiq+S4ouWkseOAggogICAgICAgIC8vIOi/meWPr+iDveS8muWvvOiHtOaEj+aDs+S4jeWIsOeahOihjOS4uu+8jOWboOS4umJ5dGVzWOaYr+WQkeWPs+Whq+WFheeahOOAggogICAgICAgIHVpbnQzMiB5ID0gdWludDMyKHgpOwogICAgICAgIG15TnVtYmVyICs9IHkgKyBtc2cudmFsdWU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.4.25</span><span class="p">;</span>
<span class="c1">// 这在0.5.0版本之后将无法编译。</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">OtherContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>y<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="p">()</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Old</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>OtherContract<span class="w"> </span>other<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">myNumber</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 没有提供函数的可变性，不是错误。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">someInteger</span><span class="p">()</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 没有提供函数的可见性，不是错误。</span>
<span class="w">    </span><span class="c1">// 没有提供函数的可变性，不是错误。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 在这个版本中，var是可以使用的。</span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span>z<span class="w"> </span><span class="o">=</span><span class="w"> </span>someInteger<span class="p">();</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span>z<span class="p">;</span>
<span class="w">        </span><span class="c1">// 在这个版本中，throw是可以使用的。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">100</span><span class="p">)</span>
<span class="w">            </span><span class="kt">throw</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>x<span class="p">);</span>
<span class="w">        </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="m m-Decimal">3</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// y == -1（错，应该是-2）。</span>
<span class="w">        </span><span class="kt">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span><span class="w"> </span><span class="kt">continue</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// &#39;Continue&#39; 会导致无限循环。</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">11</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 调用只返回一个布尔值。</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>other<span class="p">).</span>call<span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>success<span class="p">)</span>
<span class="w">            </span>revert<span class="p">();</span>
<span class="w">        </span><span class="kt">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 局部变量可以在其使用后声明。</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//不需要为&#39;arr&#39;设置明确的数据位置</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>arr<span class="p">,</span><span class="w"> </span><span class="kt">bytes8</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span>OtherContract<span class="w"> </span>otherContract<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>otherContract<span class="p">.</span>transfer<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">);</span>

<span class="w">        </span><span class="c1">// 由于uint32（4个字节）小于byte8（8个字节），</span>
<span class="w">        </span><span class="c1">// x的前4个字节将被丢失。</span>
<span class="w">        </span><span class="c1">// 这可能会导致意想不到的行为，因为bytesX是向右填充的。</span>
<span class="w">        </span><span class="kt">uint32</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32</span><span class="p">(</span>x<span class="p">);</span>
<span class="w">        </span>myNumber<span class="w"> </span><span class="o">+=</span><span class="w"> </span>y<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>新版本：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKLy8g6L+Z5ZyoMC42LjDniYjmnKzkuYvlkI7lsIbml6Dms5XnvJbor5HjgIIKCmNvbnRyYWN0IE90aGVyQ29udHJhY3QgewogICAgdWludCB4OwogICAgZnVuY3Rpb24gZih1aW50IHkpIGV4dGVybmFsIHsKICAgICAgICB4ID0geTsKICAgIH0KICAgIGZ1bmN0aW9uKCkgcGF5YWJsZSBleHRlcm5hbCB7fQp9Cgpjb250cmFjdCBOZXcgewogICAgT3RoZXJDb250cmFjdCBvdGhlcjsKICAgIHVpbnQgbXlOdW1iZXI7CgogICAgLy8g5b+F6aG75oyH5a6a5Ye95pWw55qE5Y+v5Y+Y5oCn44CCCiAgICBmdW5jdGlvbiBzb21lSW50ZWdlcigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgeyByZXR1cm4gMjsgfQoKICAgIC8vIOW/hemhu+aMh+WumuWHveaVsOeahOWPr+ingeaAp+OAggogICAgLy8g5b+F6aG75oyH5a6a5Ye95pWw55qE5Y+v5Y+Y5oCn44CCCiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcHVibGljIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkgewogICAgICAgIC8vIOeOsOWcqOW/hemhu+aYjuehruWcsOe7meWHuuexu+Wei+OAggogICAgICAgIHVpbnQgeiA9IHNvbWVJbnRlZ2VyKCk7CiAgICAgICAgeCArPSB6OwogICAgICAgIC8vIOeOsOWcqOS4jeWFgeiuuOS9v+eUqHRocm9344CCCiAgICAgICAgcmVxdWlyZSh4IDw9IDEwMCk7CiAgICAgICAgaW50IHkgPSAtMyA+PiAxOwogICAgICAgIHJlcXVpcmUoeSA9PSAtMik7CiAgICAgICAgZG8gewogICAgICAgICAgICB4ICs9IDE7CiAgICAgICAgICAgIGlmICh4ID4gMTApIGNvbnRpbnVlOwogICAgICAgICAgICAvLyAnQ29udGludWUn6Lez6L2s5Yiw5LiL6Z2i55qE5p2h5Lu244CCCiAgICAgICAgfSB3aGlsZSAoeCA8IDExKTsKCiAgICAgICAgLy8gY2FsbOi/lOWbnuWAvOS4uihib29sLCBieXRlcykuCiAgICAgICAgLy8g5b+F6aG75oyH5a6a5pWw5o2u5L2N572u44CCCiAgICAgICAgKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IGRhdGEpID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CgogICAgdXNpbmcgQWRkcmVzc01ha2VQYXlhYmxlIGZvciBhZGRyZXNzOwogICAgLy8g5b+F6aG75oyH5a6aJ2FycifnmoTmlbDmja7kvY3nva4KICAgIGZ1bmN0aW9uIGcodWludFtdIG1lbW9yeSAvKiBhcnIgKi8sIGJ5dGVzOCB4LCBPdGhlckNvbnRyYWN0IG90aGVyQ29udHJhY3QsIGFkZHJlc3MgdW5rbm93bkNvbnRyYWN0KSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8g5rKh5pyJ5o+Q5L6bJ290aGVyQ29udHJhY3QudHJhbnNmZXIn44CCCiAgICAgICAgLy8g55Sx5LqOJ090aGVyQ29udHJhY3Qn55qE5Luj56CB5piv5bey55+l55qE77yM5bm25LiU5YW35pyJ5Zue6YCA5Yqf6IO977yMCiAgICAgICAgLy8gYWRkcmVzcyhvdGhlckNvbnRyYWN0KeWFt+aciSdhZGRyZXNzIHBheWFibGUn57G75Z6L44CCCiAgICAgICAgYWRkcmVzcyhvdGhlckNvbnRyYWN0KS50cmFuc2ZlcigxIGV0aGVyKTsKCiAgICAgICAgLy8g5rKh5pyJ5o+Q5L6bJ3Vua25vd25Db250cmFjdC50cmFuc2ZlcifjgIIKICAgICAgICAvLyDmsqHmnInmj5DkvpsnYWRkcmVzcyh1bmtub3duQ29udHJhY3QpLnRyYW5zZmVyJwogICAgICAgIC8vIOWboOS4uidhZGRyZXNzKHVua25vd25Db250cmFjdCkn5LiN5pivJ2FkZHJlc3MgcGF5YWJsZSfnsbvlnovjgIIKICAgICAgICAvLyDlpoLmnpzor6Xlh73mlbDpnIDopoHkuIDkuKrmgqjmg7Plj5HpgIHotYTph5HnmoQnYWRkcmVzcyfnsbvlnovvvIwKICAgICAgICAvLyDmgqjlj6/ku6XpgJrov4cndWludDE2MCflsIblhbbovazmjaLkuLonYWRkcmVzcyBwYXlhYmxlJ+exu+Wei+OAggogICAgICAgIC8vIOazqOaEj++8muS4jeW7uuiurui/meagt+WBmu+8jOW6lOWwveWPr+iDveS9v+eUqOaYjuehrueahCdhZGRyZXNzIHBheWFibGUn57G75Z6L44CCCiAgICAgICAgLy8g5Li65LqG5o+Q6auY5piO56Gu5oCn77yM5oiR5Lus5bu66K6u5L2/55So5LiA5Liq5bqT5p2l6L+b6KGM6L2s5o2i77yI5Zyo6L+Z5Liq5L6L5a2Q5Lit55qE5ZCI5ZCM5ZCO6Z2i5o+Q5L6b77yJ44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGFkZHIgPSB1bmtub3duQ29udHJhY3QubWFrZVBheWFibGUoKTsKICAgICAgICByZXF1aXJlKGFkZHIuc2VuZCgxIGV0aGVyKSk7CgogICAgICAgIC8vIOeUseS6jnVpbnQzMu+8iDTlrZfoioLvvInlsI/kuo5ieXRlczjvvIg45a2X6IqC77yJ77yMCiAgICAgICAgLy8g5omA5Lul5LiN5YWB6K646L+b6KGM6L2s5o2i44CCCiAgICAgICAgLy8g5oiR5Lus6ZyA6KaB5YWI6L2s5o2i5Yiw5LiA5Liq6YCa55So55qE5aSn5bCP77yaCiAgICAgICAgYnl0ZXM0IHg0ID0gYnl0ZXM0KHgpOyAvLyBQYWRkaW5nIGhhcHBlbnMgb24gdGhlIHJpZ2h0CiAgICAgICAgdWludDMyIHkgPSB1aW50MzIoeDQpOyAvLyBDb252ZXJzaW9uIGlzIGNvbnNpc3RlbnQKICAgICAgICAvLyAnbXNnLnZhbHVlJ+S4jeiDveeUqOWcqCfpnZ5wYXlhYmxlJ+exu+Wei+eahOWHveaVsOS4reOAggogICAgICAgIC8vIOaIkeS7rOmcgOimgeaKiuWHveaVsOWPmOaIkHBheWFibGXnsbvlnosKICAgICAgICBteU51bWJlciArPSB5ICsgbXNnLnZhbHVlOwogICAgfQp9CgovLyDmiJHku6zlj6/ku6XlrprkuYnkuIDkuKrlupPvvIzlsIYgYGBhZGRyZXNzYGAg57G75Z6L5piO56Gu6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5L2c5Li65LiA56eN5Y+Y6YCa5pa55rOV44CCCmxpYnJhcnkgQWRkcmVzc01ha2VQYXlhYmxlIHsKICAgIGZ1bmN0aW9uIG1ha2VQYXlhYmxlKGFkZHJlc3MgeCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChhZGRyZXNzIHBheWFibGUpIHsKICAgICAgICByZXR1cm4gYWRkcmVzcyh1aW50MTYwKHgpKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.5.0</span><span class="p">;</span>
<span class="c1">// 这在0.6.0版本之后将无法编译。</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">OtherContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>y<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="p">()</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">New</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>OtherContract<span class="w"> </span>other<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">myNumber</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 必须指定函数的可变性。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">someInteger</span><span class="p">()</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 必须指定函数的可见性。</span>
<span class="w">    </span><span class="c1">// 必须指定函数的可变性。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 现在必须明确地给出类型。</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>someInteger<span class="p">();</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span>z<span class="p">;</span>
<span class="w">        </span><span class="c1">// 现在不允许使用throw。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="m m-Decimal">100</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="m m-Decimal">3</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>y<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">        </span><span class="kt">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span><span class="w"> </span><span class="kt">continue</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// &#39;Continue&#39;跳转到下面的条件。</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">11</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// call返回值为(bool, bytes).</span>
<span class="w">        </span><span class="c1">// 必须指定数据位置。</span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>data<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>other<span class="p">).</span>call<span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>success<span class="p">)</span>
<span class="w">            </span>revert<span class="p">();</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>data<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span>using<span class="w"> </span>AddressMakePayable<span class="w"> </span><span class="kt">for</span><span class="w"> </span><span class="kt">address</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 必须指定&#39;arr&#39;的数据位置</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span><span class="cm">/* arr */</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes8</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span>OtherContract<span class="w"> </span>otherContract<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">unknownContract</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 没有提供&#39;otherContract.transfer&#39;。</span>
<span class="w">        </span><span class="c1">// 由于&#39;OtherContract&#39;的代码是已知的，并且具有回退功能，</span>
<span class="w">        </span><span class="c1">// address(otherContract)具有&#39;address payable&#39;类型。</span>
<span class="w">        </span><span class="kt">address</span><span class="p">(</span>otherContract<span class="p">).</span>transfer<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">);</span>

<span class="w">        </span><span class="c1">// 没有提供&#39;unknownContract.transfer&#39;。</span>
<span class="w">        </span><span class="c1">// 没有提供&#39;address(unknownContract).transfer&#39;</span>
<span class="w">        </span><span class="c1">// 因为&#39;address(unknownContract)&#39;不是&#39;address payable&#39;类型。</span>
<span class="w">        </span><span class="c1">// 如果该函数需要一个您想发送资金的&#39;address&#39;类型，</span>
<span class="w">        </span><span class="c1">// 您可以通过&#39;uint160&#39;将其转换为&#39;address payable&#39;类型。</span>
<span class="w">        </span><span class="c1">// 注意：不建议这样做，应尽可能使用明确的&#39;address payable&#39;类型。</span>
<span class="w">        </span><span class="c1">// 为了提高明确性，我们建议使用一个库来进行转换（在这个例子中的合同后面提供）。</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>addr<span class="w"> </span><span class="o">=</span><span class="w"> </span>unknownContract<span class="p">.</span>makePayable<span class="p">();</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>addr<span class="p">.</span>send<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">));</span>

<span class="w">        </span><span class="c1">// 由于uint32（4字节）小于bytes8（8字节），</span>
<span class="w">        </span><span class="c1">// 所以不允许进行转换。</span>
<span class="w">        </span><span class="c1">// 我们需要先转换到一个通用的大小：</span>
<span class="w">        </span>bytes4<span class="w"> </span>x4<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes4<span class="p">(</span>x<span class="p">);</span><span class="w"> </span><span class="c1">// Padding happens on the right</span>
<span class="w">        </span><span class="kt">uint32</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32</span><span class="p">(</span>x4<span class="p">);</span><span class="w"> </span><span class="c1">// Conversion is consistent</span>
<span class="w">        </span><span class="c1">// &#39;msg.value&#39;不能用在&#39;非payable&#39;类型的函数中。</span>
<span class="w">        </span><span class="c1">// 我们需要把函数变成payable类型</span>
<span class="w">        </span>myNumber<span class="w"> </span><span class="o">+=</span><span class="w"> </span>y<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 我们可以定义一个库，将 ``address`` 类型明确转换为 ``address payable`` 类型，作为一种变通方法。</span>
<span class="kt">library</span><span class="w"> </span>AddressMakePayable<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">makePayable</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">uint160</span><span class="p">(</span>x<span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<span id="document-060-breaking-changes"></span><section id="solidity-0-6-0">
<h2>Solidity 0.6.0 版本突破性变化<a class="headerlink" href="#solidity-0-6-0" title="此标题的永久链接"></a></h2>
<p>本节强调了 Solidity 0.6.0 版本中引入的主要突破性变化，以及这些变化背后的原因和如何更新受影响的代码。
对于完整的列表，请查看 <a class="reference external" href="https://github.com/ethereum/solidity/releases/tag/v0.6.0">版本更新日志</a>。</p>
<section id="id2">
<h3>编译器可能不会发出警告的变化<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>本节列出了一些变化，在这些变化中，您的代码的行为可能会发生变化，而编译器不会告诉您。</p>
<ul class="simple">
<li><p>指数运算的结果类型是基数的类型。
就像对称运算一样，它曾经是可以同时容纳基数类型和指数类型的最小类型。
此外，指数化的基数允许是有符号的类型。</p></li>
</ul>
</section>
<section id="id3">
<h3>显性要求<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>这一节列出了代码现在需要更显式的更改，但是语义没有改变。
对于大多数主题，编译器会提供建议。</p>
<ul class="simple">
<li><p>现在，只有当函数被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 关键字或被定义在一个接口中时，才能被重载。
在接口之外没有实现的函数必须被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。
当重载一个函数或修改器时，必须使用新的关键字 <code class="docutils literal notranslate"><span class="pre">override</span></code>。
当重载一个定义在多个并行基类的函数或修改器时，所有基必须在关键字后面的括号中列出，
像这样： <code class="docutils literal notranslate"><span class="pre">override(Base1,</span> <span class="pre">Base2)</span></code>。</p></li>
<li><p>成员对数组的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 的访问现在总是只读的，即使是存储数组。
不再可能通过给存储数组的长度分配一个新值来调整其大小。
使用 <code class="docutils literal notranslate"><span class="pre">push()</span></code>， <code class="docutils literal notranslate"><span class="pre">push(value)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 代替，
或者分配一个完整的数组，当然这将覆盖现有内容。
这背后的原因是为了防止巨大的存储阵列的存储碰撞。</p></li>
<li><p>新的关键字 <code class="docutils literal notranslate"><span class="pre">abstract</span></code> 可以用来标记合约为抽象的。
如果一个合约没有实现它的所有功能，就必须使用这个关键字。抽象合约不能用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 操作符创建，
在编译过程中也不可能为其生成字节码。</p></li>
<li><p>库合约必须实现其所有功能，而不仅仅是内部功能。</p></li>
<li><p>在内联汇编中声明的变量名称不能再以 <code class="docutils literal notranslate"><span class="pre">_slot</span></code> 或 <code class="docutils literal notranslate"><span class="pre">_offset</span></code> 结尾。</p></li>
<li><p>内联汇编中的变量声明不能再影射内联汇编块外的任何声明。
如果变量名称中包含一个点，那么它的前缀到点的部分不能与内联汇编块外的任何声明冲突。</p></li>
<li><p>现在不允许状态变量阴影。 一个派生合约只能声明一个状态变量 <code class="docutils literal notranslate"><span class="pre">x</span></code>，
如果在它的任何基础上没有相同名称的可见状态变量。</p></li>
</ul>
</section>
<section id="id4">
<h3>语义和语法变化<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>这一部分列出了您必须修改您的代码，而之后它又做了一些别的事情的变化。</p>
<ul class="simple">
<li><p>现在不允许从外部函数类型转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。
相反，外部函数类型有一个叫做 <code class="docutils literal notranslate"><span class="pre">address</span></code> 的成员，类似于现有的 <code class="docutils literal notranslate"><span class="pre">selector</span></code> 成员。</p></li>
<li><p>动态存储数组的函数 <code class="docutils literal notranslate"><span class="pre">push(value)</span></code> 不再返回新的长度（它什么也不返回）。</p></li>
<li><p>通常被称为 &quot;回退函数&quot; 的无名函数被拆分为一个新的回退函数，该函数使用 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 关键字定义，
并使用 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 关键字定义一个接收以太的函数。</p>
<ul>
<li><p>如果存在，每当调用数据为空时（无论是否收到以太），
都会调用接收以太函数 receive。此函数是隐式的 <code class="docutils literal notranslate"><span class="pre">payable</span></code>。</p></li>
<li><p>当没有其他函数匹配时，就会调用新的回退函数（如果接收以太的函数receive不存在，则包括调用数据为空的调用）。
您可以让这个函数是 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 函数或不是。如果它不是 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 函数，
那么不匹配任何其他发送价值的函数的交易将恢复。
只有在采用升级或代理模式时，才需要实现新的回退函数。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id5">
<h3>新功能<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>本节列出了在Solidity 0.6.0之前不可能实现或很难实现的事情。</p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#try-catch"><span class="std std-ref">try/catch语句</span></a> 允许您对失败的外部调用做出反应。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span></code> 和 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 类型可以在文件级别声明。</p></li>
<li><p>数组切片可以用于calldata数组，例如 <code class="docutils literal notranslate"><span class="pre">abi.decode(msg.data[4:],</span> <span class="pre">(uint,</span> <span class="pre">uint))</span></code>
是对函数调用有效负载进行解码的低级方法。</p></li>
<li><p>Natspec在开发者文档中支持多个返回参数，执行与 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 相同的命名检查。</p></li>
<li><p>Yul 和内联汇编有一个新的语句，叫做 <code class="docutils literal notranslate"><span class="pre">leave</span></code>，可以退出当前函数。</p></li>
<li><p>现在可以通过 <code class="docutils literal notranslate"><span class="pre">payable(x)</span></code> 将 <code class="docutils literal notranslate"><span class="pre">address</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 必须是 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。</p></li>
</ul>
</section>
<section id="id6">
<h3>接口变化<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<p>本节列出与语言本身无关但对编译器接口有影响的更改。
这些可能会改变您在命令行上使用编译器的方式，例如，您如何使用它的可编程接口，
或者您如何分析它产生的输出。</p>
<section id="id7">
<h4>新的错误报告器<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>引入一个新的错误报告器，其目的是在命令行上产生更易访问的错误消息。
它在默认情况下是启用的，但是通过 <code class="docutils literal notranslate"><span class="pre">--old-reporter</span></code> 可以返回到弃用的旧错误报告器。</p>
</section>
<section id="id8">
<h4>元数据哈希选项<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>编译器现在默认将元数据文件的 <a class="reference external" href="https://ipfs.io/">IPFS</a> 哈希值附加到字节码的末尾
（详见 <a class="reference internal" href="index.html#document-metadata"><span class="doc">合约元数据</span></a> ） 文档。在0.6.0之前，
编译器默认附加了 <a class="reference external" href="https://ethersphere.github.io/swarm-home/">Swarm</a> 哈希值，
为了仍然支持这种行为，引入了新的命令行选项 <code class="docutils literal notranslate"><span class="pre">--metadata-hash</span></code>。
它允许您通过传递 <code class="docutils literal notranslate"><span class="pre">--metadata-hash</span></code> 命令行选项的 <code class="docutils literal notranslate"><span class="pre">ipfs</span></code> 或 <code class="docutils literal notranslate"><span class="pre">swarm</span></code> 值来选择要产生和附加的哈希。
传递 <code class="docutils literal notranslate"><span class="pre">none</span></code> 则可以完全删除哈希。</p>
<p>这些变化也可以通过 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准JSON接口</span></a> 使用，并影响编译器生成的元数据JSON。</p>
<p>读取元数据的推荐方法是读取最后两个字节，以确定CBOR编码的长度，并对该数据块进行适当的解码，
这在 <a class="reference internal" href="index.html#encoding-of-the-metadata-hash-in-the-bytecode"><span class="std std-ref">元数据部分</span></a> 中有所解释。</p>
</section>
<section id="yul">
<h4>Yul 优化器<a class="headerlink" href="#yul" title="此标题的永久链接"></a></h4>
<p>与传统的字节码优化器一起，<a class="reference internal" href="index.html#document-yul"><span class="doc">Yul</span></a> 优化器现在在用 <code class="docutils literal notranslate"><span class="pre">--optimize</span></code> 参数调用编译器时默认启用。
可以通过 <code class="docutils literal notranslate"><span class="pre">--no-optimize-yul</span></code> 参数在调用编译器时禁用它。这主要影响到使用ABI coder v2的代码。</p>
</section>
<section id="c-api">
<h4>C API 变化<a class="headerlink" href="#c-api" title="此标题的永久链接"></a></h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">libsolc</span></code> 的C API的客户端代码现在可以控制编译器使用的内存。
为了使这一变化保持一致， <code class="docutils literal notranslate"><span class="pre">solidity_free</span></code> 被重新命名为 <code class="docutils literal notranslate"><span class="pre">solidity_reset</span></code>，
增加了函数 <code class="docutils literal notranslate"><span class="pre">solidity_alloc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">solidity_free</span></code>，
<code class="docutils literal notranslate"><span class="pre">solidity_compile</span></code> 现在返回一个必须通过 <code class="docutils literal notranslate"><span class="pre">solidity_free()</span></code> 显式释放的字符串。</p>
</section>
</section>
<section id="id9">
<h3>如何更新您的代码<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h3>
<p>本节详细说明了如何为每一个突破性变化更新先前的代码。</p>
<ul class="simple">
<li><p>将 <code class="docutils literal notranslate"><span class="pre">address(f)</span></code>  改为 <code class="docutils literal notranslate"><span class="pre">f.address</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">f</span></code> 是外部函数类型。</p></li>
<li><p>用 <code class="docutils literal notranslate"><span class="pre">receive()</span> <span class="pre">external</span> <span class="pre">payable</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>， <code class="docutils literal notranslate"><span class="pre">fallback()</span> <span class="pre">external</span> <span class="pre">[payable]</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>
或这两个函数一起来替换 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">()</span> <span class="pre">external</span> <span class="pre">[payable]</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>。
只要有可能，最好只使用 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">length</span> <span class="pre">=</span> <span class="pre">array.push(value)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">array.push(value);</span></code>。
新的长度可以通过 <code class="docutils literal notranslate"><span class="pre">array.length</span></code> 访问。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">array.length++</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">array.push()</span></code> 来增加数组长度，使用 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 来减少存储数组的长度。</p></li>
<li><p>在一个函数的 <code class="docutils literal notranslate"><span class="pre">&#64;dev</span></code> 文档中，为每个命名的返回参数定义一个 <code class="docutils literal notranslate"><span class="pre">&#64;return</span></code> 条目，
将参数的名称作为第一个词。例如，
如果您有定义为 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f()</span> <span class="pre">public</span> <span class="pre">returns</span> <span class="pre">(uint</span> <span class="pre">value)</span></code> 的函数 <code class="docutils literal notranslate"><span class="pre">f()</span></code>，
并且有 <code class="docutils literal notranslate"><span class="pre">&#64;dev</span></code> 注释，那么记录它的返回参数如下： <code class="docutils literal notranslate"><span class="pre">&#64;return</span> <span class="pre">value</span> <span class="pre">The</span> <span class="pre">return</span> <span class="pre">value.</span></code>。
您可以混合使用命名的和未命名的返回参数文档，只要这些声明是按照它们在元组返回类型中出现的顺序即可。</p></li>
<li><p>为内联汇编中的变量声明选择唯一的标识符，不与内联汇编块外的声明冲突。</p></li>
<li><p>在每一个您打算重载的非接口函数上添加 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。
在所有没有具体实现的接口之外的函数上添加 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。
对于单继承，在每个重载的函数上添加 <code class="docutils literal notranslate"><span class="pre">override</span></code>。对于多重继承，添加 <code class="docutils literal notranslate"><span class="pre">override(A,</span> <span class="pre">B,</span> <span class="pre">..)</span></code>，
在括号中列出所有定义了重载函数的合约。当多个基类定义同一个函数时，继承的合约必须重载所有冲突的函数。</p></li>
</ul>
</section>
</section>
<span id="document-070-breaking-changes"></span><section id="solidity-v0-7-0">
<h2>Solidity v0.7.0 突破性变化<a class="headerlink" href="#solidity-v0-7-0" title="此标题的永久链接"></a></h2>
<p>本节强调了 Solidity 0.7.0 版本中引入的主要突破性变化，
以及这些变化背后的原因和如何更新受影响的代码。
对于完整的列表，请查看 <a class="reference external" href="https://github.com/ethereum/solidity/releases/tag/v0.7.0">版本更新日志</a>。</p>
<section id="id2">
<h3>语义的微小变化<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p>用非字符量进行指数和移位（例如： <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">x</span></code> 或 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">x</span></code>）
将总是使用 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 类型（对于非负数）或
<code class="docutils literal notranslate"><span class="pre">int256</span></code> 类型（对于负数）来执行操作。
在此之前，该操作是在移位量/指数的类型中进行的，这可能会产生误导。</p></li>
</ul>
</section>
<section id="id3">
<h3>语法的变化<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p>在外部函数和合约创建调用中，现在使用新的语法指定以太和gas： <code class="docutils literal notranslate"><span class="pre">x.f{gas:</span> <span class="pre">10000,</span> <span class="pre">value:</span> <span class="pre">2</span> <span class="pre">ether}(arg1,</span> <span class="pre">arg2)</span></code>。
旧的语法 -- <code class="docutils literal notranslate"><span class="pre">x.f.gas(10000).value(2</span> <span class="pre">ether)(arg1,</span> <span class="pre">arg2)</span></code> -- 会导致错误。</p></li>
<li><p>全局变量 <code class="docutils literal notranslate"><span class="pre">now</span></code> 已被弃用， 应该使用 <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> 来替换。
对于一个全局变量来说，单一的标识符 <code class="docutils literal notranslate"><span class="pre">now</span></code> 太通用了，可能会让人觉得它在事务处理过程中发生变化，
而 <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> 正确地反映了它只是块的一个属性。</p></li>
<li><p>对变量的NatSpec注释只允许用于公共状态变量，而不允许用于本地或内部变量。</p></li>
<li><p>代号 <code class="docutils literal notranslate"><span class="pre">gwei</span></code> 现在是一个关键词（用于指定，例如 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">gwei</span></code> 作为一个数字），不能作为一个标识符使用。</p></li>
<li><p>字符串现在只能包含可打印的ASCII字符，这也包括各种转义序列，
如十六进制（ <code class="docutils literal notranslate"><span class="pre">\xff</span></code>）和unicode转义（ <code class="docutils literal notranslate"><span class="pre">\u20ac</span></code>）。</p></li>
<li><p>现在支持Unicode字符串文本来容纳有效的UTF-8序列。
它们用 <code class="docutils literal notranslate"><span class="pre">unicode</span></code> 前缀来标识： <code class="docutils literal notranslate"><span class="pre">unicode&quot;Hello</span> <span class="pre">😃&quot;</span></code>。</p></li>
<li><p>状态可变性：现在可以在继承过程中限制函数的状态可变性。
具有默认状态可变性的函数可以被 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 和 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数所覆盖，
而 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数可以被 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数所覆盖。
同时，公共状态变量被认为是 <code class="docutils literal notranslate"><span class="pre">view</span></code>，甚至是 <code class="docutils literal notranslate"><span class="pre">pure</span></code>，如果它们是常量。</p></li>
</ul>
<section id="id4">
<h4>内联汇编<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>在用户定义的函数和变量名称中，不允许在内联汇编中使用 <code class="docutils literal notranslate"><span class="pre">.</span></code>。
如果您在“仅Yul”模式下使用Solidity，它仍然有效。</p></li>
<li><p>存储指针变量 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的槽和偏移量通过 <code class="docutils literal notranslate"><span class="pre">x.slot</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x.offset</span></code> 访问，
而不是 <code class="docutils literal notranslate"><span class="pre">x_slot</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x_offset</span></code>。</p></li>
</ul>
</section>
</section>
<section id="id5">
<h3>移除未使用或不安全的功能<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<section id="id6">
<h4>存储之外的映射关系<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>如果一个结构或数组包含一个映射，它只能在存储中使用。
以前，映射成员在内存中被默默地跳过，这让人困惑，也容易出错。</p></li>
<li><p>如果存储中的结构或数组包含映射，则对其进行赋值是不可行的。
以前，在复制操作过程中，映射会被默默地跳过，这是一种误导，而且容易出错。</p></li>
</ul>
</section>
<section id="id7">
<h4>函数和事件<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>构造函数不再需要可见性（ <code class="docutils literal notranslate"><span class="pre">public</span></code> / <code class="docutils literal notranslate"><span class="pre">internal</span></code>）了。
为了防止合约被创建，可以将其标记为 <code class="docutils literal notranslate"><span class="pre">abstract</span></code>。
这使得构造函数的可见性概念变得过时了。</p></li>
<li><p>类型检查器：不允许库函数为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>：
由于库合约不能被继承，库函数不应该被标记为 virtual。</p></li>
<li><p>不允许在同一继承层次中具有相同名称和参数类型的多个事件。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B</span></code> 只影响到它所提到的合约。以前，这种影响是继承的。
现在，您必须在所有使用该特性的派生合约中重复 <code class="docutils literal notranslate"><span class="pre">using</span></code> 语句。</p></li>
</ul>
</section>
<section id="id8">
<h4>表达式<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>有符号类型的移位是不允许的。以前，允许负数的移位，但它在运行时会被还原。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">finney</span></code> 和 <code class="docutils literal notranslate"><span class="pre">szabo</span></code> 的面额被删除。它们很少被使用，并且不能使实际的金额清晰可见。
相反，可以使用明确的数值，如 <code class="docutils literal notranslate"><span class="pre">1e20</span></code> 或非常常见的 <code class="docutils literal notranslate"><span class="pre">gwei</span></code>。</p></li>
</ul>
</section>
<section id="id9">
<h4>声明<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>关键字 <code class="docutils literal notranslate"><span class="pre">var</span></code> 不能再使用了。
以前，这个关键词可以解析，但会导致一个类型错误，
并建议使用哪种类型。现在，它导致一个解析器错误。</p></li>
</ul>
</section>
</section>
<section id="id10">
<h3>接口变化<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p>JSON AST：用 <code class="docutils literal notranslate"><span class="pre">kind:</span> <span class="pre">&quot;hexString&quot;</span></code> 来标记十六进制字符串文本。</p></li>
<li><p>JSON AST：值为 <code class="docutils literal notranslate"><span class="pre">null</span></code> 的成员将从JSON输出中删除。</p></li>
<li><p>NatSpec：构造器和函数有一致的用户文档输出。</p></li>
</ul>
</section>
<section id="id11">
<h3>如何更新您的代码<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h3>
<p>本节详细说明了如何为每一个突破性变化更新先前的代码。</p>
<ul class="simple">
<li><p>将 <code class="docutils literal notranslate"><span class="pre">x.f.value(...)()</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">x.f{value:</span> <span class="pre">...}()</span></code>。类似地， <code class="docutils literal notranslate"><span class="pre">(new</span> <span class="pre">C).value(...)()</span></code> 改为
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C{value:</span> <span class="pre">...}()</span></code>， <code class="docutils literal notranslate"><span class="pre">x.f.gas(...).value(...)()</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">x.f{gas:</span> <span class="pre">...,</span> <span class="pre">value:</span> <span class="pre">...}()</span></code>。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">now</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code>.</p></li>
<li><p>将移位运算符中的右操作数的类型改为无符号类型。
例如，将 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">(256</span> <span class="pre">-</span> <span class="pre">y)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">uint(256</span> <span class="pre">-</span> <span class="pre">y)</span></code>。</p></li>
<li><p>如果需要，在所有派生合约中重复 <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B</span></code> 的语句。</p></li>
<li><p>从每个构造函数中删除 <code class="docutils literal notranslate"><span class="pre">public</span></code> 关键字。</p></li>
<li><p>从每个构造函数中删除 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 关键字，并在合约中添加 <code class="docutils literal notranslate"><span class="pre">abstract</span></code> （如果还没有存在）。</p></li>
<li><p>将内联汇编中的 <code class="docutils literal notranslate"><span class="pre">_slot</span></code> 和 <code class="docutils literal notranslate"><span class="pre">_offset</span></code> 后缀分别改为 <code class="docutils literal notranslate"><span class="pre">.slot</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.offset</span></code>。</p></li>
</ul>
</section>
</section>
<span id="document-080-breaking-changes"></span><section id="solidity-v0-8-0">
<h2>Solidity v0.8.0 突破性变化<a class="headerlink" href="#solidity-v0-8-0" title="此标题的永久链接"></a></h2>
<p>本节强调了 Solidity 0.8.0 版本中引入的主要突破性变化。对于完整的列表，请查看
<a class="reference external" href="https://github.com/ethereum/solidity/releases/tag/v0.8.0">版本更新日志</a>。</p>
<section id="id2">
<h3>语义的微小变化<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>本节列出了现有代码在编译器没有通知您的情况下改变其行为的更改。</p>
<ul>
<li><p>算术操作在下溢和溢出时都会恢复。您可以使用 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 来使用以前的包装行为。</p>
<p>溢出的检查是非常普遍的，所以我们把它作为默认的检查，
以增加代码的可读性，即使它是以略微增加gas成本为代价的。</p>
</li>
<li><p>ABI编码器v2默认是激活的。</p>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v1;</span></code> 来选择使用旧的行为。
语句 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">ABIEncoderV2;</span></code> 仍然有效，但它已被废弃，没有效果。
如果您想显示使用，请使用 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v2;</span></code> 代替。</p>
<p>请注意，ABI coder v2比v1支持更多的类型，并对输入进行更多的合理性检查。
ABI coder v2使一些函数调用更加昂贵，而且当合约中包含不符合参数类型的数据时，它还会使合约调用回退，
而在ABI coder v1中则没有回退。</p>
</li>
<li><p>指数是右联的，也就是说，表达式 <code class="docutils literal notranslate"><span class="pre">a**b**c</span></code> 被解析为 <code class="docutils literal notranslate"><span class="pre">a**（b**c）</span></code>。
在0.8.0之前，它被解析为 <code class="docutils literal notranslate"><span class="pre">(a**b)**c</span></code>。</p>
<p>这是解析指数运算符的常用方法。</p>
</li>
<li><p>失败的断言和其他内部检查，如除以零或算术溢出，不使用无效的操作码，而是使用恢复操作码。
更具体地说，它们将使用等于对 <code class="docutils literal notranslate"><span class="pre">Panic(uint256)</span></code> 的函数调用的错误数据，其错误代码是针对具体情况的。</p>
<p>这将节省错误的gas，同时它仍然允许静态分析工具将这些情况与无效输入的恢复区分开来，
比如一个失败的 <code class="docutils literal notranslate"><span class="pre">require</span></code>。</p>
</li>
<li><p>如果访问存储中的一个字节数组，其长度被错误地编码，就会引起panic错误。
合约不会出现这种情况，除非使用内联汇编来修改存储字节数组的原始表示。</p></li>
<li><p>如果常数被用于数组长度表达式中，Solidity 的先前版本将在评估树的所有分支中使用任意精度。
现在，如果常量变量被用作中间表达式，它们的值将以与它们在运行时表达式中使用时相同的方式被正确舍入。</p></li>
<li><p>类型 <code class="docutils literal notranslate"><span class="pre">byte</span></code> 已经被删除。它是 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> 的别名。</p></li>
</ul>
</section>
<section id="id3">
<h3>新的限制条件<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>本节列出了可能导致现有合约不再编译的变化。</p>
<ul>
<li><p>有一些与字面常量的显式转换有关的新限制。以前在以下情况下的行为可能是模糊的：</p>
<ol class="arabic simple">
<li><p>不允许从负数字段和大于 <code class="docutils literal notranslate"><span class="pre">type(uint160).max</span></code> 的字段显式转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code>。</p></li>
<li><p>只有当字面常量位于 <code class="docutils literal notranslate"><span class="pre">type(T).min</span></code> 和 <code class="docutils literal notranslate"><span class="pre">type(T).max</span></code> 之间时，
才允许字面常量与整数类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 之间的明确转换。
特别的是，用 <code class="docutils literal notranslate"><span class="pre">type(uint).max</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">uint(-1)</span></code> 的使用。</p></li>
<li><p>只有当字面常量能够代表枚举中的一个值时，才允许字面常量和枚举之间的显式转换。</p></li>
<li><p>字面常量和 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型之间的显式转换（例如， <code class="docutils literal notranslate"><span class="pre">address(literal)</span></code>）是 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，
而不是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型。通过使用显式转换，即 <code class="docutils literal notranslate"><span class="pre">payable(literal)</span></code>，
可以得到一个payable类型的地址类型。</p></li>
</ol>
</li>
<li><p><a class="reference internal" href="index.html#address-literals"><span class="std std-ref">地址字面常量</span></a> 的类型是 <code class="docutils literal notranslate"><span class="pre">address</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。
它们可以通过显式的转换转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型，
例如： <code class="docutils literal notranslate"><span class="pre">payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</span></code>。</p></li>
<li><p>对显式类型转换有新的限制。只有当符号，宽度或类型类别（ <code class="docutils literal notranslate"><span class="pre">int</span></code>， <code class="docutils literal notranslate"><span class="pre">address</span></code>， <code class="docutils literal notranslate"><span class="pre">bytesNN</span></code> 等）
有最多一次变化时，才允许进行转换。要执行多个变化，请使用多个转换。</p>
<p>让我们使用符号 <code class="docutils literal notranslate"><span class="pre">T(S)</span></code> 来表示显式转换 <code class="docutils literal notranslate"><span class="pre">T(x)</span></code>，其中， <code class="docutils literal notranslate"><span class="pre">T</span></code> 和 <code class="docutils literal notranslate"><span class="pre">S</span></code> 是类型，
<code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">S</span></code> 类型的任何任意变量。这种不允许的转换的例子是 <code class="docutils literal notranslate"><span class="pre">uint16(int8)</span></code>，
因为它同时改变了宽度（8位到16位）和符号（有符号整数到无符号整数）。为了进行转换，我们必须通过一个中间类型。
在前面的例子中，这将是 <code class="docutils literal notranslate"><span class="pre">uint16(uint8(int8))</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">uint16(int16(int8))</span></code>。
请注意，这两种转换方式将产生不同的结果，例如，对于 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。下面是这个规则不允许的一些转换的例子。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address(uint)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint(address)</span></code>：同时转换类型和宽度。
分别用 <code class="docutils literal notranslate"><span class="pre">address(uint160(uint))</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint(uint160(address))</span></code> 代替。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">payable(uint160)</span></code>， <code class="docutils literal notranslate"><span class="pre">payable(bytes20)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">payable(integer-literal)</span></code>： 同时转换了类型和状态可变性。
分别用 <code class="docutils literal notranslate"><span class="pre">payable(address(uint160))</span></code>， <code class="docutils literal notranslate"><span class="pre">payable(address(bytes20))</span></code> 和
<code class="docutils literal notranslate"><span class="pre">payable(address(integer-literal))</span></code> 代替。请注意， <code class="docutils literal notranslate"><span class="pre">payable(0)</span></code> 是有效的，是规则的例外。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int80(bytes10)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytes10(int80)</span></code>：同时转换了类型和符号。
分别用 <code class="docutils literal notranslate"><span class="pre">int80(uint80(bytes10))</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytes10(uint80(int80))</span></code> 代替。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Contract(uint)</span></code>: 同时转换类型和宽度。用 <code class="docutils literal notranslate"><span class="pre">Contract(address(uint160(uint)))</span></code> 代替。</p></li>
</ul>
<p>这些转换是不允许的，以避免歧义。例如，在表达式 <code class="docutils literal notranslate"><span class="pre">uint16</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">uint16(int8(-1))</span></code> 中，
<code class="docutils literal notranslate"><span class="pre">x</span></code> 的值取决于是先应用符号还是宽度转换。</p>
</li>
<li><p>函数调用选项只能给出一次，即 <code class="docutils literal notranslate"><span class="pre">c.f{gas:</span> <span class="pre">10000}{value:</span> <span class="pre">1}()</span></code> 是无效的，
必须改成 <code class="docutils literal notranslate"><span class="pre">c.f{gas:</span> <span class="pre">10000,</span> <span class="pre">value:</span> <span class="pre">1}()</span></code>。</p></li>
<li><p>全局函数 <code class="docutils literal notranslate"><span class="pre">log0</span></code>， <code class="docutils literal notranslate"><span class="pre">log1</span></code>， <code class="docutils literal notranslate"><span class="pre">log2</span></code>， <code class="docutils literal notranslate"><span class="pre">log3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">log4</span></code> 已被删除。</p>
<p>这些都是低级别的函数，基本上没有被使用过。它们的行为可以通过内联汇编访问。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span></code> 定义包含的成员不能超过256个。</p>
<p>这将使我们可以安全地假设ABI中的底层类型总是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>。</p>
</li>
<li><p>除了公共函数和事件之外，不允许使用 <code class="docutils literal notranslate"><span class="pre">this</span></code>， <code class="docutils literal notranslate"><span class="pre">super</span></code> 和 <code class="docutils literal notranslate"><span class="pre">_</span></code> 的名称进行声明。
这个例外是为了使声明用Solidity以外的语言实现的合约的接口成为可能，这些语言确实允许这种函数名称。</p></li>
<li><p>移除对代码中的 <code class="docutils literal notranslate"><span class="pre">\b</span></code>， <code class="docutils literal notranslate"><span class="pre">\f</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\v</span></code> 转义序列的支持。
它们仍然可以通过十六进制转义插入，例如：分别是 <code class="docutils literal notranslate"><span class="pre">\x08</span></code>， <code class="docutils literal notranslate"><span class="pre">\x0c</span></code>， 和 <code class="docutils literal notranslate"><span class="pre">\x0b</span></code>。</p></li>
<li><p>全局变量 <code class="docutils literal notranslate"><span class="pre">tx.origin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">address</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。
我们可以通过显式转换将它们转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型，
即 <code class="docutils literal notranslate"><span class="pre">payable(tx.origin)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">payable(msg.sender)</span></code>。</p>
<p>做这个改变是因为编译器不能确定这些地址是否可以支付，所以现在需要一个明确的转换来使这个要求可见。</p>
</li>
<li><p>显式转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型总是返回一个非-payable类型的 <code class="docutils literal notranslate"><span class="pre">address</span></code>。
特别是，以下显式转换的类型是 <code class="docutils literal notranslate"><span class="pre">address</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address(u)</span></code> 其中 <code class="docutils literal notranslate"><span class="pre">u</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">uint160</span></code> 类型的变量。
我们可以通过两个显式转换将 <code class="docutils literal notranslate"><span class="pre">u</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型，即 <code class="docutils literal notranslate"><span class="pre">payable(address(u))</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address(b)</span></code> 其中 <code class="docutils literal notranslate"><span class="pre">b</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">bytes20</span></code> 类型的变量。
我们可以通过两个显式转换将 <code class="docutils literal notranslate"><span class="pre">b</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型，即 <code class="docutils literal notranslate"><span class="pre">payable(address(b))</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address(c)</span></code> 其中 <code class="docutils literal notranslate"><span class="pre">c</span></code> 是一个合约。以前，这种转换的返回类型取决于合约是否可以接收以太
（要么有一个receive函数，要么有一个payable类型的fallback函数）。
转换 <code class="docutils literal notranslate"><span class="pre">payable(c)</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，只有当合约 <code class="docutils literal notranslate"><span class="pre">c</span></code> 可以接收以太时才允许。
一般来说，人们总是可以通过使用以下显式转换将 <code class="docutils literal notranslate"><span class="pre">c</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 的类型：
<code class="docutils literal notranslate"><span class="pre">payable(address(c))</span></code>。请注意， <code class="docutils literal notranslate"><span class="pre">address(this)</span></code> 与 <code class="docutils literal notranslate"><span class="pre">address(c)</span></code> 属于同一类别，
同样的规则也适用于它。</p></li>
</ul>
</li>
<li><p>内联汇编中的 <code class="docutils literal notranslate"><span class="pre">chainid</span></code> 现在被认为是 <code class="docutils literal notranslate"><span class="pre">view</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">pure</span></code>。</p></li>
<li><p>一元求反不能再用于无符号整数，只能用于有符号整数。</p></li>
</ul>
</section>
<section id="id4">
<h3>接口变化<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--combined-json</span></code> 的输出已经改变。JSON字段 <code class="docutils literal notranslate"><span class="pre">abi</span></code>, <code class="docutils literal notranslate"><span class="pre">devdoc</span></code>, <code class="docutils literal notranslate"><span class="pre">userdoc</span></code> 和
<code class="docutils literal notranslate"><span class="pre">storage-layout</span></code> 现在是子对象。在0.8.0之前，它们曾被序列化为字符串。</p></li>
<li><p>“传统AST“ 已被删除（ <code class="docutils literal notranslate"><span class="pre">--ast-json</span></code> 在命令行界面， <code class="docutils literal notranslate"><span class="pre">legacyAST</span></code> 用于标准JSON）。
使用 “紧凑型AST”（ <code class="docutils literal notranslate"><span class="pre">--ast-compact-json</span></code> 参数. <code class="docutils literal notranslate"><span class="pre">AST</span></code>）作为替代。</p></li>
<li><p>旧的错误报告器（ <code class="docutils literal notranslate"><span class="pre">--old-reporter</span></code> ）已经被删除。</p></li>
</ul>
</section>
<section id="id5">
<h3>如何更新您的代码<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p>如果您依赖包装算术，请用 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 包裹每个操作。</p></li>
<li><p>可选：如果您使用SafeMath或类似的库，将 <code class="docutils literal notranslate"><span class="pre">x.add(y)</span></code>  改为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>， <code class="docutils literal notranslate"><span class="pre">x.mul(y)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> 等等。</p></li>
<li><p>如果您想继续使用旧的ABI编码器，请添加 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v1;</span></code>。</p></li>
<li><p>可以选择删除 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">ABIEncoderV2</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v2</span></code> 因为它是多余的。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">byte</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code>。</p></li>
<li><p>如果需要的话，添加中间显式类型转换。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">c.f{gas:</span> <span class="pre">10000}{value:</span> <span class="pre">1}()</span></code> 合并为 <code class="docutils literal notranslate"><span class="pre">c.f{gas:</span> <span class="pre">10000,</span> <span class="pre">value:</span> <span class="pre">1}()</span></code>。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">msg.sender.transfer(x)</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">payable(msg.sender).transfer(x)</span></code>
或者使用 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型的存储变量。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">x**y**z</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">(x**y)**z</span></code>。</p></li>
<li><p>Use inline assembly as a replacement for <code class="docutils literal notranslate"><span class="pre">log0</span></code>, ..., <code class="docutils literal notranslate"><span class="pre">log4</span></code>.</p></li>
<li><p>使用内联汇编作为 <code class="docutils literal notranslate"><span class="pre">log0</span></code>， ...， <code class="docutils literal notranslate"><span class="pre">log4</span></code> 的替代。</p></li>
<li><p>通过从某类型的最大值中减去该值并加上1来否定该无符号整数
（例如， <code class="docutils literal notranslate"><span class="pre">type(uint256).max</span> <span class="pre">-</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>，同时确保 <cite>x</cite> 不是零）。</p></li>
</ul>
</section>
</section>
<span id="document-natspec-format"></span><section id="natspec">
<span id="id1"></span><h2>风格指南<a class="headerlink" href="#natspec" title="此标题的永久链接"></a></h2>
<p>Solidity合约可以使用一种特殊形式的注释来为函数，返回变量等提供丰富的文档。
这种特殊形式被命名为Ethereum自然语言规范格式（NatSpec）。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>NatSpec是受 <a class="reference external" href="https://en.wikipedia.org/wiki/Doxygen">Doxygen</a> 的启发。
虽然它使用Doxygen风格的注释和标签，但并不打算与Doxygen保持严格的兼容性。
请仔细检查下面列出的支持的标签。</p>
</div>
<p>该文件被划分为以开发人员为中心的信息和面向最终用户的信息。
这些信息可以在终端用户（人类）与合约交互（即签署交易）时显示给他们。</p>
<p>建议 Solidity 合约使用 NatSpec 对所有公共接口（ABI中的一切）进行完全地注释。</p>
<p>NatSpec 包括智能合约作者将使用的注释的格式，
这些注释可被 Solidity 编译器理解。
下面还详细介绍了 Solidity 编译器的输出，
它将这些注释提取为机器可读的格式。</p>
<p>NatSpec 也可以包括第三方工具使用的注释。
这些最可能是通过 <code class="docutils literal notranslate"><span class="pre">&#64;custom:&lt;name&gt;</span></code> 标签完成的，
一个好的用例是分析和验证工具就是如此。</p>
<section id="header-doc-example">
<span id="id2"></span><h3>文档示例<a class="headerlink" href="#header-doc-example" title="此标题的永久链接"></a></h3>
<p>文档可以通过使用 Doxygen 符号格式来嵌入到每个 <code class="docutils literal notranslate"><span class="pre">contract</span></code>， <code class="docutils literal notranslate"><span class="pre">interface</span></code>， <code class="docutils literal notranslate"><span class="pre">library</span></code>，
<code class="docutils literal notranslate"><span class="pre">function</span></code> 和 <code class="docutils literal notranslate"><span class="pre">event</span></code> 之上。在 NatSpec 中， <code class="docutils literal notranslate"><span class="pre">public</span></code> 状态变量等同于 <code class="docutils literal notranslate"><span class="pre">function</span></code>。</p>
<ul class="simple">
<li><p>对于Solidity，您可以选择 <code class="docutils literal notranslate"><span class="pre">///</span></code> 用于单行注释
或以 <code class="docutils literal notranslate"><span class="pre">/**</span></code> 开始，并以 <code class="docutils literal notranslate"><span class="pre">*/</span></code> 结束的符号用于多行注释</p></li>
<li><p>对于Vyper来说，使用 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;&quot;</span></code> 缩进到内部内容来裸注释（译者注：无标记符号注释）。
参见 <a class="reference external" href="https://vyper.readthedocs.io/en/latest/natspec.html">Vyper 文档</a>。</p></li>
</ul>
<p>下面的例子显示了一个合约和一个使用所有可用标记的函数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Solidity 编译器只在标签是外部或公共的情况下才进行解析。
但也欢迎您为您的内部和私有函数使用类似的注释，不过这些不会被解析。</p>
<p>这在未来可能会发生变化。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjIgPCAwLjkuMDsKCi8vLyBAdGl0bGUg5qCR55qE5qih5ouf5ZmoCi8vLyBAYXV0aG9yIExhcnJ5IEEuIEdhcmRuZXIKLy8vIEBub3RpY2Ug5oKo5Y+q6IO95bCG5q2k5ZCI57qm55So5LqO5pyA5Z+65pys55qE5qih5ouf44CCCi8vLyBAZGV2IOebruWJjeaJgOacieeahOWHveaVsOiwg+eUqOmDveaYr+WcqOayoeacieWJr+S9nOeUqOeahOaDheWGteS4i+WunueOsOeahAovLy8gQGN1c3RvbTpleHBlcmltZW50YWwg6L+Z5piv5LiA5Liq5a6e6aqM5oCn55qE5ZCI57qm44CCCmNvbnRyYWN0IFRyZWUgewogICAgLy8vIEBub3RpY2Ug6K6h566X5rS75L2T5qCR5pyo55qE5qCR6b6E77yM5oyJ5Zub6IiN5LqU5YWl6K6h566XCiAgICAvLy8gQGRldiBBbGV4YW5kciBOLiBUZXRlYXJpbmcg566X5rOV5Y+v5Lul5o+Q6auY57K+56Gu5bqmCiAgICAvLy8gQHBhcmFtIHJpbmdzIOagkem+hOWtpuagt+acrOeahOeOr+aVsAogICAgLy8vIEByZXR1cm4g5qCR6b6E77yI5bKB77yJ77yM6YOo5YiG5bm05Lu95Zub6IiN5LqU5YWlCiAgICBmdW5jdGlvbiBhZ2UodWludDI1NiByaW5ncykgZXh0ZXJuYWwgdmlydHVhbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gcmluZ3MgKyAxOwogICAgfQoKICAgIC8vLyBAbm90aWNlIOi/lOWbnuivpeagkeeahOWPtuWtkOaVsOmHj+OAggogICAgLy8vIEBkZXYg5Zyo5q2k5Y+q5piv6L+U5Zue5LqG5LiA5Liq5Zu65a6a55qE5pWw5a2X44CCCiAgICBmdW5jdGlvbiBsZWF2ZXMoKSBleHRlcm5hbCB2aXJ0dWFsIHB1cmUgcmV0dXJucyh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIDI7CiAgICB9Cn0KCmNvbnRyYWN0IFBsYW50IHsKICAgIGZ1bmN0aW9uIGxlYXZlcygpIGV4dGVybmFsIHZpcnR1YWwgcHVyZSByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gMzsKICAgIH0KfQoKY29udHJhY3QgS3VtcXVhdFRyZWUgaXMgVHJlZSwgUGxhbnQgewogICAgZnVuY3Rpb24gYWdlKHVpbnQyNTYgcmluZ3MpIGV4dGVybmFsIG92ZXJyaWRlIHB1cmUgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiByaW5ncyArIDI7CiAgICB9CgogICAgLy8vIOi/lOWbnui/meenjeeJueWumuexu+Wei+eahOagkeeahOWPtuWtkOaVsOmHj+OAggogICAgLy8vIEBpbmhlcml0ZG9jIFRyZWUg5ZCI57qmCiAgICBmdW5jdGlvbiBsZWF2ZXMoKSBleHRlcm5hbCBvdmVycmlkZShUcmVlLCBQbGFudCkgcHVyZSByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gMzsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">/// </span><span class="cs">@title</span><span class="c1"> 树的模拟器</span>
<span class="c1">/// </span><span class="cs">@author</span><span class="c1"> Larry A. Gardner</span>
<span class="c1">/// </span><span class="cs">@notice</span><span class="c1"> 您只能将此合约用于最基本的模拟。</span>
<span class="c1">/// </span><span class="cs">@dev</span><span class="c1"> 目前所有的函数调用都是在没有副作用的情况下实现的</span>
<span class="c1">/// </span><span class="cs">@custom:experimental</span><span class="c1"> 这是一个实验性的合约。</span>
<span class="kd">contract</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="c1">/// </span><span class="cs">@notice</span><span class="c1"> 计算活体树木的树龄，按四舍五入计算</span>
    <span class="c1">/// </span><span class="cs">@dev</span><span class="c1"> Alexandr N. Tetearing 算法可以提高精确度</span>
    <span class="c1">/// </span><span class="cs">@param</span><span class="c1"> rings 树龄学样本的环数</span>
    <span class="c1">/// </span><span class="cs">@return</span><span class="c1"> 树龄（岁），部分年份四舍五入</span>
    <span class="kd">function</span> <span class="n">age</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">rings</span><span class="p">)</span> <span class="k">external</span> <span class="k">virtual</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rings</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// </span><span class="cs">@notice</span><span class="c1"> 返回该树的叶子数量。</span>
    <span class="c1">/// </span><span class="cs">@dev</span><span class="c1"> 在此只是返回了一个固定的数字。</span>
    <span class="kd">function</span> <span class="n">leaves</span><span class="p">()</span> <span class="k">external</span> <span class="k">virtual</span> <span class="k">pure</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Plant</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">leaves</span><span class="p">()</span> <span class="k">external</span> <span class="k">virtual</span> <span class="k">pure</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">KumquatTree</span> <span class="k">is</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">Plant</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">age</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">rings</span><span class="p">)</span> <span class="k">external</span> <span class="k">override</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rings</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// 返回这种特定类型的树的叶子数量。</span>
    <span class="c1">/// </span><span class="cs">@inheritdoc</span><span class="c1"> Tree 合约</span>
    <span class="kd">function</span> <span class="n">leaves</span><span class="p">()</span> <span class="k">external</span> <span class="k">override</span><span class="p">(</span><span class="n">Tree</span><span class="p">,</span> <span class="n">Plant</span><span class="p">)</span> <span class="k">pure</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="header-tags">
<span id="id3"></span><h3>标签<a class="headerlink" href="#header-tags" title="此标题的永久链接"></a></h3>
<p>所有标签都是可选的。下表解释了每个 NatSpec 标签的目的和它可能被使用的地方。
有一种特殊情况，如果没有使用标签，那么 Solidity 编译器将以同样的方式进行 <code class="docutils literal notranslate"><span class="pre">///</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/**</span></code> 注释，
如同它被标记为 <code class="docutils literal notranslate"><span class="pre">&#64;notice</span></code>。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 50%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>标签</p></th>
<th class="head"></th>
<th class="head"><p>应用于</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;title</span></code></p></td>
<td><p>一个应该描述合约/接口的标题</p></td>
<td><p>contract, library, interface</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;author</span></code></p></td>
<td><p>作者的名字</p></td>
<td><p>contract, library, interface</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;notice</span></code></p></td>
<td><p>向终端用户解释这个东西的作用</p></td>
<td><p>contract, library, interface, function, public state variable, event</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;dev</span></code></p></td>
<td><p>向开发人员解释任何额外的细节</p></td>
<td><p>contract, library, interface, function, state variable, event</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;param</span></code></p></td>
<td><p>就像在Doxygen中一样记录一个参数（必须在参数名之后）</p></td>
<td><p>function, event</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;return</span></code></p></td>
<td><p>记录一个合约的函数的返回变量</p></td>
<td><p>function, public state variable</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;inheritdoc</span></code></p></td>
<td><p>从基本函数中复制所有缺失的标签（必须在合约名称之后）</p></td>
<td><p>function, public state variable</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;custom:...</span></code></p></td>
<td><p>自定义标签，语义由应用程序定义</p></td>
<td><p>everywhere</p></td>
</tr>
</tbody>
</table>
<p>如果您的函数返回多个值，如 <code class="docutils literal notranslate"><span class="pre">(int</span> <span class="pre">quotient,</span> <span class="pre">int</span> <span class="pre">remainder)</span></code>
那么使用多个 <code class="docutils literal notranslate"><span class="pre">&#64;return</span></code> 语句，格式与 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 语句相同。</p>
<p>自定义标签以 <code class="docutils literal notranslate"><span class="pre">&#64;custom:</span></code> 开头，后面必须有一个或多个小写字母或连字符。
然而，它不能以连字符开始。它们可以在任何地方使用，是开发者文档的一部分。</p>
<section id="header-dynamic">
<span id="id4"></span><h4>动态表达方式<a class="headerlink" href="#header-dynamic" title="此标题的永久链接"></a></h4>
<p>Solidity 编译器将通过 NatSpec 文档从您的 Solidity 源代码传递到本指南所述的 JSON 输出。
此 JSON 输出的使用者，例如最终用户的客户端软件，可以直接将其呈现给最终用户，或者它可以应用一些预处理。</p>
<p>例如，一些客户端软件会呈现为：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8vIEBub3RpY2Ug6L+Z5Liq5Ye95pWw5bCG5L2/IGBhYCDkuZjku6U3"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">/// </span><span class="cs">@notice</span><span class="c1"> 这个函数将使 `a` 乘以7</span>
</pre></div>
</div>
<p>对终端用户来说，是：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>这个函数将10乘以7
</pre></div>
</div>
<p>如果一个函数被调用，并且输入的 <code class="docutils literal notranslate"><span class="pre">a</span></code> 被赋值为10。</p>
<p>指定这些动态表达式超出了 Solidity 文档的范围，您可以在
<a class="reference external" href="https://github.com/aragon/radspec">radspec 项目</a> 阅读更多内容。</p>
</section>
<section id="header-inheritance">
<span id="id5"></span><h4>继承说明<a class="headerlink" href="#header-inheritance" title="此标题的永久链接"></a></h4>
<p>没有NatSpec的函数将自动继承其基函数的文档。这方面的例外情况是：</p>
<ul class="simple">
<li><p>当参数名称不同时。</p></li>
<li><p>当有不止一个的基础函数时。</p></li>
<li><p>当有一个明确的 <code class="docutils literal notranslate"><span class="pre">&#64;inheritdoc</span></code> 标签，指定了应该使用哪个合约来继承。</p></li>
</ul>
</section>
</section>
<section id="header-output">
<span id="id6"></span><h3>文件输出<a class="headerlink" href="#header-output" title="此标题的永久链接"></a></h3>
<p>当被编译器解析时，像上面例子中的文档将产生两个不同的JSON文件。
一个是为了让终端用户在执行函数时作为通知使用，另一个是为了让开发人员使用。</p>
<p>如果上述合约被保存为 <code class="docutils literal notranslate"><span class="pre">ex1.sol</span></code>，那么您可以用以下方法生成文档：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>--userdoc<span class="w"> </span>--devdoc<span class="w"> </span>ex1.sol
</pre></div>
</div>
<p>输出如下。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>从Solidity 0.6.11版开始，NatSpec输出也包含一个 <code class="docutils literal notranslate"><span class="pre">version（版本号）</span></code> 和一个 <code class="docutils literal notranslate"><span class="pre">kind（种类）</span></code> 字段。
目前， <code class="docutils literal notranslate"><span class="pre">version</span></code> 被设置为 <code class="docutils literal notranslate"><span class="pre">1</span></code>， <code class="docutils literal notranslate"><span class="pre">kind</span></code> 必须是 <code class="docutils literal notranslate"><span class="pre">user（用户）</span></code> 或 <code class="docutils literal notranslate"><span class="pre">dev（开发者）</span></code> 之一。
在未来，有可能会引入新的版本，淘汰旧的版本。</p>
</div>
<section id="header-user-doc">
<span id="id7"></span><h4>用户文档<a class="headerlink" href="#header-user-doc" title="此标题的永久链接"></a></h4>
<p>上述文档将产生以下用户文档 JSON 文件作为输出：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;version&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;kind&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;user&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;methods&quot;</span><span class="w"> </span><span class="p">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;age(uint256)&quot;</span><span class="w"> </span><span class="p">:</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;notice&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;计算活体树木的树龄，按四舍五入计算&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;notice&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;您只能将此合约用于最基本的模拟。&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，找到方法的关键是 <a class="reference internal" href="index.html#abi-function-selector"><span class="std std-ref">合约 ABI</span></a> 中定义的函数的标准签名，
而不是简单的函数名称。</p>
</section>
<section id="header-developer-doc">
<span id="id8"></span><h4>开发者文档<a class="headerlink" href="#header-developer-doc" title="此标题的永久链接"></a></h4>
<p>除了用户文档文件，还应该产生一个开发者文档的JSON文件，看起来应该是这样的：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;version&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;kind&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;dev&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;author&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Larry A. Gardner&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;details&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;目前所有的函数调用都是在没有副作用的情况下实现的&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;custom:experimental&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;这是一个实验性的合约。&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;methods&quot;</span><span class="w"> </span><span class="p">:</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;age(uint256)&quot;</span><span class="w"> </span><span class="p">:</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;details&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Alexandr N. Tetearing 算法可以提高精确度&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;params&quot;</span><span class="w"> </span><span class="p">:</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;rings&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;树龄学样本的环数&quot;</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="nt">&quot;return&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;树龄（岁），部分年份四舍五入&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;title&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;树的模拟器&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<span id="document-security-considerations"></span><section id="security-considerations">
<span id="id1"></span><h2>安全考虑<a class="headerlink" href="#security-considerations" title="此标题的永久链接"></a></h2>
<p>虽然通常很容易建立起按预期工作的软件，但要检查没有人能够以 <strong>非</strong> 预期的方式使用它，就难得多了。</p>
<p>在 Solidity 中，这一点更加重要，因为您可以使用智能合约来处理代币，
甚至可能是更有价值的东西。此外，
智能合约的每一次执行都是公开的，而且源代码也通常是容易获得的。</p>
<p>当然，您总是要考虑有多大的风险：您可以将智能合约与一个对公众开放（因此也对恶意行为者开放），
甚至可能是开源的网络服务进行比较。如果您只在该网络服务上存储您的杂货清单，
您可能不必太过小心，但如果您使用该网络服务管理您的银行账户，您就应该更加小心。</p>
<p>本节将列出一些陷阱和一般安全建议，但当然不可能是完整的。
此外，请记住，即使您的智能合约代码没有错误，编译器或平台本身也可能有一个错误。
编译器的一些公开的，与安全有关的bug列表可以在 <a class="reference internal" href="index.html#known-bugs"><span class="std std-ref">已知错误列表</span></a> 中找到，
它也是机器可读的。请注意，有一个涵盖 Solidity 编译器代码生成器的错误赏金计划。</p>
<p>像往常一样，对于开源文档，请帮助我们扩展这部分内容（尤其是，一些例子不会有什么影响）！</p>
<p>注意：除了下面的列表，您也可以在
<a class="reference external" href="https://github.com/guylando/KnowledgeLists/blob/master/EthereumSmartContracts.md">Guy Lando 的知识列表</a>
和 <a class="reference external" href="https://consensys.github.io/smart-contract-best-practices/">Consensys GitHub 代码仓库</a>
中找到更多的安全建议和最佳实践。</p>
<section id="id2">
<h3>陷阱<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<section id="id3">
<h4>隐私信息和随机性<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<p>您在智能合约中使用的所有东西都是公开可见的，即使是标记为 <code class="docutils literal notranslate"><span class="pre">private</span></code> 的局部变量和状态变量。</p>
<p>如果您不希望矿工能够作弊，在智能合约中使用随机数是相当棘手的。</p>
</section>
<section id="id4">
<h4>重入<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p>一个合约（A）与另一个合约（B）的任何交互和任何以太币的转移都会将控制权交给该合约（B）。
这使得 B 有可能在这个交互完成之前回调回 A。举个例子，
下面的代码包含了一个漏洞（这只是一个片段，而不是一个完整的合约）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g5q2k5ZCI57qm5YyF5ZCr5LiA5Liq5ryP5rSeIC0g6K+35Yu/5L2/55SoCmNvbnRyYWN0IEZ1bmQgewogICAgLy8vIEBkZXYg5ZCI57qm55qE5Lul5aSq5biB5Lu96aKd55qE5pig5bCE44CCCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgc2hhcmVzOwogICAgLy8vIOaPkOWPluaCqOeahOS7vemineOAggogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBwdWJsaWMgewogICAgICAgIGlmIChwYXlhYmxlKG1zZy5zZW5kZXIpLnNlbmQoc2hhcmVzW21zZy5zZW5kZXJdKSkKICAgICAgICAgICAgc2hhcmVzW21zZy5zZW5kZXJdID0gMDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 此合约包含一个漏洞 - 请勿使用</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Fund</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// @dev 合约的以太币份额的映射。</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>shares<span class="p">;</span>
<span class="w">    </span><span class="c1">/// 提取您的份额。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>send<span class="p">(</span>shares<span class="p">[</span><span class="k">msg.sender</span><span class="p">]))</span>
<span class="w">            </span>shares<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里的问题不是太严重，因为作为 <code class="docutils literal notranslate"><span class="pre">send</span></code> 的一部分，gas 有限，
但它仍然暴露了一个弱点: 以太币的转移总是可以包括代码的执行，
所以接收者可以是一个回调到 <code class="docutils literal notranslate"><span class="pre">withdraw</span></code> 的合约。
这将让它获得多次退款，并基本上取回合约中的所有以太。
特别的是，下面的合约将允许攻击者多次退款，因为它使用了 <code class="docutils literal notranslate"><span class="pre">call</span></code>，
它会默认转发所有剩余 gas。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKLy/mraTlkIjnuqbljIXlkKvkuIDkuKrmvI/mtJ4gLSDor7fli7/kvb/nlKgKY29udHJhY3QgRnVuZCB7CiAgICAvLy8gQGRldiDlkIjnuqbnmoTku6XlpKrluIHku73pop3nmoTmmKDlsITjgIIKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBzaGFyZXM7CiAgICAvLy8g5o+Q5Y+W5oKo55qE5Lu96aKd44CCCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIHB1YmxpYyB7CiAgICAgICAgKGJvb2wgc3VjY2VzcywpID0gbXNnLnNlbmRlci5jYWxse3ZhbHVlOiBzaGFyZXNbbXNnLnNlbmRlcl19KCIiKTsKICAgICAgICBpZiAoc3VjY2VzcykKICAgICAgICAgICAgc2hhcmVzW21zZy5zZW5kZXJdID0gMDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">//此合约包含一个漏洞 - 请勿使用</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Fund</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// @dev 合约的以太币份额的映射。</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>shares<span class="p">;</span>
<span class="w">    </span><span class="c1">/// 提取您的份额。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">.</span>call<span class="p">{</span>value<span class="o">:</span><span class="w"> </span>shares<span class="p">[</span><span class="k">msg.sender</span><span class="p">]}(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>success<span class="p">)</span>
<span class="w">            </span>shares<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了避免重入，您可以使用如下所示的 检查-生效-交互（Checks-Effects-Interactions）模式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgRnVuZCB7CiAgICAvLy8gQGRldiDlkIjnuqbnmoTku6XlpKrluIHku73pop3nmoTmmKDlsITjgIIKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBzaGFyZXM7CiAgICAvLy8g5o+Q5Y+W5oKo55qE5Lu96aKd44CCCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIHB1YmxpYyB7CiAgICAgICAgdWludCBzaGFyZSA9IHNoYXJlc1ttc2cuc2VuZGVyXTsKICAgICAgICBzaGFyZXNbbXNnLnNlbmRlcl0gPSAwOwogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoc2hhcmUpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Fund</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// @dev 合约的以太币份额的映射。</span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>shares<span class="p">;</span>
<span class="w">    </span><span class="c1">/// 提取您的份额。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">share</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>shares<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span>shares<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span>share<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>检查-生效-交互模式确保所有通过合约的代码路径
在修改合约的状态（检查）之前完成对所提供的参数的所有必要检查；只有这样它才会对状态进行任何改变（生效）；
在所有计划的状态改变被写入存储 <em>之后</em> ，它可能会对其他合约中的函数进行调用（交互）。
这是一种常见的防止 <em>重入性攻击</em> 的万无一失的方法，在这种情况下，
外部调用的恶意合约能够通过使用在原始合约最终完成交易之前回调原始合约的逻辑来重复花费津贴，重复提取余额，以及其他事情。</p>
<p>请注意，重入不仅是对以太币转移的影响，
也是对另一个合约的任何函数调用的影响。
此外，您还必须考虑到多合约的情况。
一个被调用的合约可以修改您所依赖的另一个合约的状态。</p>
</section>
<section id="gas">
<h4>gas 限制和循环<a class="headerlink" href="#gas" title="此标题的永久链接"></a></h4>
<p>对于没有固定迭代次数的循环，例如，依赖于存储值的循环，必须谨慎使用：
由于块 gas 的限制，事务只能消耗一定量的 gas。
无论是明确的还是仅仅由于正常的操作，循环中的迭代次数可以增长到超过块 gas 限制，
这可能导致完整的合约在某一点上停滞。这可能不适用于只为从区块链上读取数据而执行的 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数。
但是，这样的函数可能会被其他合约调用，作为链上操作的一部分，并使其停滞。请在您的合约文档中明确说明这种情况。</p>
</section>
<section id="id5">
<h4>发送和接收以太币<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>无论是合约还是 “外部账户”，目前都无法阻止有人向他们发送以太币。
合约可以对普通的转账做出反应并拒绝，但有一些方法可以在不创建消息调用的情况下转移以太币。
一种方法是简单地向合约地址“挖矿”，第二种方法是使用 <code class="docutils literal notranslate"><span class="pre">selfdestruct(x)</span></code>。</p></li>
<li><p>如果一个合约收到了以太（没有函数被调用），要么是执行 <a class="reference internal" href="index.html#receive-ether-function"><span class="std std-ref">receive 方法</span></a>，
要么执行 <a class="reference internal" href="index.html#fallback-function"><span class="std std-ref">fallback</span></a> 函数。如果它没有 receive 也没有 fallback 函数，
那么该以太将被拒绝（抛出一个异常）。在这些函数的执行过程中，
合约只能依靠此时它所传递的 “gas津贴”（2300 gas）可用。但这个津贴不足以修改存储
（但不要认为这是理所当然的，这个津贴可能会随着未来的硬分叉而改变）。
为了确保您的合约能够以这种方式接收以太，请检查 receive 和 fallback 函数的 gas 要求
（在 Remix 的“详细”章节会举例说明）。</p></li>
<li><p>有一种方法可以使用 <code class="docutils literal notranslate"><span class="pre">addr.call{value:</span> <span class="pre">x}(&quot;&quot;)</span></code> 将更多的 gas 转发给接收合约。
这与 <code class="docutils literal notranslate"><span class="pre">addr.transfer(x)</span></code> 本质上是一样的，只是它转发了所有剩余的 gas，
并为接收方提供了执行更昂贵的操作的能力（而且它返回一个失败代码，而不是自动传播错误）。
这可能包括回调到发送合约或其他您可能没有想到的状态变化。
因此，这种方法无论是给诚实用户还是恶意行为者都提供了极大的灵活性。</p></li>
<li><p>尽可能使用最精确的单位来表示 wei 的数量，因为您会因为缺乏精确性而失去任何四舍五入的结果。</p></li>
<li><p>如果您想用 <code class="docutils literal notranslate"><span class="pre">address.transfer</span></code> 来发送以太，有一些细节需要注意：</p>
<ol class="arabic simple">
<li><p>如果接收者是一个合约，它会导致其 receive 或 fallback 函数被执行，
而该函数又可以回调发送以太的合约。</p></li>
<li><p>发送以太可能由于调用深度超过1024而失败。由于调用者完全控制着调用深度，他们可以迫使传输失败；
考虑到这种可能性，或者使用 <code class="docutils literal notranslate"><span class="pre">send</span></code>，并确保总是检查其返回值。
更好的办法是，使用接收者可以提取以太币的模式来编写您的合约。</p></li>
<li><p>发送以太也可能失败，因为接收合约的执行需要超过分配的 gas 值
（确切地说，是使用了 <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">require</span></a>， <a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">assert</span></a>，
<a class="reference internal" href="index.html#assert-and-require"><span class="std std-ref">revert</span></a> 或者因为操作太昂贵）- 它 “耗尽了 gas“（OOG）。
如果您使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 或 <code class="docutils literal notranslate"><span class="pre">send</span></code>，并带有返回值检查，这可能为接收者提供一种手段来阻止发送合约的进展。
同样，这里的最佳做法是使用 <a class="reference internal" href="index.html#withdrawal-pattern"><span class="std std-ref">&quot;提款&quot; 模式而不是 &quot;发送&quot;模式</span></a>。</p></li>
</ol>
</li>
</ul>
</section>
<section id="id6">
<h4>调用栈深度<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<p>外部函数调用随时都可能失败，因为它们超过了最大调用堆栈大小1024的限制。
在这种情况下，Solidity 会抛出一个异常。恶意的行为者可能会在与您的合约交互之前，
将调用堆栈逼到一个高值。请注意，由于 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-608">桔子哨子（Tangerine Whistle）</a>
硬分叉， <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-150">63/64规则</a> 使得调用栈深度攻击不切实际。
还要注意的是，调用栈和表达式栈是不相关的，尽管两者都有1024个栈槽的大小限制。</p>
<p>注意 <code class="docutils literal notranslate"><span class="pre">.send()</span></code> 在调用栈被耗尽的情况下 <strong>不会</strong> 抛出异常，
而是会返回 <code class="docutils literal notranslate"><span class="pre">false</span></code>。低级函数 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>， <code class="docutils literal notranslate"><span class="pre">.delegatecall()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.staticcall()</span></code>
也都是这样的。</p>
</section>
<section id="id8">
<h4>授权的代理<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>如果您的合约可以作为一个代理，也就是说，如果它可以用用户提供的数据调用任意的合约，
那么用户基本上可以承担代理合约的身份。即使您有其他的保护措施，
最好是建立您的合约系统，使代理没有任何权限（甚至对自己也没有）。
如果需要，您可以使用第二个代理来完成：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKY29udHJhY3QgUHJveHlXaXRoTW9yZUZ1bmN0aW9uYWxpdHkgewogICAgUGVybWlzc2lvbmxlc3NQcm94eSBwcm94eTsKCiAgICBmdW5jdGlvbiBjYWxsT3RoZXIoYWRkcmVzcyBhZGRyLCBieXRlcyBtZW1vcnkgcGF5bG9hZCkgcHVibGljCiAgICAgICAgICAgIHJldHVybnMgKGJvb2wsIGJ5dGVzIG1lbW9yeSkgewogICAgICAgIHJldHVybiBwcm94eS5jYWxsT3RoZXIoYWRkciwgcGF5bG9hZCk7CiAgICB9CiAgICAvLyDlhbbku5blh73mlbDlkozlhbbku5blip/og70KfQoKLy8g6L+Z5piv5a6M5pW055qE5ZCI57qm77yM5a6D5rKh5pyJ5YW25LuW5Yqf6IO977yM5LiN6ZyA6KaB5Lu75L2V5p2D6ZmQ5bCx5Y+v5Lul5bel5L2c44CCCmNvbnRyYWN0IFBlcm1pc3Npb25sZXNzUHJveHkgewogICAgZnVuY3Rpb24gY2FsbE90aGVyKGFkZHJlc3MgYWRkciwgYnl0ZXMgbWVtb3J5IHBheWxvYWQpIHB1YmxpYwogICAgICAgICAgICByZXR1cm5zIChib29sLCBieXRlcyBtZW1vcnkpIHsKICAgICAgICByZXR1cm4gYWRkci5jYWxsKHBheWxvYWQpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">ProxyWithMoreFunctionality</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>PermissionlessProxy<span class="w"> </span>proxy<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callOther</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>payload<span class="p">)</span><span class="w"> </span><span class="kt">public</span>
<span class="w">            </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>proxy<span class="p">.</span>callOther<span class="p">(</span>addr<span class="p">,</span><span class="w"> </span>payload<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 其他函数和其他功能</span>
<span class="p">}</span>

<span class="c1">// 这是完整的合约，它没有其他功能，不需要任何权限就可以工作。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">PermissionlessProxy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callOther</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>payload<span class="p">)</span><span class="w"> </span><span class="kt">public</span>
<span class="w">            </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>addr<span class="p">.</span>call<span class="p">(</span>payload<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="tx-origin">
<h4>tx.origin<a class="headerlink" href="#tx-origin" title="此标题的永久链接"></a></h4>
<p>永远不要使用 tx.origin 做身份认证。假设您有一个这样的钱包合约：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDmnKzlkIjnuqbljIXlkKvkuIDkuKrmvI/mtJ4gLSDor7fli7/kvb/nlKgKY29udHJhY3QgVHhVc2VyV2FsbGV0IHsKICAgIGFkZHJlc3Mgb3duZXI7CgogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgb3duZXIgPSBtc2cuc2VuZGVyOwogICAgfQoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyVG8oYWRkcmVzcyBwYXlhYmxlIGRlc3QsIHVpbnQgYW1vdW50KSBwdWJsaWMgewogICAgICAgIC8vIOa8j+a0nuWwseWcqOi/memHjO+8jOaCqOW/hemhu+S9v+eUqCBtc2cuc2VuZGVyIOiAjOS4jeaYryB0eC5vcmlnaW7jgIIKICAgICAgICByZXF1aXJlKHR4Lm9yaWdpbiA9PSBvd25lcik7CiAgICAgICAgZGVzdC50cmFuc2ZlcihhbW91bnQpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="c1">// 本合约包含一个漏洞 - 请勿使用</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">TxUserWallet</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferTo</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>dest<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 漏洞就在这里，您必须使用 msg.sender 而不是 tx.origin。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">tx.origin</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">);</span>
<span class="w">        </span>dest<span class="p">.</span>transfer<span class="p">(</span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在有人欺骗您，让您向这个攻击钱包的地址发送以太币：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwppbnRlcmZhY2UgVHhVc2VyV2FsbGV0IHsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyVG8oYWRkcmVzcyBwYXlhYmxlIGRlc3QsIHVpbnQgYW1vdW50KSBleHRlcm5hbDsKfQoKY29udHJhY3QgVHhBdHRhY2tXYWxsZXQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgIH0KCiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgVHhVc2VyV2FsbGV0KG1zZy5zZW5kZXIpLnRyYW5zZmVyVG8ob3duZXIsIG1zZy5zZW5kZXIuYmFsYW5jZSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
interface<span class="w"> </span>TxUserWallet<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferTo</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>dest<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">TxAttackWallet</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>TxUserWallet<span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transferTo<span class="p">(</span>owner<span class="p">,</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">.</span>balance<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您的钱包检查了 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 的授权，它将得到攻击钱包的地址，而不是所有者地址。
但是通过检查 <code class="docutils literal notranslate"><span class="pre">tx.origin</span></code>，它得到的是启动交易的原始地址，这仍然是所有者地址。
攻击钱包会立即耗尽您的所有资金。</p>
</section>
<section id="underflow-overflow">
<span id="id9"></span><h4>二进制补码 / 下溢 / 上溢<a class="headerlink" href="#underflow-overflow" title="此标题的永久链接"></a></h4>
<p>正如在许多编程语言中，Solidity 的整数类型实际上不是整数。
当数值较小时，它们类似于整数，但也不能表示任意大的数字。</p>
<p>下面的代码会导致溢出，因为加法的结果太大，不能存储在 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 类型中：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludDggeCA9IDI1NTsKdWludDggeSA9IDE7CnJldHVybiB4ICsgeTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">255</span><span class="p">;</span>
<span class="kt">uint8</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span>y<span class="p">;</span>
</pre></div>
</div>
<p>Solidity 有两种模式来处理这些溢出。检查和不检查或 “包装” 模式。</p>
<p>默认的检查模式将检测到溢出并导致一个失败的断言。
您可以使用 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>，使溢出被无声地忽略。
上面的代码如果用 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 包装，将返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<p>即使在检查模式下，也不要认为您受到了保护，不会出现溢出错误。
在这种模式下，溢出总是会被还原。如果无法避免溢出，这可能导致智能合约被卡在某个状态。</p>
<p>一般来说，请阅读关于二进制补码表示法的限制，它甚至对有符号的数字有一些更特殊的边缘情况。</p>
<p>尝试使用 <code class="docutils literal notranslate"><span class="pre">require</span></code> 将输入的大小限制在一个合理的范围内，
并使用:ref:<cite>SMT 检查器 &lt;smt_checker&gt;</cite> 来发现潜在的溢出。</p>
</section>
<section id="clearing-mappings">
<span id="id10"></span><h4>清除映射<a class="headerlink" href="#clearing-mappings" title="此标题的永久链接"></a></h4>
<p>Solidity <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 类型（见 <a class="reference internal" href="index.html#mapping-types"><span class="std std-ref">映射类型</span></a>）是一个仅有存储空间的键值数据结构，
它不跟踪被分配非零值的键。正因为如此，清理映射时不可能有关于写入键的额外信息。
如果 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 被用作动态存储数组的基本类型，删除或弹出数组将不会对 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 元素产生影响。
例如，如果一个 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 被用作一个 <code class="docutils literal notranslate"><span class="pre">struct</span></code> 的成员字段的类型，
而该结构是一个动态存储阵列的基本类型，同样的情况也会发生。
<code class="docutils literal notranslate"><span class="pre">mapping</span></code> 在包含 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 的结构或数组的分配中也会被忽略。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwIHsKICAgIG1hcHBpbmcgKHVpbnQgPT4gdWludClbXSBhcnJheTsKCiAgICBmdW5jdGlvbiBhbGxvY2F0ZSh1aW50IG5ld01hcHMpIHB1YmxpYyB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgbmV3TWFwczsgaSsrKQogICAgICAgICAgICBhcnJheS5wdXNoKCk7CiAgICB9CgogICAgZnVuY3Rpb24gd3JpdGVNYXAodWludCBtYXAsIHVpbnQga2V5LCB1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIGFycmF5W21hcF1ba2V5XSA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlYWRNYXAodWludCBtYXAsIHVpbnQga2V5KSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGFycmF5W21hcF1ba2V5XTsKICAgIH0KCiAgICBmdW5jdGlvbiBlcmFzZU1hcHMoKSBwdWJsaWMgewogICAgICAgIGRlbGV0ZSBhcnJheTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Map</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)[]</span><span class="w"> </span>array<span class="p">;</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">allocate</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newMaps</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>newMaps<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span>
<span class="w">            </span>array<span class="p">.</span>push<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">writeMap</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">map</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>array<span class="p">[</span>map<span class="p">][</span>key<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">readMap</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">map</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>array<span class="p">[</span>map<span class="p">][</span>key<span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">eraseMaps</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>delete<span class="w"> </span>array<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>考虑一下上面的例子和下面的调用序列： <code class="docutils literal notranslate"><span class="pre">allocate(10)</span></code>， <code class="docutils literal notranslate"><span class="pre">writeMap(4,</span> <span class="pre">128,</span> <span class="pre">256)</span></code>。
此时，调用 <code class="docutils literal notranslate"><span class="pre">readMap(4,</span> <span class="pre">128)</span></code> 返回256。如果我们调用 <code class="docutils literal notranslate"><span class="pre">eraseMaps</span></code>，
状态变量 <code class="docutils literal notranslate"><span class="pre">array</span></code> 的长度被清零，但由于它的 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 元素不能被清零，
它们的信息在合约的存储中仍然存在。
删除 <code class="docutils literal notranslate"><span class="pre">array</span></code> 后，调用 <code class="docutils literal notranslate"><span class="pre">allocate(5)</span></code> 允许我们再次访问 <code class="docutils literal notranslate"><span class="pre">array[4]</span></code>，
调用 <code class="docutils literal notranslate"><span class="pre">readMap(4,</span> <span class="pre">128)</span></code> 则返回256，即使没有再次调用 <code class="docutils literal notranslate"><span class="pre">writeMap</span></code>。</p>
<p>如果您的 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 信息必须被删除，可以考虑使用类似于
<a class="reference external" href="https://github.com/ethereum/dappbin/blob/master/library/iterable_mapping.sol">可迭代的映射</a> 的库，
它允许您在适当的 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 中遍历键并删除其值。</p>
</section>
<section id="id12">
<h4>细枝末节<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>没有占满32字节的类型可能包含 “脏高位”。
这在当您访问 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code> 的时候尤为重要 —— 它带来了延展性风险：
您既可以用原始字节 <code class="docutils literal notranslate"><span class="pre">0xff000001</span></code>，也可以用 <code class="docutils literal notranslate"><span class="pre">0x00000001</span></code> 作为参数来调用
函数 <code class="docutils literal notranslate"><span class="pre">f(uint8</span> <span class="pre">x)</span></code>  以构造交易。
您可以制作一些交易，调用一个函数 <code class="docutils literal notranslate"><span class="pre">f(uint8</span> <span class="pre">x)</span></code> ，这两个参数都会被正常提供给合约，
就 <code class="docutils literal notranslate"><span class="pre">x</span></code>  而言，两者看起来都是数字 <code class="docutils literal notranslate"><span class="pre">1</span></code>， 但 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code> 将是不同的，
所以如果您无论怎么使用 <code class="docutils literal notranslate"><span class="pre">keccak256(msg.data)</span></code>，您都会得到不同的结果。</p></li>
</ul>
</section>
</section>
<section id="id13">
<h3>推荐做法<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h3>
<section id="id14">
<h4>认真对待警告<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h4>
<p>如果编译器警告您一些事情，您应该改变它。
即使您不认为这个特定的警告有安全问题，但也可能在它下面埋藏着另一个问题。
我们发出的任何编译器警告都可以通过对代码的轻微修改来消除。</p>
<p>始终使用最新版本的编译器，以获知所有最近引入的警告。</p>
<p>编译器发出的 <code class="docutils literal notranslate"><span class="pre">info</span></code> 类型的信息并不危险，只是代表编译器认为可能对用户有用的额外建议和可选信息。</p>
</section>
<section id="id15">
<h4>限制以太币的数量<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h4>
<p>限制智能合约中可存储的以太币（或其他代币）的数量。
如果您的源代码，编译器或平台有错误，这些资金可能会丢失。
如果您想限制您的损失，就限制以太币的数量。</p>
</section>
<section id="id16">
<h4>保持合约简练且模块化<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>保持您的合约短小而容易理解。把不相关的功能单独放在其他合约中或放在库中。
关于源代码质量的一般建议当然也适用：限制局部变量的数量和函数的长度，等等。
给您的函数添加注释，这样别人就可以看到您的意图是什么，
并判断代码是否按照正确的意图实现。</p>
</section>
<section id="checks-effects-interactions">
<h4>使用“检查-生效-交互”（Checks-Effects-Interactions）模式<a class="headerlink" href="#checks-effects-interactions" title="此标题的永久链接"></a></h4>
<p>大多数函数会首先进行一些检查（谁调用了这个函数，参数是否在范围内，
他们是否发送了足够的以太，这个人是否有代币，等等）。这些检查应该首先完成。</p>
<p>第二步，如果所有的检查都通过了，就应该对当前合约的状态变量进行影响。
与其他合约的交互应该是任何函数的最后一步。</p>
<p>早期的合约延迟了一些效果，等待外部函数调用在非错误状态下返回。
这往往是一个严重的错误，因为上面解释了重入问题。</p>
<p>请注意，对已知合约的调用也可能反过来导致对未知合约的调用，因此，最好总是应用这种模式。</p>
</section>
<section id="fail-safe">
<h4>包含故障-安全（Fail-Safe）模式<a class="headerlink" href="#fail-safe" title="此标题的永久链接"></a></h4>
<p>尽管将系统完全去中心化可以省去许多中间环节，但包含某种故障-安全模式仍然是好的做法，
尤其是对于新的代码来说：</p>
<p>您可以在您的智能合约中添加一个功能，执行一些自我检查，如 “是否有任何以太币泄漏？”，
“代币的总和是否等于合约的余额？” 或类似的事情。
请记住，您不能为此使用太多的 gas，所以可能需要通过链外计算的帮助。</p>
<p>如果自我检查失败，合约会自动切换到某种 “故障安全” 模式，
例如，禁用大部分功能，将控制权移交给一个固定的，可信赖的第三方，
或者只是将合约转换为一个简单的 “退回我的钱” 的合约。</p>
</section>
<section id="id17">
<h4>请求同行评审<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h4>
<p>检查一段代码的人越多，发现的问题就越多。
要求其他人审查您的代码也有助于作为交叉检查，
找出您的代码是否容易理解 - 这是好的智能合约的一个非常重要的标准。</p>
</section>
</section>
</section>
<span id="document-smtchecker"></span><section id="smt">
<span id="formal-verification"></span><h2>SMT检查器和形式化验证<a class="headerlink" href="#smt" title="此标题的永久链接"></a></h2>
<p>使用形式化验证，有可能进行自动数学证明，
证明您的源代码符合某种形式化规范。
该规范仍然是正式的（就像源代码一样），但通常要简单得多。</p>
<p>请注意，形式化验证本身只能帮助您理解您所做的（规范）和您如何做的（实际实现）之间的区别。
您仍然需要检查规范是否是您想要的，以及您没有遗漏任何意想不到的效果。</p>
<p>Solidity 实现了基于 <a class="reference external" href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theoris">SMT（可满足性模型理论（Satisfiability Modulo Theories）</a>
和 <a class="reference external" href="https://en.wikipedia.org/wiki/Horn-satisfiability">Horn</a> 解决的形式验证方法。
SMT检查器模块自动尝试证明代码满足由 <code class="docutils literal notranslate"><span class="pre">require</span></code> 和 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 语句给出的规范。
也就是说，它把 <code class="docutils literal notranslate"><span class="pre">require</span></code> 语句视为假设，并试图证明 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 语句中的条件总是真的。
如果发现断言失败，则可以向用户提供一个反例，说明断言是如何被违反的。
如果 SMT 检查器对某一属性没有给出警告，这意味着该属性是安全的。</p>
<p>SMT 检查器在编译时检查的其他验证目标有：</p>
<ul class="simple">
<li><p>算术上的下溢和溢出。</p></li>
<li><p>除以0的除法。</p></li>
<li><p>无用的条件和无法访问的代码。</p></li>
<li><p>弹出一个空数组。</p></li>
<li><p>超出界限的索引访问。</p></li>
<li><p>转账资金不足。</p></li>
</ul>
<p>如果所有检查引擎都被启用，上述所有目标都被默认为自动检查，
除了 Solidity &gt;=0.8.7 的下溢和溢出。</p>
<p>SMT 检查器所报告的潜在警告是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;失败的属性&gt;</span> <span class="pre">发生在这里</span></code>。这意味着 SMT 检查器证明了某一属性失败。可能会给出一个反例，但是在复杂的情况下，也可能不会显示反例。在某些情况下，当 SMT 编码为 Solidity 代码添加了难以表达或无法表达的抽象时，这个结果也可能是一个假阳性。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;失败的属性&gt;</span> <span class="pre">可能发生在这里</span></code>。这意味着求解器无法在给定的超时时间内证明两种情况。由于结果是未知的，SMT 检查器会报告潜在的健全性失败。这可以通过增加查询超时时间来解决，但问题也可能只是对引擎来说太难解决。</p></li>
</ul>
<p>要启用SMT检查器，您必须选择 <a class="reference internal" href="#smtchecker-engines"><span class="std std-ref">应该运行哪一个引擎</span></a>，
其中默认的是没有引擎。选择引擎可以在所有文件上启用SMT检查器。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Solidity 0.8.4 之前，启用SMT检查器的默认方式是通过 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">SMTChecker;</span></code>
并且只有包含 pragma 的合约才会被分析。该 pragma 已被弃用，
尽管它仍能使SMT检查器向后兼容，但它将在 Solidity 0.9.0 中被移除。
还要注意的是，现在即使在一个文件中使用 pragma，也会对所有文件启用SMT检查器。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>假设SMT检查器和底层求解器中没有错误，
那么验证目标没有警告就代表了一个无可争议的正确性数学证明。
请记住，这些问题在一般情况下是 <em>很难</em> 的，有时是 <em>不可能</em> 自动解决的。
因此，有几个属性可能无法解决，或者可能导致大型合约的假阳性。
每一个被证明的属性都应该被看作是一个重要的成就。
对于高级用户，请参阅 <a class="reference internal" href="#smtchecker-options"><span class="std std-ref">SMT检查器 调优</span></a>
来了解一些可能有助于证明更复杂属性的选项。</p>
</div>
<section id="id1">
<h3>教程<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h3>
<section id="id2">
<h4>溢出<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h4>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhZGQoeCwgeSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Overflow</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">y</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">add</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x_</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y_</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x_</span> <span class="o">+</span> <span class="n">y_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x_</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y_</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">stateAdd</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的合约显示了一个溢出检查的例子。
对于 Solidity &gt;=0.8.7，SMT检查器默认不检查下溢和溢出，
所以我们需要使用命令行选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-targets</span> <span class="pre">&quot;underflow,overflow&quot;</span></code>
或者JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.targets</span> <span class="pre">=</span> <span class="pre">[&quot;underflow&quot;,</span> <span class="pre">&quot;overflow&quot;]</span></code>。
参见 <a class="reference internal" href="#smtchecker-targets"><span class="std std-ref">本节的目标配置</span></a>。此处，它报告如下：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Overflow (resulting value larger than 2**256 - 1) happens here.
Counterexample:
x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
 = 0

Transaction trace:
Overflow.constructor(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
State: x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
Overflow.stateAdd()
    Overflow.add(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935) -- internal call
 --&gt; o.sol:9:20:
  |
9 |             return x_ + y_;
  |                    ^^^^^^^
</pre></div>
</div>
<p>如果我们添加了过滤掉溢出情况的 <code class="docutils literal notranslate"><span class="pre">require</span></code> 语句，
SMT检查器就会证明没有溢出是可以达到的（会通过不报告警告表现出来）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXF1aXJlKHkgPCB0eXBlKHVpbnQxMjgpLm1heCk7CiAgICAgICAgcmV0dXJuIGFkZCh4LCB5KTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Overflow</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">y</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">add</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x_</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y_</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x_</span> <span class="o">+</span> <span class="n">y_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x_</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y_</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">stateAdd</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="k">type(uint128).max);</span>
<span class="k">        require(y &lt; type(uint128).max</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id3">
<h4>断言<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h4>
<p>断言表示代码中的一个不变量： <em>对于所有的事务，包括所有的输入和存储值</em>，
一个属性必须为真，否则就会出现错误。</p>
<p>下面的代码定义了一个保证没有溢出的函数 <code class="docutils literal notranslate"><span class="pre">f</span></code>。
函数 <code class="docutils literal notranslate"><span class="pre">inv</span></code> 定义了 <code class="docutils literal notranslate"><span class="pre">f</span></code> 是单调递增的规范：
对于每个可能的数值对 <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>，如果 <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">a</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">f(b)</span> <span class="pre">&gt;</span> <span class="pre">f(a)</span></code>。
由于 <code class="docutils literal notranslate"><span class="pre">f</span></code> 确实是单调增长的，SMT检查器证明了我们的属性是正确的。
我们鼓励您试试这个属性和函数定义，看看会有什么样的结果!</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNb25vdG9uaWMgewogICAgZnVuY3Rpb24gZih1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXR1cm4geCAqIDQyOwogICAgfQoKICAgIGZ1bmN0aW9uIGludih1aW50IGEsIHVpbnQgYikgcHVibGljIHB1cmUgewogICAgICAgIHJlcXVpcmUoYiA+IGEpOwogICAgICAgIGFzc2VydChmKGIpID4gZihhKSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Monotonic</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="k">type(uint128).max</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">inv</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">);</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们还可以在循环中添加断言，以验证更多的复杂的属性。
下面的代码搜索一个不受限制的数字数组的最大元素，
并断言找到的元素必须大于或等于数组中的每个元素的属性。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHVpbnQgbSA9IDA7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgaWYgKGFbaV0gPiBtKQogICAgICAgICAgICAgICAgbSA9IGFbaV07CgogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpCiAgICAgICAgICAgIGFzc2VydChtID49IGFbaV0pOwoKICAgICAgICByZXR1cm4gbTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Max</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">max</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">a</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="nf">assert</span><span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，在这个例子中，SMT检查器将自动尝试证明三个属性：</p>
<ol class="arabic simple">
<li><p>第一个循环中的 <code class="docutils literal notranslate"><span class="pre">++i</span></code> 不会溢出。</p></li>
<li><p>第二个循环中的 <code class="docutils literal notranslate"><span class="pre">++i</span></code> 不会溢出。</p></li>
<li><p>该断言始终是正确的。</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这些属性涉及到循环，这使得它比前面的例子 <em>更加</em> 难了，所以要当心循环的问题！</p>
</div>
<p>所有的属性都被正确证明是安全的。
可以随意改变属性和/或在数组上添加限制，以看到不同的结果。例如，将代码改为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoYS5sZW5ndGggPj0gNSk7CiAgICAgICAgdWludCBtID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKQogICAgICAgICAgICBpZiAoYVtpXSA+IG0pCiAgICAgICAgICAgICAgICBtID0gYVtpXTsKCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgYXNzZXJ0KG0gPiBhW2ldKTsKCiAgICAgICAgcmV0dXJuIG07CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Max</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">max</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">a</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">);</span>
        <span class="kt">uint</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="nf">assert</span><span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们得到的结果：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Assertion violation happens here.
Counterexample:

a = [0, 0, 0, 0, 0]
 = 0

Transaction trace:
Test.constructor()
Test.max([0, 0, 0, 0, 0])
  --&gt; max.sol:14:4:
   |
14 |            assert(m &gt; a[i]);
</pre></div>
</div>
</section>
<section id="id4">
<h4>状态属性<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p>到目前为止，这些例子只展示了SMT检查器在纯代码上的使用，
证明了关于特定操作或算法的属性。
智能合约中常见的属性类型是涉及合约状态的属性。
对于这样的属性，可能需要多个交易来使断言失效。</p>
<p>举一个例子，考虑一个二维网格，其中两个轴的坐标都在（-2^128, 2^128 - 1）范围内。
让我们在位置（0，0）放置一个机器人。该机器人只能在对角线上移动，一次只能走一步，
不能在网格外移动。机器人的状态机可以用下面的智能合约来表示。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSb2JvdCB7CiAgICBpbnQgeCA9IDA7CiAgICBpbnQgeSA9IDA7CgogICAgbW9kaWZpZXIgd2FsbCB7CiAgICAgICAgcmVxdWlyZSh4ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB4IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgcmVxdWlyZSh5ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB5IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlTGVmdFVwKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICArK3k7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZUxlZnREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZVJpZ2h0VXAoKSB3YWxsIHB1YmxpYyB7CiAgICAgICAgKyt4OwogICAgICAgICsreTsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlUmlnaHREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgICsreDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gaW52KCkgcHVibGljIHZpZXcgewogICAgICAgIGFzc2VydCgoeCArIHkpICUgMiA9PSAwKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Robot</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kd">modifier</span> <span class="n">wall</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="k">type(int128).min &amp;&amp; x &lt; type(int128).max);</span>
<span class="k">        require(y &gt; type(int128).min &amp;&amp; y &lt; type(int128).max</span><span class="p">);</span>
        <span class="k">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveLeftUp</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">x</span><span class="p">;</span>
        <span class="o">++</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveLeftDown</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">x</span><span class="p">;</span>
        <span class="o">--</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveRightUp</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">x</span><span class="p">;</span>
        <span class="o">++</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveRightDown</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">x</span><span class="p">;</span>
        <span class="o">--</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">inv</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="p">{</span>
        <span class="nf">assert</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">inv</span></code> 代表状态机的一个不变量，即 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 必须是偶数。
SMT检查器设法证明，无论我们给机器人多少条命令，
即使是无限多的命令，这个不变量都 <em>不会</em> 失败。
有兴趣的读者可能也想手动证明这个事实。 提示：这个不变量是归纳性的。</p>
<p>我们也可以欺骗SMT检查器，让它给我们提供一条通往某个我们认为可能是可访问的位置的路径。
我们可以通过添加以下函数，来增加(2, 4)是 <em>不</em> 可访问的属性。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gcmVhY2hfMl80KCkgcHVibGljIHZpZXcgewogICAgYXNzZXJ0KCEoeCA9PSAyICYmIHkgPT0gNCkpOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">reach_2_4</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="p">{</span>
    <span class="nf">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个属性是假的，在证明这个属性是假的同时，
SMT检查器准确地告诉我们 <em>如何</em> 访问到(2, 4)。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Assertion violation happens here.
Counterexample:
x = 2, y = 4

Transaction trace:
Robot.constructor()
State: x = 0, y = 0
Robot.moveLeftUp()
State: x = (- 1), y = 1
Robot.moveRightUp()
State: x = 0, y = 2
Robot.moveRightUp()
State: x = 1, y = 3
Robot.moveRightUp()
State: x = 2, y = 4
Robot.reach_2_4()
  --&gt; r.sol:35:4:
   |
35 |            assert(!(x == 2 &amp;&amp; y == 4));
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</pre></div>
</div>
<p>请注意，上面的路径不一定是确定的，
因为还有其他路径可以访问（2，4）。
选择哪条路径可能会根据所使用的解算器，其使用版本，或者只是随机地改变。</p>
</section>
<section id="id5">
<h4>外部调用和重入<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<p>每个外部调用都被SMT检查器视为对未知代码的调用。
这背后的原因是，即使被调用合约的代码在编译时是可用的，
也不能保证部署的合约确实与编译时接口所在的合约相同。</p>
<p>在某些情况下，有可能在状态变量上自动推断出属性，
即使外部调用的代码可以做任何事情，包括重新进入调用者合约，
这些属性仍然是真的。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVW5rbm93biB7CiAgICBmdW5jdGlvbiBydW4oKSBleHRlcm5hbDsKfQoKY29udHJhY3QgTXV0ZXggewogICAgdWludCB4OwogICAgYm9vbCBsb2NrOwoKICAgIFVua25vd24gaW1tdXRhYmxlIHVua25vd247CgogICAgY29uc3RydWN0b3IoVW5rbm93biB1KSB7CiAgICAgICAgcmVxdWlyZShhZGRyZXNzKHUpICE9IGFkZHJlc3MoMCkpOwogICAgICAgIHVua25vd24gPSB1OwogICAgfQoKICAgIG1vZGlmaWVyIG11dGV4IHsKICAgICAgICByZXF1aXJlKCFsb2NrKTsKICAgICAgICBsb2NrID0gdHJ1ZTsKICAgICAgICBfOwogICAgICAgIGxvY2sgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCB4XykgbXV0ZXggcHVibGljIHsKICAgICAgICB4ID0geF87CiAgICB9CgogICAgZnVuY3Rpb24gcnVuKCkgbXV0ZXggcHVibGljIHsKICAgICAgICB1aW50IHhQcmUgPSB4OwogICAgICAgIHVua25vd24ucnVuKCk7CiAgICAgICAgYXNzZXJ0KHhQcmUgPT0geCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">interface</span> <span class="n">Unknown</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">run</span><span class="p">()</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Mutex</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">lock</span><span class="p">;</span>

    <span class="n">Unknown</span> <span class="kr">immutable</span> <span class="n">unknown</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="n">Unknown</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">unknown</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="n">mutex</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">_</span><span class="p">;</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">set</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x_</span><span class="p">)</span> <span class="n">mutex</span> <span class="k">public</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">run</span><span class="p">()</span> <span class="n">mutex</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">xPre</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">unknown</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">xPre</span> <span class="o">==</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的例子显示了一个使用互斥标志来禁止重入的合约。
解算器能够推断出，当 <code class="docutils literal notranslate"><span class="pre">unknown.run()</span></code> 被调用时，合约已经被 “锁定”，
所以无论未知的调用代码做什么，都不可能改变 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值。</p>
<p>如果我们 “忘记” 在函数 <code class="docutils literal notranslate"><span class="pre">set</span></code> 上使用 <code class="docutils literal notranslate"><span class="pre">mutex</span></code> 修饰符，
SMT检查器就能合成外部调用代码的行为，从而使断言失败。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Assertion violation happens here.
Counterexample:
x = 1, lock = true, unknown = 1

Transaction trace:
Mutex.constructor(1)
State: x = 0, lock = false, unknown = 1
Mutex.run()
    unknown.run() -- untrusted external call, synthesized as:
        Mutex.set(1) -- reentrant call
  --&gt; m.sol:32:3:
   |
32 |                assert(xPre == x);
   |                ^^^^^^^^^^^^^^^^^
</pre></div>
</div>
</section>
</section>
<section id="smtchecker-options">
<span id="id6"></span><h3>SMT检查器选项和调试<a class="headerlink" href="#smtchecker-options" title="此标题的永久链接"></a></h3>
<section id="id7">
<h4>超时<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>SMT检查器使用了一个硬编码的资源限制（ <code class="docutils literal notranslate"><span class="pre">rlimit</span></code> ），
这个限制是根据每个求解器选择的，与时间没有确切的关系。
我们选择 <code class="docutils literal notranslate"><span class="pre">rlimit</span></code> 选项作为默认值，因为它比求解器内部的时间提供了更多的确定性保证。</p>
<p>这个选项大致转化为每个查询 “几秒钟超时”。
当然，许多属性非常复杂，需要大量的时间来解决，而决定并不重要。
如果SMT检查器不能用默认的 <code class="docutils literal notranslate"><span class="pre">rlimit</span></code> 选项处理合约属性，
则可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-timeout</span> <span class="pre">&lt;time&gt;</span></code> 或
JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.timeout=&lt;time&gt;</span></code> 给出以毫秒为单位的超时。
其中0表示不超时。</p>
</section>
<section id="smtchecker-targets">
<span id="id8"></span><h4>验证目标<a class="headerlink" href="#smtchecker-targets" title="此标题的永久链接"></a></h4>
<p>SMT检查器创建的验证目标的类型也可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-target</span> <span class="pre">&lt;targets&gt;</span></code>
或JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.targets=&lt;targets&gt;</span></code> 来定制。
在CLI情况下， <code class="docutils literal notranslate"><span class="pre">&lt;targets&gt;</span></code> 是一个没有空格的逗号分隔的一个或多个验证目标的列表，
在JSON输入中是一个或多个作为字符串的目标数组。
代表目标的关键词是：</p>
<ul class="simple">
<li><p>断言： <code class="docutils literal notranslate"><span class="pre">assert</span></code>。</p></li>
<li><p>算术下溢： <code class="docutils literal notranslate"><span class="pre">underflow</span></code>。</p></li>
<li><p>算术溢出： <code class="docutils literal notranslate"><span class="pre">overflow</span></code>。</p></li>
<li><p>除以零： <code class="docutils literal notranslate"><span class="pre">divByZero</span></code>。</p></li>
<li><p>无用的条件和无法访问的代码： <code class="docutils literal notranslate"><span class="pre">constantCondition</span></code>。</p></li>
<li><p>弹出一个空数组： <code class="docutils literal notranslate"><span class="pre">popEmptyArray</span></code>。</p></li>
<li><p>越界的数组/固定字节索引访问： <code class="docutils literal notranslate"><span class="pre">outOfBounds</span></code>。</p></li>
<li><p>转账资金不足： <code class="docutils literal notranslate"><span class="pre">balance</span></code>。</p></li>
<li><p>以上都是： <code class="docutils literal notranslate"><span class="pre">default</span></code> （仅适用CLI）。</p></li>
</ul>
<p>一个常见的目标子集可能是，例如： <code class="docutils literal notranslate"><span class="pre">--model-checker-targets</span> <span class="pre">assert,overflow</span></code>。</p>
<p>所有目标都被默认检查，除了Solidity &gt;=0.8.7的下溢和溢出。</p>
<p>关于如何以及何时分割验证目标，没有精确的指导方法。
但在处理大型合约时，它可能是有用的。</p>
</section>
<section id="id9">
<h4>未验证的目标<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>如果有任何未验证的目标，SMT检查器会发出一个警告，
说明有多少个未验证的目标。如果用户希望看到所有具体的未验证的目标，
可以使用CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-show-unproved</span></code>
和JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.showUnproved</span> <span class="pre">=</span> <span class="pre">true</span></code>。</p>
</section>
<section id="id10">
<h4>已验证过的合约<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h4>
<p>默认情况下，给定来源中的所有可部署合约都会被单独分析，正如将被部署的那一个合约一样。
这意味着，如果一个合约有许多直接和间接的继承父类，所有这些都将被单独分析，
尽管只有最终派生的合约可以在区块链上被直接访问。
这给SMT检查器和求解器造成了不必要的负担。
为了帮助缓解这样的情况，用户可以指定哪些合约应该作为部署的合约进行分析。
当然，基类合约仍然被分析，但只是在分析最终派生的合约的情况下才进行，
这可以减少编码和生成查询的复杂性。
请注意，抽象合约在默认情况下不会被SMT检查器分析为最终派生的合约。</p>
<p>选择的合约可以通过CLI，用 &lt;source&gt;:&lt;contract&gt; 形式的键值对，以逗号分隔的列表（不允许有空格）给出：
<code class="docutils literal notranslate"><span class="pre">--model-checker-contracts</span> <span class="pre">&quot;&lt;source1.sol:contract1&gt;,&lt;source2.sol:contract2&gt;,&lt;source2.sol:contract3&gt;&quot;</span></code>，
以及通过 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">JSON 输入</span></a> 中的对象 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.contracts</span></code>，它有如下格式：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;contracts&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;source1.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract1&quot;</span><span class="p">],</span>
<span class="w">    </span><span class="nt">&quot;source2.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;contract3&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id11">
<h4>报告推断的归纳变量<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>于那些被CHC引擎证明为安全的属性，
SMT检查器可以检索由Horn求解器推断出的归纳不变性，作为证明的一部分。
目前有两种类型的不变量可以报告给用户：</p>
<ul class="simple">
<li><p>合约不变量：这些是合约的状态变量的属性，在合约可能运行的每一个可能的事务之前和之后都是真的。
例如， <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 是一个合约的状态变量。</p></li>
<li><p>可重入性属性：它们代表了合约在存在对未知代码的外部调用时的行为。
这些属性可以表达外部调用前后状态变量的值之间的关系，
其中外部调用可以自由地做任何事情，包括对分析的合约进行可重入调用。
导数变量代表所述外部调用后的状态变量的值。例如： <code class="docutils literal notranslate"><span class="pre">lock</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x'</span></code>。</p></li>
</ul>
<p>用户可以使用CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-invariants</span> <span class="pre">&quot;contract,reentrancy&quot;</span></code> 来选择要报告的不变量类型，
或者在 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">JSON 输入</span></a> 中的字段 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.invariants</span></code> 中作为数组。
默认情况下，SMT检查器不报告不变量。</p>
</section>
<section id="id12">
<h4>有松弛变量的除法和模数运算<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<p>Spacer是SMT检查器使用的默认Horn求解器，它通常不喜欢Horn规则中的除法和模数操作。
正因为如此，默认情况下，Solidity的除法和模运算是用约束条件 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">m</span></code> 来编码的，
其中 <code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></code> 和 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>。
然而，对于其他求解器，如Eldarica，更喜欢语法上的精确操作。
命令行标志 <code class="docutils literal notranslate"><span class="pre">--model-checker-div-mod-no-slacks</span></code> 和
JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.divModNoSlacks</span></code> 可以用来切换编码，
这取决于所用求解器的偏好。</p>
</section>
<section id="natspec">
<h4>Natspec标签函数抽象化<a class="headerlink" href="#natspec" title="此标题的永久链接"></a></h4>
<p>某些函数包括常见的数学方法，如 <code class="docutils literal notranslate"><span class="pre">pow</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>，
可能它们过于复杂，无法用完全自动化的方式进行分析。
这些函数可以用Natspec标签进行注释，向SMT检查器表明这些函数应该被抽象化。
这意味着在调用此函数时，不会使用函数的主体，函数将：</p>
<ul class="simple">
<li><p>返回一个非决定性的值，如果抽象函数是 view/pure 类型的，则保持状态变量不变，
否则会将状态变量设置为非决定性的值。
可以通过注解 <code class="docutils literal notranslate"><span class="pre">//&#64;custom:smtchecker</span> <span class="pre">abstract-function-nondet</span></code> 来使用。</p></li>
<li><p>作为一个未被解释的函数。这意味着函数的语义（由主体给出）会被忽略，
这个函数的唯一属性是，给定相同的输入，它保证有相同的输出。
这一点目前正在开发中，并将通过注解 <code class="docutils literal notranslate"><span class="pre">//&#64;custom:smtchecker</span> <span class="pre">abstract-function-uf</span></code> 来使用。</p></li>
</ul>
</section>
<section id="smtchecker-engines">
<span id="id13"></span><h4>模型检查引擎<a class="headerlink" href="#smtchecker-engines" title="此标题的永久链接"></a></h4>
<p>SMT检查器模块实现了两个不同的推理引擎，一个是有界模型检查器（Bounded Model Checker， BMC），
一个是约束角条款（Constrained Horn Clauses， CHC）系统。
这两个引擎目前都在开发中，并且有不同的特点。
这两个引擎是独立的，每一个属性警告都说明它来自哪个引擎。
请注意，上面所有带有反例的例子都是由CHC这个更强大的引擎报告的。</p>
<p>默认情况下，两个引擎都会被使用，其中首先运行CHC，
每一个没有被证明的属性都被传递给BMC。
您可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-engine</span> <span class="pre">{all,bmc,chc,none}</span></code> 或
JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.engine</span> <span class="pre">{all,bmc,chc,none}</span></code> 来选择一个特定的引擎。</p>
<section id="bmc">
<h5>有界模型检查器 （BMC）<a class="headerlink" href="#bmc" title="此标题的永久链接"></a></h5>
<p>BMC引擎单独地分析函数，也就是说，它在分析每个函数时不会考虑合约在多个交易中的整体行为。
目前在这个引擎中循环也会被忽略了。
只要不是直接或间接的递归，内部函数调用是内联的。
如果可能的话，外部函数调用是内联的。
有可能受重入影响的理论在此被忽略。</p>
<p>上述特点使BMC容易报告假阳性，
但它也是轻量级的，应该能够快速找到小的局部bug。</p>
</section>
<section id="constrained-horn-clauses-chc">
<h5>受约束的角条款（Constrained Horn Clauses， CHC）<a class="headerlink" href="#constrained-horn-clauses-chc" title="此标题的永久链接"></a></h5>
<p>合约的控制流程图（CFG）被建模为一个Horn条款系统，
其中合约的生命周期由一个可以非确定性地访问每个公共/外部函数的循环表示。
这样，在分析任何函数时都会考虑到整个合约在无限制数量的事务中的行为。
这个引擎完全支持循环。
支持内部函数调用，而外部函数调用假定被调用的代码是未知的，可以做任何事情。</p>
<p>在能够证明的内容方面，CHC引擎要比BMC强大得多，但可能需要更多的计算资源。</p>
</section>
</section>
<section id="smthorn">
<h4>SMT和Horn求解器<a class="headerlink" href="#smthorn" title="此标题的永久链接"></a></h4>
<p>上面详述的两个引擎使用自动定理证明器作为其逻辑后端。
BMC使用一个SMT求解器，而CHC使用一个Horn求解器。
通常同一个工具可以同时充当这两种工具，如 <a class="reference external" href="https://github.com/Z3Prover/z3">z3</a>，
它主要是一个SMT求解器，并将 <a class="reference external" href="https://spacer.bitbucket.io/">Spacer</a>
作为一个Horn求解器使用，而 <a class="reference external" href="https://github.com/uuverifiers/eldarica">Eldarica</a>
则同时做这两种工作。</p>
<p>如果求解器可用的话，用户可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-solvers</span> <span class="pre">{all,cvc4,smtlib2,z3}</span></code>
或JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.solvers=[smtlib2,z3]</span></code> 来选择应该使用哪个求解器，
其中：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cvc4</span></code> 仅在使用 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 编译二进制文件时可用。并且只有BMC使用 <code class="docutils literal notranslate"><span class="pre">cvc4</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">smtlib2</span></code> 以 <a class="reference external" href="http://smtlib.cs.uiowa.edu/">smtlib2</a> 格式输出 SMT/Horn 查询。
这些可以和编译器的 <a class="reference external" href="https://github.com/ethereum/solc-js">回调机制</a> 一起使用，
这样就可以采用系统中的任何求解器二进制来同步返回查询的结果给编译器。
例如，这是目前使用Eldarica的唯一方法，因为它没有C++ API。
根据调用哪个求解器，BMC和CHC都可以使用此方法。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z3</span></code> 是可用的</p>
<ul>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 与它一起被编译的话。</p></li>
<li><p>如果Linux系统中安装了4.8.x版本的动态 <code class="docutils literal notranslate"><span class="pre">z3</span></code> 库（从Solidity 0.7.6开始）。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">soljson.js</span></code> （从Solidity 0.6.9开始）中静态的，也就是编译器的Javascript二进制。</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>z3 4.8.16 版本破坏了与以前版本的 ABI 兼容性，
不能与 solc &lt;=0.8.13 一起使用。
如果您正在使用 z3 &gt;=4.8.16，请使用 solc &gt;=0.8.14 的版本。</p>
</div>
<p>由于 BMC 和 CHC 都使用 <code class="docutils literal notranslate"><span class="pre">z3</span></code>，而且 <code class="docutils literal notranslate"><span class="pre">z3</span></code> 可以在更多的环境中使用，包括在浏览器中，
大多数用户几乎不需要关心这个选项。更高级的用户可能会应用这个选项，在更复杂的问题上尝试其他求解器。</p>
<p>请注意，所选择的引擎和求解器的某些组合将导致SMT检查器不做任何事情，例如选择CHC和 <code class="docutils literal notranslate"><span class="pre">cvc4</span></code>。</p>
</section>
</section>
<section id="id15">
<h3>抽象和假阳性结果<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h3>
<p>SMT检查器以一种不完整但健全的方式实现了抽象：
如果报告了一个bug，它可能是由抽象引入的假阳性（由于删除了知识或使用了非精确类型）。
如果它确定一个验证目标是安全的，那么它确实是安全的，也就是说，
不存在假阴性（除非SMT检查器中存在一个bug）。</p>
<p>如果一个目标不能被证明，您可以尝试通过使用上一节中的调整选项来帮助求解器。
如果您确定是假阳性，在代码中加入有更多信息的 <code class="docutils literal notranslate"><span class="pre">require</span></code> 语句也可能给求解器带来一些更多的帮助。</p>
<section id="id16">
<h4>SMT的编码和类型<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>SMT检查器编码试图尽可能精确，
将Solidity类型和表达式映射到它们最接近的 <a class="reference external" href="http://smtlib.cs.uiowa.edu/">SMT-LIB</a> 表示法上，
正如下表所示。</p>
<p>关于 SMT 编码内部如何工作的更多细节，请参阅论文
<a class="reference external" href="https://github.com/chriseth/solidity_isola/blob/master/main.pdf">基于 SMT 的 Solidity 智能合约验证</a>。</p>
<p>尚不支持的类型由一个256位无符号整数抽象出来，其不支持的操作被忽略。</p>
<p>关于SMT编码的内部工作方式的更多细节，请参见论文
<a class="reference external" href="https://github.com/leonardoalt/text/blob/master/solidity_isola_2018/main.pdf">基于SMT的Solidity智能合约验证</a>。</p>
</section>
<section id="id17">
<h4>函数调用<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h4>
<p>在BMC引擎中，当可能时，即当它们的实现可用时，对相同合约（或基础合约）的函数调用被内联。
对其他合约中的函数的调用不被内联，即使它们的代码是可用的，因为我们不能保证实际部署的代码是相同的。</p>
<p>CHC引擎创建了非线性的Horn选项，使用被调用函数的摘要来支持内部函数调用。
外部函数调用被视为对未知代码的调用，包括潜在的可重入调用。</p>
<p>复杂的纯函数是由参数上的未转译函数（UF）抽象出来的。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法</p></th>
<th class="head"><p>BMC/CHC 运行方式</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assert</span></code></p></td>
<td><p>验证目标。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">require</span></code></p></td>
<td><p>假设。</p></td>
</tr>
<tr class="row-even"><td><p>内部调用</p></td>
<td><p>BMC: 内联函数调用。
CHC：函数摘要。</p></td>
</tr>
<tr class="row-odd"><td><p>对已知代码的外部调用</p></td>
<td><p>BMC: 内联函数调用或
抹去关于状态变量的记忆
和本地存储引用。
CHC: 假设被调用的代码是未知的。
试图推断出在调用返回后仍然成立的不变性。</p></td>
</tr>
<tr class="row-even"><td><p>存储数组的压栈和出栈</p></td>
<td><p>精确地支持
检查是否从一个空数组弹出。</p></td>
</tr>
<tr class="row-odd"><td><p>ABI 函数</p></td>
<td><p>用UF函数进行抽象</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">addmod</span></code>, <code class="docutils literal notranslate"><span class="pre">mulmod</span></code></p></td>
<td><p>精确地支持</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gasleft</span></code>, <code class="docutils literal notranslate"><span class="pre">blockhash</span></code>,
<code class="docutils literal notranslate"><span class="pre">keccak256</span></code>, <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>
<code class="docutils literal notranslate"><span class="pre">ripemd160</span></code></p></td>
<td><p>用UF函数进行抽象</p></td>
</tr>
<tr class="row-even"><td><p>无执行动作的纯函数（外部或复杂）。</p></td>
<td><p>用UF函数进行抽象</p></td>
</tr>
<tr class="row-odd"><td><p>无执行动作的外部函数</p></td>
<td><p>BMC：擦除状态记忆并假定结果是不确定的。
CHC：不确定的摘要。
试图推断出在调用返回后仍然成立的不变性。</p></td>
</tr>
<tr class="row-even"><td><p>transfer</p></td>
<td><p>BMC：检查合约的余额是否足够。
CHC：还不执行检查。</p></td>
</tr>
<tr class="row-odd"><td><p>其他调用</p></td>
<td><p>目前不支持</p></td>
</tr>
</tbody>
</table>
<p>使用抽象意味着失去精确的知识，但在许多情况下，这并不意味着失去证明力。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSZWNvdmVyCnsKICAgIGZ1bmN0aW9uIGYoCiAgICAgICAgYnl0ZXMzMiBoYXNoLAogICAgICAgIHVpbnQ4IHYxLCB1aW50OCB2MiwKICAgICAgICBieXRlczMyIHIxLCBieXRlczMyIHIyLAogICAgICAgIGJ5dGVzMzIgczEsIGJ5dGVzMzIgczIKICAgICkgcHVibGljIHB1cmUgcmV0dXJucyAoYWRkcmVzcykgewogICAgICAgIGFkZHJlc3MgYTEgPSBlY3JlY292ZXIoaGFzaCwgdjEsIHIxLCBzMSk7CiAgICAgICAgcmVxdWlyZSh2MSA9PSB2Mik7CiAgICAgICAgcmVxdWlyZShyMSA9PSByMik7CiAgICAgICAgcmVxdWlyZShzMSA9PSBzMik7CiAgICAgICAgYWRkcmVzcyBhMiA9IGVjcmVjb3ZlcihoYXNoLCB2MiwgcjIsIHMyKTsKICAgICAgICBhc3NlcnQoYTEgPT0gYTIpOwogICAgICAgIHJldHVybiBhMTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Recover</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">hash</span><span class="p">,</span>
<span class="w">        </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">r1</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">r2</span><span class="p">,</span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">s2</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ecrecover<span class="p">(</span><span class="kt">hash</span><span class="p">,</span><span class="w"> </span>v1<span class="p">,</span><span class="w"> </span>r1<span class="p">,</span><span class="w"> </span>s1<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>v1<span class="w"> </span><span class="o">==</span><span class="w"> </span>v2<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>r1<span class="w"> </span><span class="o">==</span><span class="w"> </span>r2<span class="p">);</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>s1<span class="w"> </span><span class="o">==</span><span class="w"> </span>s2<span class="p">);</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ecrecover<span class="p">(</span><span class="kt">hash</span><span class="p">,</span><span class="w"> </span>v2<span class="p">,</span><span class="w"> </span>r2<span class="p">,</span><span class="w"> </span>s2<span class="p">);</span>
<span class="w">        </span>assert<span class="p">(</span>a1<span class="w"> </span><span class="o">==</span><span class="w"> </span>a2<span class="p">);</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a1<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在上面的例子中，SMT检查器的表达能力不足以实际计算 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>，
但通过将函数调用建模为未转译的函数，我们知道在同等参数上调用时返回值是相同的。
这就足以证明上面的断言总是正确的。</p>
<p>对于已知是确定性的函数，可以用UF来抽象一个函数调用，
对于纯函数也很容易做到。
然而，对于一般的外部函数来说，这是很难做到的，
因为它们可能依赖于状态变量。</p>
</section>
<section id="id18">
<h4>引用类型和别名<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h4>
<p>Solidity 为具有相同 <a class="reference internal" href="index.html#data-location"><span class="std std-ref">数据位置</span></a> 的引用类型实现了别名。
这意味着可以通过对同一数据区域的引用来修改一个变量。
SMT检查器并不跟踪哪些引用是指向相同的数据。
这意味着每当分配一个局部引用或引用类型的状态变量时，
所有关于相同类型和数据位置的变量的知识都会被抹去。
如果类型是嵌套的，知识删除也包括所有的前缀基础类型。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBbGlhc2luZwp7CiAgICB1aW50W10gYXJyYXkxOwogICAgdWludFtdW10gYXJyYXkyOwogICAgZnVuY3Rpb24gZigKICAgICAgICB1aW50W10gbWVtb3J5IGEsCiAgICAgICAgdWludFtdIG1lbW9yeSBiLAogICAgICAgIHVpbnRbXVtdIG1lbW9yeSBjLAogICAgICAgIHVpbnRbXSBzdG9yYWdlIGQKICAgICkgaW50ZXJuYWwgewogICAgICAgIGFycmF5MVswXSA9IDQyOwogICAgICAgIGFbMF0gPSAyOwogICAgICAgIGNbMF1bMF0gPSAyOwogICAgICAgIGJbMF0gPSAxOwogICAgICAgIC8vIOWIoOmZpOWFs+S6juWGheWtmOW8leeUqOeahOiusOW/huS4jeW6lOivpeWIoOmZpOWFs+S6jueKtuaAgeWPmOmHj+eahOiusOW/huOAggogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIOS9huaYr++8jOWvueWtmOWCqOW8leeUqOeahOi1i+WAvOWwhuebuOW6lOWcsOWIoOmZpOWtmOWCqOiusOW/huOAggogICAgICAgIGRbMF0gPSAyOwogICAgICAgIC8vIOeUseS6juS4iumdoueahOWIhumFje+8jOWksei0peS4uuWBh+mYs+aAp+OAggogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIOWksei0pe+8jOWboOS4uiBgYSA9PSBiYCDmmK/lj6/og73nmoTjgIIKICAgICAgICBhc3NlcnQoYVswXSA9PSAyKTsKICAgICAgICAvLyDlpLHotKXvvIzlm6DkuLogYGNbaV0gPT0gYmAg5piv5Y+v6IO955qE44CCCiAgICAgICAgYXNzZXJ0KGNbMF1bMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGRbMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGJbMF0gPT0gMSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKAogICAgICAgIHVpbnRbXSBtZW1vcnkgYSwKICAgICAgICB1aW50W10gbWVtb3J5IGIsCiAgICAgICAgdWludFtdW10gbWVtb3J5IGMsCiAgICAgICAgdWludCB4CiAgICApIHB1YmxpYyB7CiAgICAgICAgZihhLCBiLCBjLCBhcnJheTJbeF0pOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Aliasing</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>array1<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span>array2<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>b<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>c<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>d
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>array1<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span>
<span class="w">        </span>a<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="w">        </span>c<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="w">        </span>b<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 删除关于内存引用的记忆不应该删除关于状态变量的记忆。</span>
<span class="w">        </span>assert<span class="p">(</span>array1<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 但是，对存储引用的赋值将相应地删除存储记忆。</span>
<span class="w">        </span>d<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 由于上面的分配，失败为假阳性。</span>
<span class="w">        </span>assert<span class="p">(</span>array1<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 失败，因为 `a == b` 是可能的。</span>
<span class="w">        </span>assert<span class="p">(</span>a<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 失败，因为 `c[i] == b` 是可能的。</span>
<span class="w">        </span>assert<span class="p">(</span>c<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">        </span>assert<span class="p">(</span>d<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span>
<span class="w">        </span>assert<span class="p">(</span>b<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>b<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>c<span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>f<span class="p">(</span>a<span class="p">,</span><span class="w"> </span>b<span class="p">,</span><span class="w"> </span>c<span class="p">,</span><span class="w"> </span>array2<span class="p">[</span>x<span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在对 <code class="docutils literal notranslate"><span class="pre">b[0]</span></code> 进行赋值后，我们需要清除关于 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的知识，
因为它有相同的类型（ <code class="docutils literal notranslate"><span class="pre">uint[]</span></code> ）和数据位置（内存）。
我们还需要清除关于 <code class="docutils literal notranslate"><span class="pre">c</span></code> 的知识，因为它的基本类型也是一个位于内存中的 <code class="docutils literal notranslate"><span class="pre">uint[]</span></code>。
这意味着一些 <code class="docutils literal notranslate"><span class="pre">c[i]</span></code> 可能与 <code class="docutils literal notranslate"><span class="pre">b</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a</span></code> 指的是同一个数据。</p>
<p>注意，我们没有清除关于 <code class="docutils literal notranslate"><span class="pre">array</span></code> 和 <code class="docutils literal notranslate"><span class="pre">d</span></code> 的知识，
因为它们位于存储区，尽管它们也有 <code class="docutils literal notranslate"><span class="pre">uint[]</span></code> 类型。
然而，如果 <code class="docutils literal notranslate"><span class="pre">d</span></code> 被分配，我们就需要清除关于 <code class="docutils literal notranslate"><span class="pre">array</span></code> 的知识，反之亦然。</p>
</section>
<section id="id19">
<h4>合约余额<a class="headerlink" href="#id19" title="此标题的永久链接"></a></h4>
<p>如果在部署交易中 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> &gt; 0，则合约可能在部署时被发送资金。
然而，合约的地址在部署前可能已经有了资金，
这些资金由合约保存。
因此，SMT检查器在构造函数中假定 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span> <span class="pre">&gt;=</span> <span class="pre">msg.value</span></code>，
以便与EVM规则一致。合约的余额也可能在不触发任何对合约的调用的情况下增加，如果</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 是由另一个合约执行的，被分析的合约是剩余资金的接收目标。</p></li>
<li><p>该合约是某个区块的coinbase（即 <code class="docutils literal notranslate"><span class="pre">block.coinbase</span></code>）。</p></li>
</ul>
<p>为了正确建模，SMT检查器假设在每一笔新的交易中，合约的余额可能至少增长 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 的值。</p>
</section>
</section>
<section id="id20">
<h3>现实世界的假设<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h3>
<p>有些情况可以在Solidity和EVM中可以表达出，但可能在实践中不会发生。
其中一种情况是动态存储数组的长度在压栈过程中溢出：
如果 <code class="docutils literal notranslate"><span class="pre">push</span></code> 操作被应用于一个长度为 2^256 - 1的数组，它的长度会悄悄溢出。
然而，这在实践中不太可能发生，因为将数组增长到这一点所需的操作需要数十亿年的时间来执行。
SMT检查器采取的另一个类似的假设是，一个地址的余额永远不会溢出。</p>
<p>类似的想法在 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-1985">EIP-1985</a> 中提出过。</p>
</section>
</section>
<span id="document-resources"></span><section id="id1">
<h2>资源<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<section id="id2">
<h3>一般资源<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://ethereum.org/en/developers/">Ethereum.org开发者门户网站</a></p></li>
<li><p><a class="reference external" href="https://ethereum.stackexchange.com/">Ethereum StackExchange</a></p></li>
<li><p><a class="reference external" href="https://soliditylang.org/">Solidity门户网站</a></p></li>
<li><p><a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/Changelog.md">Solidity变更日志</a></p></li>
<li><p><a class="reference external" href="https://github.com/ethereum/solidity/">GitHub上的Solidity源代码</a></p></li>
<li><p><a class="reference external" href="index.html#ethereum_solidity:gitter.im">Solidity语言用户聊天室</a></p></li>
<li><p><a class="reference external" href="index.html#ethereum_solidity-dev:gitter.im">Solidity编译器开发人员聊天室</a></p></li>
<li><p><a class="reference external" href="https://github.com/bkrem/awesome-solidity">很棒的Solidity</a></p></li>
<li><p><a class="reference external" href="https://solidity-by-example.org/">通过实例学Solidity</a></p></li>
<li><p><a class="reference external" href="https://github.com/solidity-docs">Solidity文档社区翻译</a></p></li>
</ul>
</section>
<section id="id9">
<h3>集成（以太坊）开发环境<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h3>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://eth-brownie.readthedocs.io/en/stable/">Brownie</a></dt><dd><p>面向以太坊虚拟机的基于Python的智能合约开发和测试框架。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://dapp.tools/">Dapp</a></dt><dd><p>用于从命令行构建，测试和部署智能合约的工具。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://framework.embarklabs.io/">Embark</a></dt><dd><p>构建和部署去中心化应用程序的开发者平台。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/gakonst/foundry">Foundry</a></dt><dd><p>用Rust编写的用于Ethereum应用开发的快速，可移植和模块化的工具包。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://hardhat.org/">Hardhat</a></dt><dd><p>以太坊开发环境具有本地以太坊网络，调试功能和插件生态系统。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://remix.ethereum.org/">Remix</a></dt><dd><p>基于浏览器的IDE，具有集成的编译器和Solidity运行环境，没有服务器端组件。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://www.trufflesuite.com/truffle">Truffle</a></dt><dd><p>以太坊开发框架。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</section>
<section id="id10">
<h3>编辑器集成<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<ul>
<li><p>Atom</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/0mkara/etheratom">Etheratom</a></dt><dd><p>Atom编辑器的插件，具有语法高亮、编译和运行环境（兼容后端节点和虚拟机）的功能。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://atom.io/packages/linter-solidity">Atom Solidity 语法检查器</a></dt><dd><p>为Atom编辑器提供Solidity语法检查的插件。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://atom.io/packages/linter-solium">Atom Solium 语法检查器</a></dt><dd><p>以Solium（现在的Ethlint）为基础，为Atom提供可配置的Solidity语法检查器。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Emacs</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/ethereum/emacs-solidity/">Emacs Solidity</a></dt><dd><p>Emacs编辑器的插件，提供语法高亮和编译错误报告。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>IntelliJ</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://plugins.jetbrains.com/plugin/9475-intellij-solidity">IntelliJ IDEA 插件</a></dt><dd><p>IntelliJ IDEA（和所有其他JetBrains IDEs）的Solidity插件</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Sublime</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://packagecontrol.io/packages/Ethereum/">SublimeText的软件包 - Solidity语言语法</a></dt><dd><p>用于 SublimeText 编辑器的 Solidity 语法高亮。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Vim</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/tomlion/vim-solidity/">Vim Solidity</a></dt><dd><p>为Vim编辑器提供语法高亮的插件。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/vim-syntastic/syntastic">Vim Syntastic</a></dt><dd><p>为Vim编辑器提供编译检查的插件。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Visual Studio Code</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://juan.blanco.ws/solidity-contracts-in-visual-studio-code/">Visual Studio Code 扩展</a></dt><dd><p>Microsoft Visual Studio Code的Solidity插件，包括语法高亮和Solidity编译器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor">Solidity Visual Auditor 扩展</a></dt><dd><p>在Visual Studio Code中增加了以安全为中心的语法和语义突出显示。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="id11">
<h3>Solidity 工具<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://gist.github.com/chriseth/8f533d133fa0c15b0d6eaf3ec502c82b">ABI到Solidity接口转换器</a></dt><dd><p>一个用于从智能合约的ABI生成合约接口的脚本。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/gnidan/abi-to-sol">abi-to-sol</a></dt><dd><p>从一个给定的ABI JSON生成Solidity接口源的工具。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/DigixGlobal/doxity">Doxity</a></dt><dd><p>Solidity的文档生成器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/duaraghav8/Ethlint">Ethlint</a></dt><dd><p>识别和修复Solidity中的风格和安全问题的语法检查器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/Arachnid/evmdis">evmdis</a></dt><dd><p>EVM反汇编程序，对字节码进行静态分析，提供比原始EVM操作更高的抽象水平。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/ethereum/evmlab/">EVM Lab</a></dt><dd><p>丰富的工具包，与EVM互动。包括一个虚拟机、以太链API，以及一个带有gas成本显示的跟踪查看器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/dapphub/dapptools/tree/master/src/hevm#readme">hevm</a></dt><dd><p>EVM调试器和符号执行引擎。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/clemlak/leafleth">leafleth</a></dt><dd><p>Solidity智能合约的文档生成器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://piet.slock.it/">PIET</a></dt><dd><p>一个通过简单图形界面开发，审计和使用Solidity智能合约的工具。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/scaffold-eth/scaffold-eth">Scaffold-ETH</a></dt><dd><p>专注于产品快速迭代的可分叉的以太坊开发堆栈。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://www.npmjs.com/package/sol2uml">sol2uml</a></dt><dd><p>Solidity合约的统一建模语言（UML）类图生成器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/crytic/solc-select">solc-select</a></dt><dd><p>一个在 Solidity 编译器版本之间快速切换的脚本。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/prettier-solidity/prettier-plugin-solidity">优化Solidity语言格式插件</a></dt><dd><p>Solidity格式美化插件。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/raineorshine/solidity-repl">Solidity REPL</a></dt><dd><p>使用命令行solidity控制台立即尝试solidity。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/raineorshine/solgraph">solgraph</a></dt><dd><p>可视化Solidity控制流并突出潜在的安全漏洞。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/protofire/solhint">Solhint</a></dt><dd><p>Solidity语法检查器，为智能合约的验证提供安全，风格指南和最佳实践规则。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://sourcify.dev/">Sourcify</a></dt><dd><p>去中心化的自动合约验证服务和合约元数据的公共存储库。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/ConsenSys/surya/">Sūrya</a></dt><dd><p>智能合约系统的实用工具，提供一些可视化输出和关于合约结构的信息。还支持查询函数调用图。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/agroce/universalmutator">Universal Mutator</a></dt><dd><p>一个用于突变生成的工具，具有可配置的规则并支持Solidity和Vyper。</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="id13">
<h3>第三方Solidity解析器和语法<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://github.com/solidity-parser/parser">用于JavaScript的Solidity解析器</a></dt><dd><p>一个建立在强大的ANTLR4语法之上的JS Solidity解析器。</p>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<span id="document-path-resolution"></span><section id="path-resolution">
<span id="id1"></span><h2>导入路径解析<a class="headerlink" href="#path-resolution" title="此标题的永久链接"></a></h2>
<p>为了能够在所有平台上支持可重复的构建，Solidity 编译器必须抽象出存储源文件的文件系统的细节。
在导入中使用的路径必须在任何地方以同样的方式工作，而命令行界面必须能够与平台特定的路径一起工作，
以提供良好的用户体验。
本节旨在详细解释 Solidity 是如何协调这些要求的。</p>
<section id="virtual-filesystem">
<span id="index-0"></span><span id="id2"></span><h3>虚拟文件系统<a class="headerlink" href="#virtual-filesystem" title="此标题的永久链接"></a></h3>
<p>编译器维护一个内部数据库（ <em>虚拟文件系统</em> 或简称 <em>VFS</em> ），
每个源单元被分配一个唯一的 <em>源单元名称</em>，这是一个不透明的非结构化的标识符。
当您使用 <a class="reference internal" href="index.html#import"><span class="std std-ref">import 语句</span></a> 时，
您指定了引用源单元名称的 <em>导入路径</em>。</p>
<section id="import-callback">
<span id="index-1"></span><span id="id3"></span><h4>导入回调<a class="headerlink" href="#import-callback" title="此标题的永久链接"></a></h4>
<p>VFS最初只填充了编译器收到的输入文件。
在编译过程中可以使用 <em>import 回调</em> 加载其他文件，
但这取决于您使用的编译器的类型（见下文）。
如果编译器在VFS中没有找到任何与导入路径相匹配的源单元名称，
它就会调用回调，负责获取要放在该名称下的源代码。
一个导入回调可以自由地以任意方式解释源单元名称，而不仅仅是作为路径。
如果在需要回调时没有可用的回调，或者无法找到源代码，编译就会失败。</p>
<p>命令行编译器提供了 <em>主机文件系统加载器</em> -- 一个基本的回调，
它将源单元名称解释为本地文件系统中的一个路径。
<a class="reference external" href="https://github.com/ethereum/solc-js">JavaScript接口</a> 默认不提供任何接口，
但可以由用户提供一个。
这个机制可以用来从本地文件系统以外的地方获得源代码
（本地文件系统甚至可能无法访问，例如当编译器在浏览器中运行时）。
例如， <a class="reference external" href="https://remix.ethereum.org/">Remix IDE</a> 提供了一个多功能的回调，
让您 <a class="reference external" href="https://remix-ide.readthedocs.io/en/latest/import.html">从HTTP、IPFS和Swarm URL导入文件，或直接引用NPM注册表中的包</a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>主机文件系统加载器的文件查找是依赖于平台的。
例如，源单元名称中的反斜线可以被解释为目录分隔符，也可以不被解释为目录分隔符，
查找时可以区分大小写，这取决于底层平台。</p>
<p>为了实现可移植性，我们建议避免使用只有在特定的导入回调中才能正常工作的导入路径，
或者只在一个平台上使用。
例如，您应该总是使用正斜线，因为它们在支持反斜线的平台上也能作为路径分隔符使用。</p>
</div>
</section>
<section id="id4">
<h4>虚拟文件系统的初始内容<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p>VFS的初始内容取决于您如何调用编译器：</p>
<ol class="arabic">
<li><p><strong>solc / 命令行界面</strong></p>
<p>当您使用编译器的命令行界面编译一个文件时，您提供一个或多个包含Solidity代码的文件的路径：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>contract.sol<span class="w"> </span>/usr/local/dapp-bin/token.sol
</pre></div>
</div>
<p>以这种方式加载的文件的源单元名称是通过将其路径转换为规范的形式来构建的，
如果可能的话，使其与基本路径或其中一个包含路径相对。
参见 <a class="reference internal" href="#cli-path-normalization-and-stripping"><span class="std std-ref">CLI路径规范化和剥离</span></a> 以了解这一过程的详细描述。</p>
</li>
<li id="index-2"><p><strong>标准JSON</strong></p>
<p>当使用 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准JSON</span></a> API时
通过 <a class="reference external" href="https://github.com/ethereum/solc-js">JavaScript接口</a> 或
<cite>--standard-json</cite> 命令行选项），您需提供JSON格式的输入，其中包含您所有源文件的内容。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;language&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Solidity&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;sources&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;contract.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;import \&quot;./util.sol\&quot;;\ncontract C {}&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;util.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;library Util {}&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;/usr/local/dapp-bin/token.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;contract Token {}&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;settings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;outputSelection&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;evm.bytecode&quot;</span><span class="p">]}}}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的 <code class="docutils literal notranslate"><span class="pre">sources</span></code> 字典结构成为虚拟文件系统的初始内容，它的键被用作源单元名称。</p>
</li>
<li id="initial-vfs-content-standard-json-with-import-callback"><p><strong>标准JSON（通过导入回调）</strong></p>
<p>通过标准JSON，也可以告诉编译器使用导入回调来获得源代码：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;language&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Solidity&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;sources&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;/usr/local/dapp-bin/token.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;urls&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">                </span><span class="s2">&quot;/projects/mytoken.sol&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s2">&quot;https://example.com/projects/mytoken.sol&quot;</span>
<span class="w">            </span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;settings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;outputSelection&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;evm.bytecode&quot;</span><span class="p">]}}}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果导入回调是可用的，编译器将一个一个地给它 <code class="docutils literal notranslate"><span class="pre">urls</span></code> 中指定的字符串，直到有一个被成功加载或到达列表的末尾。</p>
<p>源单元名称的确定方式与使用 <code class="docutils literal notranslate"><span class="pre">content</span></code> 时相同 - 它们是 <code class="docutils literal notranslate"><span class="pre">sources</span></code> 字典结构的键，
<code class="docutils literal notranslate"><span class="pre">urls</span></code> 的内容不会以任何方式影响它们。</p>
</li>
<li id="index-3"><p><strong>标准输入</strong></p>
<p>在命令行中，也可以通过将源代码发送到编译器的标准输入来提供源代码:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;import &quot;./util.sol&quot;; contract C {}&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>solc<span class="w"> </span>-
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-</span></code> 作为参数之一，指示编译器将标准输入的内容放在虚拟文件系统中的一个特殊的源单元名下： <code class="docutils literal notranslate"><span class="pre">&lt;stdin&gt;</span></code>。</p>
</li>
</ol>
<p>初始化VFS之后，仍然可以向它添加其他文件，但只能通过导入回调的方式。</p>
</section>
</section>
<section id="index-4">
<span id="id6"></span><h3>导入<a class="headerlink" href="#index-4" title="此标题的永久链接"></a></h3>
<p>导入语句指定了一个 <em>导入路径</em>。
根据导入路径的指定方式，我们可以将导入分为两类：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#direct-imports"><span class="std std-ref">直接导入</span></a>，直接指定完整的源单元名称。</p></li>
<li><p><a class="reference internal" href="#relative-imports"><span class="std std-ref">相对导入</span></a>，指定一个以 <code class="docutils literal notranslate"><span class="pre">./</span></code> 或 <code class="docutils literal notranslate"><span class="pre">../</span></code> 开头的路径，
与导入文件的源单元名称相结合。</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">contracts/contract.sol</span><a class="headerlink" href="#id13" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIuL21hdGgvbWF0aC5zb2wiOwppbXBvcnQgImNvbnRyYWN0cy90b2tlbnMvdG9rZW4uc29sIjs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./math/math.sol&quot;</span><span class="p">;</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;contracts/tokens/token.sol&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>在上面的 <code class="docutils literal notranslate"><span class="pre">./math/math.sol</span></code> 和 <code class="docutils literal notranslate"><span class="pre">contracts/tokens/token.sol</span></code> 都是导入路径，
然而它们转译成的源单元名分别是 <code class="docutils literal notranslate"><span class="pre">contracts/math/math.sol</span></code> 和 <code class="docutils literal notranslate"><span class="pre">contracts/tokens/token.sol</span></code>。</p>
<section id="direct-imports">
<span id="index-5"></span><span id="id7"></span><h4>直接导入<a class="headerlink" href="#direct-imports" title="此标题的永久链接"></a></h4>
<p>不以 <code class="docutils literal notranslate"><span class="pre">./</span></code> 或 <code class="docutils literal notranslate"><span class="pre">../</span></code> 开头的导入是 <em>直接导入</em>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIvcHJvamVjdC9saWIvdXRpbC5zb2wiOyAgICAgICAgIC8vIOa6kOWNleWFg+WQjeensO+8miAvcHJvamVjdC9saWIvdXRpbC5zb2wKaW1wb3J0ICJsaWIvdXRpbC5zb2wiOyAgICAgICAgICAgICAgICAgIC8vIOa6kOWNleWFg+WQjeensO+8miBsaWIvdXRpbC5zb2wKaW1wb3J0ICJAb3BlbnplcHBlbGluL2FkZHJlc3Muc29sIjsgICAgIC8vIOa6kOWNleWFg+WQjeensO+8miBAb3BlbnplcHBlbGluL2FkZHJlc3Muc29sCmltcG9ydCAiaHR0cHM6Ly9leGFtcGxlLmNvbS90b2tlbi5zb2wiOyAvLyDmupDljZXlhYPlkI3np7DvvJogaHR0cHM6Ly9leGFtcGxlLmNvbS90b2tlbi5zb2w="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;/project/lib/util.sol&quot;</span><span class="p">;</span><span class="w">         </span><span class="c1">// 源单元名称： /project/lib/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;lib/util.sol&quot;</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 源单元名称： lib/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;@openzeppelin/address.sol&quot;</span><span class="p">;</span><span class="w">     </span><span class="c1">// 源单元名称： @openzeppelin/address.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;https://example.com/token.sol&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： https://example.com/token.sol</span>
</pre></div>
</div>
<p>在应用任何 <a class="reference internal" href="#import-remapping"><span class="std std-ref">导入重映射</span></a> 之后，导入路径简单地成为源单元名称。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>一个源单元的名字只是一个标识符，即使它的值碰巧看起来像一个路径，
它也不受您在shell中通常期望的规范化规则的约束。
任何 <code class="docutils literal notranslate"><span class="pre">/./</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/../</span></code> 的分隔符或多个斜线的序列都是它的一部分。
当源是通过标准JSON接口提供的时候，完全有可能将不同的内容与源单元的名称联系起来，
这些名称将指代磁盘上的同一个文件。</p>
</div>
<p>当源文件在虚拟文件系统中不可用时，编译器会将源单元名称传递给导入回调。
主机文件系统加载器将尝试使用它作为路径并在磁盘上查找文件。
在这一点上，平台特定的规范化规则开始发挥作用，在VFS中被认为是不同的名字实际上可能导致同一个文件被加载。
例如， <code class="docutils literal notranslate"><span class="pre">/project/lib/math.sol</span></code> 和 <code class="docutils literal notranslate"><span class="pre">/project/lib/../lib///math.sol</span></code>
在VFS中被认为是完全不同的，但它们在磁盘上指向的是同一个文件。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>即使一个导入回调最终从磁盘上的同一个文件中加载了两个不同的源单元名称的源代码，
编译器仍然会将它们视为独立的源单元。
重要的是源单元名称，而不是代码的物理位置。</p>
</div>
</section>
<section id="relative-imports">
<span id="index-6"></span><span id="id8"></span><h4>相对导入<a class="headerlink" href="#relative-imports" title="此标题的永久链接"></a></h4>
<p>以 <code class="docutils literal notranslate"><span class="pre">./</span></code> 或 <code class="docutils literal notranslate"><span class="pre">./</span></code> 开头的导入是一个 <em>相对导入</em>。
这种导入指定了一个相对于导入源单元的源单元名称的路径。</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">/project/lib/math.sol</span><a class="headerlink" href="#id14" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAgICAvLyDmupDljZXlhYPlkI3np7DvvJogL3Byb2plY3QvbGliL3V0aWwuc29sCmltcG9ydCAiLi4vdG9rZW4uc29sIiBhcyB0b2tlbjsgLy8g5rqQ5Y2V5YWD5ZCN56ew77yaIC9wcm9qZWN0L3Rva2VuLnNvbA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./util.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>util<span class="p">;</span><span class="w">    </span><span class="c1">// 源单元名称： /project/lib/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;../token.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>token<span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： /project/token.sol</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">lib/math.sol</span><a class="headerlink" href="#id15" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAgICAvLyDmupDljZXlhYPlkI3np7DvvJogbGliL3V0aWwuc29sCmltcG9ydCAiLi4vdG9rZW4uc29sIiBhcyB0b2tlbjsgLy8g5rqQ5Y2V5YWD5ZCN56ew77yaIHRva2VuLnNvbA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./util.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>util<span class="p">;</span><span class="w">    </span><span class="c1">// 源单元名称： lib/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;../token.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>token<span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： token.sol</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>相对导入 <strong>总是</strong> 以 <code class="docutils literal notranslate"><span class="pre">./</span></code> 或 <code class="docutils literal notranslate"><span class="pre">./</span></code> 开始，
所以与 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&quot;./util.sol&quot;</span></code> 不同， <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&quot;util.sol&quot;</span></code> 是一个直接导入。
虽然这两个路径在主机文件系统中被认为是相对的，但 <code class="docutils literal notranslate"><span class="pre">util.sol</span></code> 在VFS中实际上是绝对的。</p>
</div>
<p>让我们把 <em>路径段</em> 定义为路径中不包含分隔符的任何非空部分，并以两个路径分隔符为界。
分隔符是一个正斜杠或字符串的开头/结尾。
例如，在 <code class="docutils literal notranslate"><span class="pre">./abc/...//</span></code> 中，有三个路径段。 <code class="docutils literal notranslate"><span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">abc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">..</span></code>。</p>
<p>编译器以下列方式从导入路径中计算出一个源单元的名称：</p>
<ol class="arabic simple">
<li><p>首先计算出一个前缀</p>
<ul class="simple">
<li><p>前缀被初始化为导入源单元的源单元名称。</p></li>
<li><p>最后一个带有斜线的路径段被从前缀中删除。</p></li>
<li><p>然后，考虑规范化导入路径的前导部分，仅由 <code class="docutils literal notranslate"><span class="pre">/</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.</span></code> 字符组成。
对于在这部分发现的每一个 <code class="docutils literal notranslate"><span class="pre">..</span></code> 段，最后一个带斜杠的路径段将从前缀中删除。</p></li>
</ul>
</li>
<li><p>然后，前缀被预置到规范化的导入路径中。
如果前缀不为空，则在它和导入路径之间插入一个单斜线。</p></li>
</ol>
<p>删除前面有斜线的最后一个路径段，可以理解为工作原理如下：</p>
<ol class="arabic simple">
<li><p>超过最后一个斜线的所有内容都被删除（即 <code class="docutils literal notranslate"><span class="pre">a/b//c.sol</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">a/b//</span></code>）。</p></li>
<li><p>所有的尾部斜线被删除（即 <code class="docutils literal notranslate"><span class="pre">a/b//</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">a/b</span></code>）。</p></li>
</ol>
<p>归一化规则与UNIX路径相同，即：</p>
<ul class="simple">
<li><p>所有内部的 <code class="docutils literal notranslate"><span class="pre">.</span></code> 段被删除。</p></li>
<li><p>每一个内部的 <code class="docutils literal notranslate"><span class="pre">..</span></code> 段都在层次结构中往上追溯一级。</p></li>
<li><p>多条斜线被压成一条。</p></li>
</ul>
<p>注意，规范化只在导入路径上执行。
用于前缀的导入模块的源单元名称仍未被规范化。
这确保了在导入文件被识别为URL时， <code class="docutils literal notranslate"><span class="pre">protocol://</span></code> 部分不会变成 <code class="docutils literal notranslate"><span class="pre">protocol:/</span></code>。</p>
<p>如果导入路径已经规范化，则可以期望上述算法产生非常直观的结果。
下面是一些例子，告诉您如果不是的话会发生什么：</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">lib/src/../contract.sol</span><a class="headerlink" href="#id16" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIuL3V0aWwvLi91dGlsLnNvbCI7ICAgICAgICAgLy8g5rqQ5Y2V5YWD5ZCN56ew77yaIGxpYi9zcmMvLi4vdXRpbC91dGlsLnNvbAppbXBvcnQgIi4vdXRpbC8vdXRpbC5zb2wiOyAgICAgICAgICAvLyDmupDljZXlhYPlkI3np7DvvJogbGliL3NyYy8uLi91dGlsL3V0aWwuc29sCmltcG9ydCAiLi4vdXRpbC8uLi9hcnJheS91dGlsLnNvbCI7IC8vIOa6kOWNleWFg+WQjeensO+8miBsaWIvc3JjL2FycmF5L3V0aWwuc29sCmltcG9ydCAiLi4vLi4vLi8uLi91dGlsLnNvbCI7ICAgICAgIC8vIOa6kOWNleWFg+WQjeensO+8miB1dGlsLnNvbAppbXBvcnQgIi4uLy4uLy4uLy4vLi4vdXRpbC5zb2wiOyAgICAvLyDmupDljZXlhYPlkI3np7DvvJogdXRpbC5zb2w="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./util/./util.sol&quot;</span><span class="p">;</span><span class="w">         </span><span class="c1">// 源单元名称： lib/src/../util/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./util//util.sol&quot;</span><span class="p">;</span><span class="w">          </span><span class="c1">// 源单元名称： lib/src/../util/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;../util/../array/util.sol&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： lib/src/array/util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;../.././../util.sol&quot;</span><span class="p">;</span><span class="w">       </span><span class="c1">// 源单元名称： util.sol</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;../../.././../util.sol&quot;</span><span class="p">;</span><span class="w">    </span><span class="c1">// 源单元名称： util.sol</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>不建议使用使用包含前缀 <code class="docutils literal notranslate"><span class="pre">..</span></code> 的路径段。
通过使用带有 <a class="reference internal" href="#base-and-include-paths"><span class="std std-ref">基本路径和包含路径</span></a> 的直接导入，
可以以更可靠的方式实现同样的效果。</p>
</div>
</section>
</section>
<section id="base-and-include-paths">
<span id="index-7"></span><span id="id9"></span><h3>基本路径和包含路径<a class="headerlink" href="#base-and-include-paths" title="此标题的永久链接"></a></h3>
<p>基本路径和包含路径表示主机文件系统加载器将加载文件的目录。
当一个源单元的名字被传递给加载器时，它把基本路径加到它的前面，并执行一个文件系统查找。
如果查找不成功，也会对包含路径列表中的所有目录进行同样的处理。</p>
<p>建议将基本路径设置为您项目的根目录，并使用包含路径来指定可能包含您项目所依赖的库的其他位置。
这可以让您以统一的方式从这些库中导入，无论它们在文件系统中相对于您的项目位于何处。
例如，如果您使用npm安装包，而您的合约导入了 <code class="docutils literal notranslate"><span class="pre">&#64;openzeppelin/contracts/utils/Strings.sol</span></code>，
您可以使用这些选项来告诉编译器，该库可以在npm包目录中找到。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>contract.sol<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--base-path<span class="w"> </span>.<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--include-path<span class="w"> </span>node_modules/<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--include-path<span class="w"> </span>/usr/local/lib/node_modules/
</pre></div>
</div>
<p>无论您是把库安装在本地还是全局包目录下，甚至直接安装在您的项目根目录下，
您的合约都会被编译（具有完全相同的元数据）。</p>
<p>默认情况下，基本路径是空的，这使得源单元的名称没有变化。
当源单元名称是一个相对路径时，这将导致文件在编译器被调用的目录中被查找。
这也是唯一能使源单元名称中的绝对路径被实际解释为磁盘上的绝对路径的值。
如果基本路径本身是相对的，则它被解释为相对于编译器的当前工作目录。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>包含路径不能有空值，必须与非空的基本路径一起使用。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>只要不使导入解析产生歧义，包含路径和基本路径可以重合。
例如，您可以在基本路径内指定一个目录作为包含目录，或者有一个包含目录是另一个包含目录的子目录。
只有传递给主机文件系统加载器的源单元名称在与多个包含路径或包含路径和基本路径结合代表一个现有路径时，
编译器才会发出错误。</p>
</div>
<section id="cli">
<span id="cli-path-normalization-and-stripping"></span><h4>CLI路径规范化和剥离<a class="headerlink" href="#cli" title="此标题的永久链接"></a></h4>
<p>在命令行中，编译器的行为就像您对其他程序的期望一样：
它接受平台的本地格式的路径，相对路径是相对于当前工作目录的。
然而，分配给在命令行上指定了路径的文件的源单元名称，不应该因为项目在不同的平台上被编译，
或者因为编译器碰巧从不同的目录被调用而改变。
为了达到这个目的，来自命令行的源文件的路径必须被转换为规范的形式，
如果可能的话，应使其与基本路径或包含路径之一相对。</p>
<p>规范化规则如下：</p>
<ul class="simple">
<li><p>如果一个路径是相对路径，则通过在其前面加上当前工作目录使其成为绝对路径。</p></li>
<li><p>内部的 <code class="docutils literal notranslate"><span class="pre">.</span></code> 和 <code class="docutils literal notranslate"><span class="pre">..</span></code> 段被折叠起来。</p></li>
<li><p>平台特定的路径分隔符被替换为正斜杠。</p></li>
<li><p>多个连续路径分隔符的序列被压缩成一个分隔符
（除非它们是 <a class="reference external" href="https://en.wikipedia.org/wiki/Path_(computing)#UNC">UNC路径</a> 的前导斜杠）。</p></li>
<li><p>如果路径中包含一个根名（例如Windows系统中的一个盘符），并且该根名与当前工作目录的根名相同，
则根名将被替换为 <code class="docutils literal notranslate"><span class="pre">/</span></code>。</p></li>
<li><p>路径中的符号链接 <strong>没有</strong> 解析。</p>
<ul>
<li><p>唯一的例外是在使相对路径成为绝对路径的过程中，对当前工作目录的路径进行了预处理。
在一些平台上，工作目录总是用带有符号链接的解析来声明，
所以为了保持一致性，编译器在任何地方都会解析它们。</p></li>
</ul>
</li>
<li><p>即使文件系统对大小写不敏感，
但 <a class="reference external" href="https://en.wikipedia.org/wiki/Case_preservation">保留大小写</a>
和磁盘上的实际大小写不同，是会保留路径的原始大小写。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有些情况下，路径不能独立于平台。
例如，在Windows下，编译器可以通过将当前驱动器的根目录称为 <code class="docutils literal notranslate"><span class="pre">/</span></code> 来避免使用驱动器字母，
但对于通往其他驱动器的路径来说，驱动器字母仍然是必要的。
您可以通过确保所有的文件都在同一驱动器上的单一目录树内，来避免这种情况。</p>
</div>
<p>在规范化之后，编译器试图使源文件的路径变成相对的。
它首先尝试基本路径，然后按照给出的顺序尝试包含路径。
如果基本路径是空的或者没有指定，它将被视为等同于当前工作目录的路径（解决了所有符号链接）。
只有当规范化的目录路径是规范化的文件路径的确切前缀时，才会接受这个结果。
否则，文件路径仍然是绝对的。
这使得转换毫不含糊，并确保相对路径不以 <code class="docutils literal notranslate"><span class="pre">.../</span></code> 开头。
产生的文件路径成为源单元名称。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>剥离后产生的相对路径必须在基本路径和包含路径中保持唯一。
例如，如果 <code class="docutils literal notranslate"><span class="pre">/project/contract.sol</span></code> 和  <code class="docutils literal notranslate"><span class="pre">/lib/contract.sol</span></code> 同时存在，
编译器将对以下命令发出错误：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>/project/contract.sol<span class="w"> </span>--base-path<span class="w"> </span>/project<span class="w"> </span>--include-path<span class="w"> </span>/lib
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在0.8.8版本之前，CLI路径剥离不被执行，唯一应用的规范化是路径分隔符的转换。
当使用旧版本的编译器时，建议从基本路径调用编译器，在命令行上只使用相对路径。</p>
</div>
</section>
</section>
<section id="allowed-paths">
<span id="index-8"></span><span id="id11"></span><h3>允许的路径<a class="headerlink" href="#allowed-paths" title="此标题的永久链接"></a></h3>
<p>作为一项安全措施，主机文件系统加载器将拒绝从默认认为安全的几个位置之外的地方加载文件：</p>
<ul class="simple">
<li><p>标准JSON模式之外：</p>
<ul>
<li><p>含有命令行上所列输入文件的目录。</p></li>
<li><p>作为 <a class="reference internal" href="#import-remapping"><span class="std std-ref">重映射</span></a> 目标使用的目录。
如果目标不是一个目录（即不以 <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">/.</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/.</span></code> 结尾），则使用包含该目标的目录。</p></li>
<li><p>基本路径和包含路径。</p></li>
</ul>
</li>
<li><p>在标准JSON模式下：</p>
<ul>
<li><p>基本路径和包含路径。</p></li>
</ul>
</li>
</ul>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">--allow-paths</span></code> 选项将其他目录列入白名单。
该选项接受一个用逗号分隔的路径列表：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>/home/user/project/
solc<span class="w"> </span>token/contract.sol<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>lib/util.sol<span class="o">=</span>libs/util.sol<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--base-path<span class="o">=</span>token/<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--include-path<span class="o">=</span>/lib/<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--allow-paths<span class="o">=</span>../utils/,/tmp/libraries
</pre></div>
</div>
<p>当用上面的命令调用编译器时，主机文件系统加载器将允许从以下目录导入文件：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/home/user/project/token/</span></code> （因为 <code class="docutils literal notranslate"><span class="pre">token/</span></code> 包含输入文件，也因为它是基本路径），</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/lib/</span></code> （因为 <code class="docutils literal notranslate"><span class="pre">/lib/</span></code> 是包含路径之一），</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/home/user/project/libs/</span></code> （因为 <code class="docutils literal notranslate"><span class="pre">libs/</span></code> 是一个包含重映射目标的目录），</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/home/user/utils/</span></code> （因为 <code class="docutils literal notranslate"><span class="pre">.../utils/</span></code> 传给了 <code class="docutils literal notranslate"><span class="pre">-allow-paths</span></code> ），</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/tmp/libraries/</span></code> （因为 <code class="docutils literal notranslate"><span class="pre">/tmp/libraries</span></code> 被传递到 <code class="docutils literal notranslate"><span class="pre">/tmp/libraries</span></code>），</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>编译器的工作目录是默认允许的路径之一，前提是它恰好是基本路径时（或者基本路径没有被指定或有一个空值）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>编译器不检查允许的路径是否真实存在以及它们是否是目录。
不存在的或空的路径会被简单地忽略掉。
如果一个被允许的路径与一个文件而不是一个目录相匹配，该文件也被视为白名单。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>允许的路径是区分大小写的，即使文件系统不是这样的。
大小写必须与您的导入中使用的大小写完全一致。
例如 <code class="docutils literal notranslate"><span class="pre">--allow-paths</span> <span class="pre">tokens</span></code> 不会匹配 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&quot;Tokens/IERC20.sol&quot;</span></code>。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>只有通过允许的目录的符号链接才能到达的文件和目录不会被自动列入白名单。
例如，如果上面的例子中的 <code class="docutils literal notranslate"><span class="pre">token/contract.sol</span></code> 实际上是一个指向
<code class="docutils literal notranslate"><span class="pre">/etc/passwd</span></code> 的符号链接，编译器将拒绝加载它，除非 <code class="docutils literal notranslate"><span class="pre">/etc/</span></code> 也是允许的路径之一。</p>
</div>
</section>
<section id="import-remapping">
<span id="index-9"></span><span id="id12"></span><h3>导入重映射<a class="headerlink" href="#import-remapping" title="此标题的永久链接"></a></h3>
<p>导入重映射允许您将导入重定向到虚拟文件系统的不同位置。
该机制通过改变导入路径和源单元名称之间的转换来工作。
例如，您可以设置一个重映射，使任何从虚拟目录 <code class="docutils literal notranslate"><span class="pre">github.com/ethereum/dapp-bin/library/</span></code>
的导入被视为从 <code class="docutils literal notranslate"><span class="pre">dapp-bin/library/</span></code> 导入。</p>
<p>您可以通过指定 <em>context</em> 来限制重映射的范围。
这允许创建仅适用于特定库或特定文件中的导入的重映射。
如果没有context关键字指定，重映射将应用于虚拟文件系统中所有文件中的每个匹配的导入。</p>
<p>导入重映射的形式为 <code class="docutils literal notranslate"><span class="pre">context:prefix=target</span></code>：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> 必须与包含导入文件的源单元名称的开头相匹配。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prefix</span></code>  必须与导入的源单元名称的开头相匹配。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">target</span></code> 是前缀被替换的值。</p></li>
</ul>
<p>例如，如果您在本地克隆 <a class="reference external" href="https://github.com/ethereum/dapp-bin/">https://github.com/ethereum/dapp-bin/</a> 到 <code class="docutils literal notranslate"><span class="pre">/project/dapp-bin</span></code>，
并用以下命令运行编译器：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>github.com/ethereum/dapp-bin/<span class="o">=</span>dapp-bin/<span class="w"> </span>--base-path<span class="w"> </span>/project<span class="w"> </span>source.sol
</pre></div>
</div>
<p>您可以在您的源文件中使用以下内容：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICJnaXRodWIuY29tL2V0aGVyZXVtL2RhcHAtYmluL2xpYnJhcnkvbWF0aC5zb2wiOyAvLyDmupDljZXlhYPlkI3np7DvvJogZGFwcC1iaW4vbGlicmFyeS9tYXRoLnNvbA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;github.com/ethereum/dapp-bin/library/math.sol&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： dapp-bin/library/math.sol</span>
</pre></div>
</div>
<p>编译器将在VFS的 <code class="docutils literal notranslate"><span class="pre">dapp</span> <span class="pre">bin/library/math.sol</span></code> 下寻找该文件。
如果那里没有该文件，源单元名称将被传递给主机文件系统加载器，
然后它将在 <code class="docutils literal notranslate"><span class="pre">/project/dapp-bin/library/iterable_mapping.sol</span></code> 中寻找。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>关于重映射的信息被存储在合约元数据中。
由于编译器产生的二进制文件中嵌入了元数据的哈希值，对重映射的任何修改都会导致不同的字节码。</p>
<p>由于这个原因，您应该注意不要在重映射目标中包含任何本地信息。
例如，如果您的库位于 <code class="docutils literal notranslate"><span class="pre">/home/user/packages/mymath/math.sol</span></code>，
像 <code class="docutils literal notranslate"><span class="pre">&#64;math/=/home/user/packages/mymath/</span></code> 这样的重映射会导致您的主目录被包含在元数据中。
为了能够在不同的机器上用这样的重映射重现相同的字节码，
您需要在VFS和（如果您依赖主机文件系统加载器）主机文件系统中重新创建您的本地目录结构。</p>
<p>为了避免元数据中嵌入您的本地目录结构，建议将包含库的目录指定为 <em>include paths</em>。
例如，在上面的例子中， <code class="docutils literal notranslate"><span class="pre">--include-path</span> <span class="pre">/home/user/packages/</span></code> 会让您使用以 <code class="docutils literal notranslate"><span class="pre">mymath/</span></code> 开始的导入。
与重映射不同，该选项本身不会使 <code class="docutils literal notranslate"><span class="pre">mymath</span></code> 显示为 <code class="docutils literal notranslate"><span class="pre">&#64;math</span></code>，
但这可以通过创建符号链接或重命名软件包子目录来实现。</p>
</div>
<p>作为一个更复杂的例子，假设您依赖一个使用旧版dapp-bin的模块，
您把它签出到 <code class="docutils literal notranslate"><span class="pre">/project/dapp-bin_old</span></code>，那么您可以运行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>module1:github.com/ethereum/dapp-bin/<span class="o">=</span>dapp-bin/<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>module2:github.com/ethereum/dapp-bin/<span class="o">=</span>dapp-bin_old/<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>--base-path<span class="w"> </span>/project<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>source.sol
</pre></div>
</div>
<p>这意味着 <code class="docutils literal notranslate"><span class="pre">module2</span></code> 的所有导入都指向旧版本，但 <code class="docutils literal notranslate"><span class="pre">module1</span></code> 的导入则指向新版本。</p>
<p>以下是关于重映射行为的详细规则：</p>
<ol class="arabic">
<li><p><strong>重新映射只影响导入路径和源单元名称之间的转换。</strong></p>
<p>以任何其他方式添加到VFS的源单元名称不能被重新映射。
例如，您在命令行上指定的路径和标准JSON中 <code class="docutils literal notranslate"><span class="pre">sources.urls</span></code> 中的路径不受影响。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>/project/<span class="o">=</span>/contracts/<span class="w"> </span>/project/contract.sol<span class="w"> </span><span class="c1"># 源单元名称： /project/contract.sol</span>
</pre></div>
</div>
<p>在上面的例子中，编译器将从 <code class="docutils literal notranslate"><span class="pre">/project/contract.sol</span></code> 中加载源代码，
并将其放在VFS中那个确切的源代码单元名下，而不是放在 <code class="docutils literal notranslate"><span class="pre">/contract/contract.sol</span></code> 中。</p>
</li>
<li><p><strong>上下文和前缀必须与源单元名称相匹配，而不是导入路径。</strong></p>
<ul>
<li><p>这意味着您不能直接重新映射 <code class="docutils literal notranslate"><span class="pre">./</span></code> 或 <code class="docutils literal notranslate"><span class="pre">./</span></code>，因为它们在转译成源单元名称时被替换了，
但您可以重新映射它们被替换的那部分名称：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>./<span class="o">=</span>a/<span class="w"> </span>/project/<span class="o">=</span>b/<span class="w"> </span>/project/contract.sol<span class="w"> </span><span class="c1"># 源单元名称： /project/contract.sol</span>
</pre></div>
</div>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">/project/contract.sol</span><a class="headerlink" href="#id17" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAvLyDmupDljZXlhYPlkI3np7DvvJogYi91dGlsLnNvbA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./util.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>util<span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： b/util.sol</span>
</pre></div>
</div>
</div>
</li>
<li><p>您不能重新映射基本路径或仅由导入回调内部添加的任何其他部分的路径。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>/project/<span class="o">=</span>/contracts/<span class="w"> </span>/project/contract.sol<span class="w"> </span>--base-path<span class="w"> </span>/project<span class="w"> </span><span class="c1"># 源单元名称： contract.sol</span>
</pre></div>
</div>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">/project/contract.sol</span><a class="headerlink" href="#id18" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICJ1dGlsLnNvbCIgYXMgdXRpbDsgLy8g5rqQ5Y2V5YWD5ZCN56ew77yaIHV0aWwuc29s"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;util.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>util<span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： util.sol</span>
</pre></div>
</div>
</div>
</li>
</ul>
</li>
<li><p><strong>目标直接插入源单元名称中，不一定是有效的路径。</strong></p>
<ul>
<li><p>只要导入回调能够处理它，它可以是任何东西。
在主机文件系统加载器的情况下，这也包括相对路径。
当使用JavaScript接口时，您甚至可以使用URL和抽象标识符，
如果您的回调能够处理它们。</p></li>
<li><p>重映射发生在相对导入已经被解析为源单元名称之后。
这意味着以 <code class="docutils literal notranslate"><span class="pre">./</span></code> 和 <code class="docutils literal notranslate"><span class="pre">./</span></code> 开头的目标没有特殊含义，是相对于基本路径而不是源文件的位置。</p></li>
<li><p>重映射目标没有被规范化，所以 <code class="docutils literal notranslate"><span class="pre">&#64;root/=./a/b//</span></code> 将重映射
<code class="docutils literal notranslate"><span class="pre">&#64;root/contract.sol</span></code> 到 <code class="docutils literal notranslate"><span class="pre">./a/b/contract.sol</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">a/b/contract.sol</span></code>。</p></li>
<li><p>如果目标不以斜线结尾，编译器将不会自动添加一个斜线:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>/project/<span class="o">=</span>/contracts<span class="w"> </span>/project/contract.sol<span class="w"> </span><span class="c1"># 源单元名称： /project/contract.sol</span>
</pre></div>
</div>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">/project/contract.sol</span><a class="headerlink" href="#id19" title="此代码块的永久链接"></a></div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aW1wb3J0ICIvcHJvamVjdC91dGlsLnNvbCIgYXMgdXRpbDsgLy8g5rqQ5Y2V5YWD5ZCN56ew77yaIC9jb250cmFjdHN1dGlsLnNvbA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">import</span><span class="w"> </span><span class="s2">&quot;/project/util.sol&quot;</span><span class="w"> </span>as<span class="w"> </span>util<span class="p">;</span><span class="w"> </span><span class="c1">// 源单元名称： /contractsutil.sol</span>
</pre></div>
</div>
</div>
</li>
</ul>
</li>
<li><p><strong>上下文和前缀是匹配模式，匹配必须是精确的。</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a//b=c</span></code> 不会匹配 <code class="docutils literal notranslate"><span class="pre">a/b</span></code>。</p></li>
<li><p>源单元名称没有被规范化，所以 <code class="docutils literal notranslate"><span class="pre">a/b=c</span></code> 也不会匹配 <code class="docutils literal notranslate"><span class="pre">a//b</span></code>。</p></li>
<li><p>文件和目录的部分名称是可以匹配。
<code class="docutils literal notranslate"><span class="pre">/newProject/con:/new=old</span></code> 将匹配 <code class="docutils literal notranslate"><span class="pre">/newProject/contract.sol</span></code>
并将其重新映射到 <code class="docutils literal notranslate"><span class="pre">oldProject/contract.sol</span></code>。</p></li>
</ul>
</li>
<li><p><strong>最多只有一个重映射被应用于单个导入。</strong></p>
<ul class="simple">
<li><p>如果多个重映射与同一个源单元名称相匹配，则选择具有最长匹配前缀的那个。</p></li>
<li><p>如果前缀相同，则选择最后指定的那个。</p></li>
<li><p>重映射对其他重映射不起作用。例如 <code class="docutils literal notranslate"><span class="pre">a=b</span> <span class="pre">b=c</span> <span class="pre">c=d</span></code> 不会导致 <code class="docutils literal notranslate"><span class="pre">a</span></code> 被重映射到 <code class="docutils literal notranslate"><span class="pre">d</span></code>。</p></li>
</ul>
</li>
<li><p><strong>prefix不能为空，但context和target是可选的。</strong></p>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">target</span></code> 是空字符串， <code class="docutils literal notranslate"><span class="pre">prefix</span></code> 将从导入路径中删除。</p></li>
<li><p>空的 <code class="docutils literal notranslate"><span class="pre">context</span></code> 意味着重新映射适用于所有源单元中的所有导入。</p></li>
</ul>
</li>
</ol>
</section>
<section id="url">
<span id="index-10"></span><h3>在导入中使用url<a class="headerlink" href="#url" title="此标题的永久链接"></a></h3>
<p>大多数URL前缀，如 <code class="docutils literal notranslate"><span class="pre">https://</span></code> 或 <code class="docutils literal notranslate"><span class="pre">data://</span></code> 在导入路径中没有特殊含义。
唯一的例外是 <code class="docutils literal notranslate"><span class="pre">file://</span></code>，它被主机文件系统加载器从源单元名称中剥离出来。</p>
<p>在本地编译时，您可以使用导入重映射，用本地路径替换协议和域名部分：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>:https://github.com/ethereum/dapp-bin<span class="o">=</span>/usr/local/dapp-bin<span class="w"> </span>contract.sol
</pre></div>
</div>
<p>注意前面的 <code class="docutils literal notranslate"><span class="pre">:</span></code>，当重映射上下文为空时，这是必要的。
否则， <code class="docutils literal notranslate"><span class="pre">https:</span></code> 部分将被编译器解释为上下文。</p>
</section>
</section>
<span id="document-yul"></span><section id="yul">
<span id="id1"></span><h2>Yul<a class="headerlink" href="#yul" title="此标题的永久链接"></a></h2>
<p id="index-0">Yul（先前被也被称为 JULIA 或 IULIA）是一种可以编译到各种不同后端的中间语言。</p>
<p>计划支持EVM 1.0，EVM 1.5和Ewasm，它被设计为这三个平台的可用的共同标准。
它已经可以在独立模式下使用，也可以在Solidity内部用于 “内联汇编”，
并且有一个Solidity编译器的实验性实现，将Yul作为一种中间语言。
Yul是高级优化阶段的一个很好的目标，可以使所有的目标平台同样受益。</p>
<section id="id2">
<h3>动机和高级别描述<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>Yul 的设计试图实现几个目标：</p>
<ol class="arabic simple">
<li><p>用Yul编写的程序应该是可读的，即使代码是由Solidity或其他高级语言的编译器生成的。</p></li>
<li><p>控制流应易于理解，以帮助人工检查、形式化验证和优化。</p></li>
<li><p>从Yul到字节码的翻译应该尽可能的简单明了。</p></li>
<li><p>Yul应该适用于整个程序的优化。</p></li>
</ol>
<p>为了实现第一个和第二个目标，Yul提供了高级别的结构，如 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环， <code class="docutils literal notranslate"><span class="pre">if</span></code> 和 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句和函数调用。
这些应该足以充分代表汇编程序的控制流。
因此，没有提供 <code class="docutils literal notranslate"><span class="pre">SWAP</span></code>， <code class="docutils literal notranslate"><span class="pre">DUP</span></code>， <code class="docutils literal notranslate"><span class="pre">JUMPDEST</span></code>， <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 和 <code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> 的明确语句，
因为前两者混淆了数据流，后两者混淆了控制流。此外，
<code class="docutils literal notranslate"><span class="pre">mul(add(x,</span> <span class="pre">y),</span> <span class="pre">7)</span></code> 形式的函数语句比 <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">y</span> <span class="pre">x</span> <span class="pre">add</span> <span class="pre">mul</span></code> 这样的纯操作码语句更受欢迎，
因为在第一种形式中，更容易看到哪个操作数用于哪个操作码。</p>
<p>尽管它是为堆栈机设计的，但Yul并没有暴露堆栈本身的复杂性。
程序员或审计师不应该担心堆栈的问题。</p>
<p>第三个目标是通过以一种非常有规律的方式将高层结构编译成字节码来实现的。
汇编器执行的唯一非本地操作是用户定义的标识符（函数、变量......）的名称查找和清理堆栈中的本地变量。</p>
<p>为了避免值和引用等概念之间的混淆，
Yul是静态类型的。同时，
有一个默认的类型（通常是目标机的整数字），
可以随时省略以帮助增加可读性。</p>
<p>为了保持语言的简单和灵活，
Yul在其纯粹的形式下没有任何内置的操作，函数或类型。
在指定Yul的语言时，这些操作和语义被添加到一起，
这使得Yul可以根据不同的目标平台和功能集的要求进行专业化。</p>
<p>目前，只有一种指定的Yul语言。这个语言使用EVM的操作码作为内建函数（见下文），
并且只定义了 <code class="docutils literal notranslate"><span class="pre">u256</span></code> 类型，这是EVM的本地256位类型。正因为如此，我们将不在下面的例子中提供类型。</p>
</section>
<section id="id3">
<h3>简单的例子<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>下面的例子程序是用EVM语言编写的，用来计算指数。
它可以用 <code class="docutils literal notranslate"><span class="pre">solc</span> <span class="pre">--strict-assembly</span></code> 指令编译。
内置函数 <code class="docutils literal notranslate"><span class="pre">mul</span></code> 和 <code class="docutils literal notranslate"><span class="pre">div</span></code> 分别计算乘法和除法。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdAogICAgewogICAgICAgIHN3aXRjaCBleHBvbmVudAogICAgICAgIGNhc2UgMCB7IHJlc3VsdCA6PSAxIH0KICAgICAgICBjYXNlIDEgeyByZXN1bHQgOj0gYmFzZSB9CiAgICAgICAgZGVmYXVsdAogICAgICAgIHsKICAgICAgICAgICAgcmVzdWx0IDo9IHBvd2VyKG11bChiYXNlLCBiYXNlKSwgZGl2KGV4cG9uZW50LCAyKSkKICAgICAgICAgICAgc3dpdGNoIG1vZChleHBvbmVudCwgMikKICAgICAgICAgICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBtdWwoYmFzZSwgcmVzdWx0KSB9CiAgICAgICAgfQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="k">function</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">result</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="n">exponent</span>
        <span class="k">case</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="k">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="n">base</span> <span class="p">}</span>
        <span class="k">default</span>
        <span class="p">{</span>
            <span class="n">result</span> <span class="o">:=</span> <span class="n">power</span><span class="p">(</span><span class="nf">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="nf">div</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">switch</span> <span class="nf">mod</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>也可以用for-loop而不是递归来实现同样的函数。
这里， <code class="docutils literal notranslate"><span class="pre">lt(a,</span> <span class="pre">b)</span></code> 计算 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是否小于 <code class="docutils literal notranslate"><span class="pre">b</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdAogICAgewogICAgICAgIHJlc3VsdCA6PSAxCiAgICAgICAgZm9yIHsgbGV0IGkgOj0gMCB9IGx0KGksIGV4cG9uZW50KSB7IGkgOj0gYWRkKGksIDEpIH0KICAgICAgICB7CiAgICAgICAgICAgIHJlc3VsdCA6PSBtdWwocmVzdWx0LCBiYXNlKQogICAgICAgIH0KICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="k">function</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">result</span>
    <span class="p">{</span>
        <span class="n">result</span> <span class="o">:=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="p">{</span> <span class="ow">let</span> <span class="nv">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">{</span>
            <span class="n">result</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <a class="reference internal" href="#erc20yul"><span class="std std-ref">本节的末尾</span></a> ，可以找到ERC-20标准的完整实现。</p>
</section>
<section id="id4">
<h3>单独使用<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>您可以使用Solidity编译器在EVM语言中以独立的形式使用Yul。
这将使用 <a class="reference internal" href="#yul-object"><span class="std std-ref">Yul 对象符号</span></a>，这样就有可能将代码作为数据引用到部署合约中。
这种Yul模式可用于命令行编译器（使用 <code class="docutils literal notranslate"><span class="pre">--strict-assembly</span></code>）和 <a class="reference internal" href="index.html#compiler-api"><span class="std std-ref">标准-json接口</span></a>。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;language&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Yul&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;sources&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;input.yul&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;{ sstore(0, 1) }&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;settings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;outputSelection&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span><span class="w"> </span><span class="nt">&quot;&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;*&quot;</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;optimizer&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;enabled&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;details&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;yul&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Yul正在积极开发中，只有以EVM 1.0为目标，Yul的EVM语言才能完全实现字节码生成。</p>
</div>
</section>
<section id="id5">
<h3>对Yul的非正式描述<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>在下文中，我们将谈论Yul语言的每个单独方面。在例子中，我们将使用默认的EVM语言。</p>
<section id="id6">
<h4>语法<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<p>Yul使用与Solidity相同的方式解析注释，字词和标识符，
所以您可以使用 <code class="docutils literal notranslate"><span class="pre">//</span></code> 和 <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> 来表示注释。
但是有一个例外，Yul中的标识符可以包含圆点： <code class="docutils literal notranslate"><span class="pre">.</span></code>。</p>
<p>Yul可以指定由代码，数据和子对象组成的 “对象”。
请参阅 <a class="reference internal" href="#yul-object"><span class="std std-ref">Yul 对象</span></a> 以了解这方面的详情。
在本节中，我们只关注这样一个对象的代码部分。
这个代码部分总是由一个大括号限定的块组成。
大多数工具都支持只指定一个预期对象的代码块。</p>
<p>在一个代码块内，可以使用以下元素（更多细节见后面章节）：</p>
<ul class="simple">
<li><p>字母，即 <code class="docutils literal notranslate"><span class="pre">0x123</span></code>， <code class="docutils literal notranslate"><span class="pre">42</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;abc&quot;</span></code> （32个字符以内的字符串）。</p></li>
<li><p>对内置函数的调用，例如 <code class="docutils literal notranslate"><span class="pre">add(1,</span> <span class="pre">mload(0))</span></code></p></li>
<li><p>变量声明，例如 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">7</span></code>， <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(y,</span> <span class="pre">3)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span></code> （初始值为0）</p></li>
<li><p>标识符（变量），例如： <code class="docutils literal notranslate"><span class="pre">add(3,</span> <span class="pre">x)</span></code></p></li>
<li><p>赋值，例如： <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(y,</span> <span class="pre">3)</span></code></p></li>
<li><p>局部变量的作用域所在的代码块，例如 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">3</span> <span class="pre">{</span> <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">add(x,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">}</span></code></p></li>
<li><p>if 语句，例如 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">lt(a,</span> <span class="pre">b)</span> <span class="pre">{</span> <span class="pre">sstore(0,</span> <span class="pre">1)</span> <span class="pre">}</span></code></p></li>
<li><p>switch语句，例如 <code class="docutils literal notranslate"><span class="pre">switch</span> <span class="pre">mload(0)</span> <span class="pre">case</span> <span class="pre">0</span> <span class="pre">{</span> <span class="pre">revert()</span> <span class="pre">}</span> <span class="pre">default</span> <span class="pre">{</span> <span class="pre">mstore(0,</span> <span class="pre">1)</span> <span class="pre">}</span></code></p></li>
<li><p>for 循环，例如 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">{</span> <span class="pre">let</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">0}</span> <span class="pre">lt(i,</span> <span class="pre">10)</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">add(i,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">{</span> <span class="pre">mstore(i,</span> <span class="pre">7)</span> <span class="pre">}</span></code></p></li>
<li><p>函数的定义，例如 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(a,</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">c</span> <span class="pre">{</span> <span class="pre">c</span> <span class="pre">:=</span> <span class="pre">add(a,</span> <span class="pre">b)</span> <span class="pre">}</span></code></p></li>
</ul>
<p>多个语法元素之间可以简单地用空格隔开，即不需要结尾的 <code class="docutils literal notranslate"><span class="pre">;</span></code> 或换行。</p>
</section>
<section id="id7">
<h4>字面量<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>作为字面量，您可以使用。</p>
<ul class="simple">
<li><p>以十进制或十六进制符号表示的整数常数。</p></li>
<li><p>ASCII字符串（例如 <code class="docutils literal notranslate"><span class="pre">&quot;abc&quot;</span></code>），可能包含十六进制转义 <code class="docutils literal notranslate"><span class="pre">\xNN</span></code> 和 Unicode转义 <code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">N</span></code> 是十六进制数字。</p></li>
<li><p>十六进制字符串（例如： <code class="docutils literal notranslate"><span class="pre">hex&quot;616263&quot;</span></code>）。</p></li>
</ul>
<p>在Yul的EVM语言中，字面量表示256位的单词，如下所示：</p>
<ul class="simple">
<li><p>十进制或十六进制的常量必须小于 <code class="docutils literal notranslate"><span class="pre">2**256</span></code>。
它们以大端编码的无符号整数形式表示具有该值的256位字。</p></li>
<li><p>一个ASCII字符串首先被看作是一个字节序列，
通过将非转义ASCII字符看作是一个单字节，其值是ASCII代码，
转义 <code class="docutils literal notranslate"><span class="pre">\xNN</span></code> 是具有该值的单字节，
转义 <code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> 是该代码点的UTF-8字节序列。
字节序列不得超过32字节。
字节序列在右边用零填充，以达到32个字节的长度；
换句话说，字符串是以左对齐的方式存储。
填充后的字节序列代表一个256位的字，其最有意义的8位是第一个字节的1，
也就是说，字节被解释为大端形式。</p></li>
<li><p>十六进制字符串首先被视为一个字节序列，
将每一对连续的十六进制数字视为一个字节。
字节序列不得超过32个字节（即64个十六进制数字），并按上述方法处理。</p></li>
</ul>
<p>当为EVM编译时，这将被翻译成一个适当的 <code class="docutils literal notranslate"><span class="pre">PUSHi</span></code> 指令。
在下面的例子中， <code class="docutils literal notranslate"><span class="pre">3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2</span></code> 相加的结果是 5，
然后计算与字符串 “abc” 的按位 <code class="docutils literal notranslate"><span class="pre">与（and）</span></code>。
最后的数值被分配到一个叫做 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的局部变量。</p>
<p>上述32字节的限制并不适用于传递给需要字面参数的内置函数的字符串（例如， <code class="docutils literal notranslate"><span class="pre">setimmutable</span></code> 或 <code class="docutils literal notranslate"><span class="pre">loadimmutable</span></code>）。
这些字符串最终不会出现在生成的字节码中。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IHggOj0gYW5kKCJhYmMiLCBhZGQoMywgMikp"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="nf">and</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>除非是默认类型，否则字面的类型必须在冒号后指定：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=Ly8g6L+Z5bCG5LiN5Lya6KKr57yW6K+R77yIdTMy5ZKMdTI1Nuexu+Wei+WwmuacquWunueOsO+8ieOAggpsZXQgeCA6PSBhbmQoImFiYyI6dTMyLCBhZGQoMzp1MjU2LCAyOnUyNTYpKQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这将不会被编译（u32和u256类型尚未实现）。</span>
<span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="nf">and</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">:</span><span class="n">u32</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">3</span><span class="p">:</span><span class="n">u256</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="n">u256</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="id8">
<h4>函数调用<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>内置函数和用户定义的函数（见下文）都可以用前面例子中的相同方式调用。
如果函数返回一个单一的值，它可以直接在一个表达式中再次使用。
如果它返回多个值，则必须将它们分配给局部变量。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gZih4LCB5KSAtPiBhLCBiIHsgLyogLi4uICovIH0KbXN0b3JlKDB4ODAsIGFkZChtbG9hZCgweDgwKSwgMykpCi8vIOatpOWkhO+8jOeUqOaIt+WumuS5ieeahOWHveaVsCBgZmAg6L+U5Zue5Lik5Liq5YC844CCCmxldCB4LCB5IDo9IGYoMSwgbWxvYWQoMCkp"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="nf">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="mh">0x80</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">// 此处，用户定义的函数 `f` 返回两个值。</span>
<span class="ow">let</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>对于EVM的内置函数，函数表达式可以直接转换为操作码流：
您只需从右到左读取表达式，就可以得到操作码。
在例子中的第一行，是 <code class="docutils literal notranslate"><span class="pre">PUSH1</span> <span class="pre">3</span> <span class="pre">PUSH1</span> <span class="pre">0x80</span> <span class="pre">MLOAD</span> <span class="pre">ADD</span> <span class="pre">PUSH1</span> <span class="pre">0x80</span> <span class="pre">MSTORE</span></code>。</p>
<p>对于调用用户定义的函数，参数也从右到左放在堆栈中，这是参数列表被评估的顺序。
然而，返回值是在堆栈中从左到右，即在这个例子中， <code class="docutils literal notranslate"><span class="pre">y</span></code> 在堆栈的顶部， <code class="docutils literal notranslate"><span class="pre">x</span></code> 在其下方。</p>
</section>
<section id="id9">
<h4>变量声明<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">let</span></code> 关键字来声明变量。变量只在它所定义的 <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 块内可见。
当编译到EVM时，会创建一个新的堆栈槽，为该变量保留，并在到达块的末端时自动移除。
您可以为该变量提供一个初始值。如果您不提供一个值，该变量将被初始化为零。</p>
<p>由于变量存储在堆栈中，它们不直接影响内存或存储，
但它们可以在内置函数 <code class="docutils literal notranslate"><span class="pre">mstore</span></code>， <code class="docutils literal notranslate"><span class="pre">mload</span></code>， <code class="docutils literal notranslate"><span class="pre">sstore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sload</span></code> 中作为内存或存储位置的指针使用。
未来的语言可能会为这种指针引入特定的类型。</p>
<p>当一个变量被引用时，其当前值被复制。
对于EVM来说，这相当于一个 <code class="docutils literal notranslate"><span class="pre">DUP</span></code> 指令。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IHplcm8gOj0gMAogICAgbGV0IHYgOj0gY2FsbGRhdGFsb2FkKHplcm8pCiAgICB7CiAgICAgICAgbGV0IHkgOj0gYWRkKHNsb2FkKHYpLCAxKQogICAgICAgIHYgOj0geQogICAgfSAvLyB55Zyo6L+Z6YeM6KKrIOKAnOWIoOmZpOKAnSDkuoYKICAgIHNzdG9yZSh2LCB6ZXJvKQp9IC8vIHblkox6ZXJv5Zyo6L+Z6YeM6KKrIOKAnOWIoOmZpOKAneOAgg=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">zero</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="ow">let</span> <span class="nv">v</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="ow">let</span> <span class="nv">y</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nf">sload</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="n">y</span>
    <span class="p">}</span> <span class="c1">// y在这里被 “删除” 了</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>
<span class="p">}</span> <span class="c1">// v和zero在这里被 “删除”。</span>
</pre></div>
</div>
<p>如果声明的变量应该有一个与默认类型不同的类型，您可以用冒号表示。
当您从一个返回多个值的函数调用中赋值时，您也可以在一条语句中声明多个变量。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=Ly8g6L+Z5bCG5LiN5Lya6KKr57yW6K+R77yIdTMy5ZKMdTI1Nuexu+Wei+WwmuacquWunueOsO+8ieOAggp7CiAgICBsZXQgemVybzp1MzIgOj0gMDp1MzIKICAgIGxldCB2OnUyNTYsIHQ6dTMyIDo9IGYoKQogICAgbGV0IHgsIHkgOj0gZygpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这将不会被编译（u32和u256类型尚未实现）。</span>
<span class="p">{</span>
    <span class="ow">let</span> <span class="nv">zero</span><span class="p">:</span><span class="n">u32</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">:</span><span class="n">u32</span>
    <span class="ow">let</span> <span class="nv">v</span><span class="p">:</span><span class="n">u256</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span><span class="n">u32</span> <span class="o">:=</span> <span class="n">f</span><span class="p">()</span>
    <span class="ow">let</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>根据优化器的设置，编译器可以在变量被最后一次使用后释放堆栈槽，即使它仍然在范围内。</p>
</section>
<section id="id10">
<h4>赋值<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h4>
<p>变量可以在其定义后使用 <code class="docutils literal notranslate"><span class="pre">:=</span></code> 操作符进行赋值。可以在同一时间对多个变量进行赋值。
为此，数值的数量和类型必须匹配。如果您想对一个有多个返回参数的函数进行赋值，
您必须提供多个变量。同一变量不能多次出现在赋值的左侧，例如： <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">f()</span></code> 是无效的。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IHYgOj0gMAovLyDph43mlrDlr7l26LWL5YC8CnYgOj0gMgpsZXQgdCA6PSBhZGQodiwgMikKZnVuY3Rpb24gZigpIC0+IGEsIGIgeyB9Ci8vIOi1i+S6iOWkmuS4quWAvAp2LCB0IDo9IGYoKQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">v</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="c1">// 重新对v赋值</span>
<span class="n">v</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="ow">let</span> <span class="nv">t</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">function</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">// 赋予多个值</span>
<span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="if">
<h4>If<a class="headerlink" href="#if" title="此标题的永久链接"></a></h4>
<p>if语句可用于有条件地执行代码。不能定义 “else” 块。
如果您需要多种选择条件，可以考虑使用 “switch” 来代替（见下文）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=aWYgbHQoY2FsbGRhdGFzaXplKCksIDQpIHsgcmV2ZXJ0KDAsIDApIH0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nf">lt</span><span class="p">(</span><span class="nf">calldatasize</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>代码块的大括号是必需的。</p>
</section>
<section id="switch">
<h4>Switch<a class="headerlink" href="#switch" title="此标题的永久链接"></a></h4>
<p>您可以使用switch语句作为if语句的扩展版本。
它获取一个表达式的值，并将其与几个字面常量进行比较，与匹配的常量相对应的分支被选中。
与其他编程语言不同的是，出于安全考虑，控制流不会从一个条件延续到下一个条件。
可以有一个叫 <code class="docutils literal notranslate"><span class="pre">default</span></code> 的回退或默认情况，如果没有一个字面常数匹配，就会采取这种情况。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IHggOj0gMAogICAgc3dpdGNoIGNhbGxkYXRhbG9hZCg0KQogICAgY2FzZSAwIHsKICAgICAgICB4IDo9IGNhbGxkYXRhbG9hZCgweDI0KQogICAgfQogICAgZGVmYXVsdCB7CiAgICAgICAgeCA6PSBjYWxsZGF0YWxvYWQoMHg0NCkKICAgIH0KICAgIHNzdG9yZSgwLCBkaXYoeCwgMikpCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">switch</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mh">0x24</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">default</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mh">0x44</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">sstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>条件的列表没有用大括号括起来，但条件的主体确实需要大括号。</p>
</section>
<section id="id11">
<h4>循环<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>Yul支持for循环，它由一个包含初始化部分的头，一个条件，一个后迭代部分和一个主体组成。
条件必须是一个表达式，而其他三个是代码块。
如果初始化部分在顶层声明了任何变量，这些变量的范围将延伸到循环的所有其他部分。</p>
<p><code class="docutils literal notranslate"><span class="pre">break</span></code> 和 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 语句可以在主体中使用，分别用于退出循环或跳到后部分。</p>
<p>下面的例子是计算内存中一个代码区域的总和。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IHggOj0gMAogICAgZm9yIHsgbGV0IGkgOj0gMCB9IGx0KGksIDB4MTAwKSB7IGkgOj0gYWRkKGksIDB4MjApIH0gewogICAgICAgIHggOj0gYWRkKHgsIG1sb2FkKGkpKQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="ow">let</span> <span class="nv">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For循环也可以作为while循环的替代：
只需将初始化和后迭代部分留为空即可。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgbGV0IHggOj0gMAogICAgbGV0IGkgOj0gMAogICAgZm9yIHsgfSBsdChpLCAweDEwMCkgeyB9IHsgICAgIC8vIHdoaWxlKGkgPCAweDEwMCkKICAgICAgICB4IDo9IGFkZCh4LCBtbG9hZChpKSkKICAgICAgICBpIDo9IGFkZChpLCAweDIwKQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="ow">let</span> <span class="nv">i</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="p">}</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">{</span>     <span class="c1">// while(i &lt; 0x100)</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id12">
<h4>函数声明<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<p>Yul允许定义函数。这些不应该与 Solidity 中的函数相混淆，因为它们从来不是一个合约的外部接口的一部分，
而是一个独立于 Solidity 函数的命名空间的一部分。</p>
<p>对于EVM来说，Yul函数从堆栈中获取它们的参数（和一个返回的PC），
同时也将结果放到堆栈中。用户定义的函数和内置函数的调用方式完全相同。</p>
<p>函数可以在任何地方定义，并且在它们所声明的块中是可见的。
在一个函数中，您不能访问在该函数之外定义的局部变量。</p>
<p>函数声明参数和返回变量，与Solidity类似。
为了返回一个值，您可以把它分配给返回变量。</p>
<p>如果您调用一个返回多个值的函数，
您必须用 <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">f(x)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">a,</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">f(x)</span></code> 将它们分配给多个变量。</p>
<p><code class="docutils literal notranslate"><span class="pre">leave</span></code> 语句可以用来退出当前函数。它的工作原理类似于其他语言中的 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句，
只是它不需要返回值，它只是退出函数，
函数将返回当前分配给返回变量的任何值。</p>
<p>注意，EVM语言有一个内置的函数叫 <code class="docutils literal notranslate"><span class="pre">return</span></code>，
它可以退出整个执行环境（内部消息调用），而不仅仅是当前的yul函数。</p>
<p>下面的例子通过平方和乘法实现了幂函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdCB7CiAgICAgICAgc3dpdGNoIGV4cG9uZW50CiAgICAgICAgY2FzZSAwIHsgcmVzdWx0IDo9IDEgfQogICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBiYXNlIH0KICAgICAgICBkZWZhdWx0IHsKICAgICAgICAgICAgcmVzdWx0IDo9IHBvd2VyKG11bChiYXNlLCBiYXNlKSwgZGl2KGV4cG9uZW50LCAyKSkKICAgICAgICAgICAgc3dpdGNoIG1vZChleHBvbmVudCwgMikKICAgICAgICAgICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBtdWwoYmFzZSwgcmVzdWx0KSB9CiAgICAgICAgfQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="k">function</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">result</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">exponent</span>
        <span class="k">case</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="k">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="n">base</span> <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">:=</span> <span class="n">power</span><span class="p">(</span><span class="nf">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="nf">div</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">switch</span> <span class="nf">mod</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id13">
<h3>Yul形式规范<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h3>
<p>本章正式描述Yul代码。Yul代码通常放置在Yul对象内，
Yul对象将在它们自己的章节中解释。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>代码块 = &#39;{&#39; 语句* &#39;}&#39;
语句 =
    代码块 |
    函数定义 |
    变量声明 |
    赋值 |
    If |
    表达式 |
    Switch |
    For 循环 |
    循环中断 |
    退出
函数定义 =
    &#39;function&#39; 标识符 &#39;(&#39; 带类型的标识符列表? &#39;)&#39;
    ( &#39;-&gt;&#39; 带类型的标识符列表 )? 代码块
变量声明 =
    &#39;let&#39; 带类型的标识符列表 ( &#39;:=&#39; 表达式 )?
赋值 =
    标识符列表 &#39;:=&#39; 表达式
表达式 =
    函数调用 | 标识符 | 字面量
If 条件语句 =
    &#39;if&#39; 表达式 代码块
Switch 条件语句 =
    &#39;switch&#39; 表达式 ( Case+ Default? | Default )
Case =
    &#39;case&#39; 字面量 代码块
Default =
    &#39;default&#39; 代码块
For 循环 =
    &#39;for&#39; 代码块 表达式 代码块 代码块
循环中断 =
    &#39;break&#39; | &#39;continue&#39;
退出 = &#39;leave&#39;
函数调用 =
    标识符 &#39;(&#39; ( 表达式 ( &#39;,&#39; 表达式 )* )? &#39;)&#39;
标识符 = [a-zA-Z_$] [a-zA-Z_$0-9.]*
标识符列表 = 标识符 ( &#39;,&#39; 标识符)*
类型名 = 标识符
带类型的标识符列表 = 标识符 ( &#39;:&#39; 类型名 )? ( &#39;,&#39; 标识符 ( &#39;:&#39; 类型名 )? )*
字面量 =
    (数字字面量 | 字符串字面量 | True字面量 | False字面量) ( &#39;:&#39; 类型名 )?
数字字面量 = 十六进制数字 | 十进制数字
字符串字面量 = &#39;&quot;&#39; ([^&quot;\r\n\\] | &#39;\\&#39; .)* &#39;&quot;&#39;
True字面量 = &#39;true&#39;
False字面量 = &#39;false&#39;
十六进制数字 = &#39;0x&#39; [0-9a-fA-F]+
十进制数字 = [0-9]+
</pre></div>
</div>
<section id="id14">
<h4>语法层面的限制<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h4>
<p>除语法直接规定的限制外，还适用以下限制：</p>
<p>Switch 语句必须至少有一个判断条件（包括默认条件）。
所有情况下的值都需要有相同的类型和不同的值。
如果表达式类型的所有可能值都被覆盖，则不允许有默认情况
（例如，一个带有 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 表达式的Switch 语句，如果有一个真和一个假的情况，则不允许有默认情况）。</p>
<p>每个表达式都评估为零或多个值。
标识符和字面量精确地评估为一个值，
而函数调用求值为所调用函数的返回值。</p>
<p>在变量声明和赋值中，右边的表达式（如果存在的话）必须求值到与左边的变量数量相等的数值。
这是唯一允许对一个以上的值进行评估的表达式的情况。
在赋值或变量声明的左侧，同一个变量名称不能出现多次。</p>
<p>也是语句的表达式（即在块级）必须评估为零值。</p>
<p>在所有其他情况下，表达式必须精确评估为一个值。</p>
<p><code class="docutils literal notranslate"><span class="pre">continue</span></code> 或 <code class="docutils literal notranslate"><span class="pre">break</span></code> 语句只能在for循环的主体内使用，如下所示。
考虑包含该语句的最内部循环。循环和语句必须在同一个函数中，或者两者必须在最高层。
该语句必须在循环的主体块中；不能在循环的初始化块或更新块中。
值得强调的是，这个限制只适用于包含 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 或 <code class="docutils literal notranslate"><span class="pre">break</span></code> 语句的最内层循环：
这个最内层循环，以及 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 或 <code class="docutils literal notranslate"><span class="pre">break</span></code> 语句，
可以出现在外层循环的任何地方，可能是外层循环的初始化块或更新块中。
例如，下面的例子是合法的，因为 <code class="docutils literal notranslate"><span class="pre">break</span></code> 出现在内循环的主体块中，尽管也出现在外循环的更新块中。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=Zm9yIHt9IHRydWUgeyBmb3Ige30gdHJ1ZSB7fSB7IGJyZWFrIH0gfQp7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">{}</span> <span class="n">true</span> <span class="p">{</span> <span class="k">for</span> <span class="p">{}</span> <span class="n">true</span> <span class="p">{}</span> <span class="p">{</span> <span class="n">break</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>for循环的条件部分必须精确评估为一个值。</p>
<p><code class="docutils literal notranslate"><span class="pre">leave</span></code> 语句只能在一个函数内使用。</p>
<p>函数不能在for循环初始化块的任何地方定义。</p>
<p>字面量不可以大于它们本身的类型。已定义的最大类型宽度为 256 比特。</p>
<p>在赋值和函数调用过程中，各个值的类型必须匹配。
没有隐式的类型转换。一般来说，只有当EVM语言提供一个适当的内置函数，
接收一个类型的值并返回一个不同类型的值时，才能实现类型转换。</p>
</section>
<section id="id15">
<h4>作用域规则<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h4>
<p>Yul中的作用域是与块联系在一起的（函数和for循环是例外，下面会解释），
所有的声明（ <code class="docutils literal notranslate"><span class="pre">函数定义（FunctionDefinition）</span></code>，  <code class="docutils literal notranslate"><span class="pre">变量声明（VariableDeclaration）</span></code>）
都将新的标识符引入这些作用域。</p>
<p>标识符在其定义的块中是可见的（包括所有子节点和子块）。
函数在整个块中是可见的（甚至在其定义之前），
而变量只在 <code class="docutils literal notranslate"><span class="pre">变量声明</span></code> 之后的语句中可见。</p>
<p>特别是，变量不能在其自身变量声明的右侧被引用。
函数可以在其声明之前就被引用（如果它们是可见的）。</p>
<p>作为一般范围规则的一个例外，for 循环的 “init” 部分（第一个块）的范围延伸到for 循环的所有其他部分。
这意味着在init部分声明的变量（和函数）（但不在init部分的块内）在for循环的所有其他部分都是可见的。</p>
<p>在for循环的其他部分声明的标识符要遵守常规的句法范围规则。</p>
<p>这意味着一个for循环的形式 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">{</span> <span class="pre">I...</span> <span class="pre">}</span> <span class="pre">C</span> <span class="pre">{</span> <span class="pre">P...</span> <span class="pre">}</span> <span class="pre">{</span> <span class="pre">B...</span> <span class="pre">}</span></code> 等同于
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">I...</span> <span class="pre">for</span> <span class="pre">{}.</span> <span class="pre">C</span> <span class="pre">{</span> <span class="pre">P...</span> <span class="pre">}</span> <span class="pre">{</span> <span class="pre">B...</span>&#160; <span class="pre">}</span></code>.</p>
<p>函数的参数和返回参数在函数体中是可见的，其名称必须是不同的。</p>
<p>在函数内部，不可能引用一个在该函数之外声明的变量。</p>
<p>影子变量是不允许的，也就是说，您不能在另一个同名的标识符也可见的地方声明一个标识符，
即使因为它是在当前函数之外声明的而不可能引用它。</p>
</section>
<section id="id16">
<h4>形式规范<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>我们通过提供一个在AST的各个节点上重载的评估函数E来正式指定Yul。
由于内置函数可能有副作用，E接收两个状态对象和AST节点，并返回两个新的状态对象和数量不定的其他值。
这两个状态对象是全局状态对象（在EVM的背景下，它是区块链的内存、存储和状态）
和本地状态对象（本地变量的状态，即EVM中堆栈的一段）。</p>
<p>如果AST节点是一个语句，E返回两个状态对象和一个 “mode”，
该mode用于 <code class="docutils literal notranslate"><span class="pre">break</span></code>， <code class="docutils literal notranslate"><span class="pre">continue</span></code> 和 <code class="docutils literal notranslate"><span class="pre">leave</span></code> 语句。
如果AST节点是一个表达式，E返回两个状态对象和表达式所评估的数值。</p>
<p>全局状态的确切性质在这个高层次的描述中没有明确说明。
本地状态 <code class="docutils literal notranslate"><span class="pre">L</span></code> 是标识符 <code class="docutils literal notranslate"><span class="pre">i</span></code> 到值 <code class="docutils literal notranslate"><span class="pre">v</span></code> 的映射，表示为 <code class="docutils literal notranslate"><span class="pre">L[i]</span> <span class="pre">=</span> <span class="pre">v</span></code>。</p>
<p>对于标识符 <code class="docutils literal notranslate"><span class="pre">v</span></code>, 我们用 <code class="docutils literal notranslate"><span class="pre">$v</span></code> 作为标识符的名字。</p>
<p>我们将为 AST 节点使用解构符号。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>E(G, L, &lt;{St1, ..., Stn}&gt;: Block) =
    let G1, L1, mode = E(G, L, St1, ..., Stn)
    let L2 be a restriction of L1 to the identifiers of L
    G1, L2, mode
E(G, L, St1, ..., Stn: Statement) =
    if n is zero:
        G, L, regular
    else:
        let G1, L1, mode = E(G, L, St1)
        if mode is regular then
            E(G1, L1, St2, ..., Stn)
        otherwise
            G1, L1, mode
E(G, L, FunctionDefinition) =
    G, L, regular
E(G, L, &lt;let var_1, ..., var_n := rhs&gt;: VariableDeclaration) =
    E(G, L, &lt;var_1, ..., var_n := rhs&gt;: Assignment)
E(G, L, &lt;let var_1, ..., var_n&gt;: VariableDeclaration) =
    let L1 be a copy of L where L1[$var_i] = 0 for i = 1, ..., n
    G, L1, regular
E(G, L, &lt;var_1, ..., var_n := rhs&gt;: Assignment) =
    let G1, L1, v1, ..., vn = E(G, L, rhs)
    let L2 be a copy of L1 where L2[$var_i] = vi for i = 1, ..., n
    G1, L2, regular
E(G, L, &lt;for { i1, ..., in } condition post body&gt;: ForLoop) =
    if n &gt;= 1:
        let G1, L1, mode = E(G, L, i1, ..., in)
        // 由于语法限制，mode 必须是规则的
        if mode is leave then
            G1, L1 restricted to variables of L, leave
        otherwise
            let G2, L2, mode = E(G1, L1, for {} condition post body)
            G2, L2 restricted to variables of L, mode
    else:
        let G1, L1, v = E(G, L, condition)
        if v is false:
            G1, L1, regular
        else:
            let G2, L2, mode = E(G1, L, body)
            if mode is break:
                G2, L2, regular
            otherwise if mode is leave:
                G2, L2, leave
            else:
                G3, L3, mode = E(G2, L2, post)
                if mode is leave:
                    G3, L3, leave
                otherwise
                    E(G3, L3, for {} condition post body)
E(G, L, break: BreakContinue) =
    G, L, break
E(G, L, continue: BreakContinue) =
    G, L, continue
E(G, L, leave: Leave) =
    G, L, leave
E(G, L, &lt;if condition body&gt;: If) =
    let G0, L0, v = E(G, L, condition)
    if v is true:
        E(G0, L0, body)
    else:
        G0, L0, regular
E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn&gt;: Switch) =
    E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default {})
E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn default st&#39;&gt;: Switch) =
    let G0, L0, v = E(G, L, condition)
    // i = 1 .. n
    // 对字面量求值，上下文无关
    let _, _, v1 = E(G0, L0, l1)
    ...
    let _, _, vn = E(G0, L0, ln)
    if there exists smallest i such that vi = v:
        E(G0, L0, sti)
    else:
        E(G0, L0, st&#39;)

E(G, L, &lt;name&gt;: Identifier) =
    G, L, L[$name]
E(G, L, &lt;fname(arg1, ..., argn)&gt;: FunctionCall) =
    G1, L1, vn = E(G, L, argn)
    ...
    G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)
    Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)
    Let &lt;function fname (param1, ..., paramn) -&gt; ret1, ..., retm block&gt;
    be the function of name $fname visible at the point of the call.
    Let L&#39; be a new local state such that
    L&#39;[$parami] = vi and L&#39;[$reti] = 0 for all i.
    Let G&#39;&#39;, L&#39;&#39;, mode = E(Gn, L&#39;, block)
    G&#39;&#39;, Ln, L&#39;&#39;[$ret1], ..., L&#39;&#39;[$retm]
E(G, L, l: StringLiteral) = G, L, str(l),
    where str is the string evaluation function,
    which for the EVM dialect is defined in the section &#39;Literals&#39; above
E(G, L, n: HexNumber) = G, L, hex(n)
    where hex is the hexadecimal evaluation function,
    which turns a sequence of hexadecimal digits into their big endian value
E(G, L, n: DecimalNumber) = G, L, dec(n),
    where dec is the decimal evaluation function,
    which turns a sequence of decimal digits into their big endian value
</pre></div>
</div>
</section>
<section id="evm">
<span id="opcodes"></span><h4>EVM语言<a class="headerlink" href="#evm" title="此标题的永久链接"></a></h4>
<p>目前Yul的默认语言是当前选择的EVM版本的EVM语言，与EVM的一个版本。
该语言中唯一可用的类型是 <code class="docutils literal notranslate"><span class="pre">u256</span></code>，即Ethereum虚拟机的256位本地类型。
因为它是该语言的默认类型，所以可以省略。</p>
<p>下表列出了所有内置函数（取决于EVM版本），并提供了函数/操作码的语义的简短描述。
本文件并不想成为以太坊虚拟机的完整描述。如果您对精确的语义感兴趣，请参考另一份文件。</p>
<p>标有 <code class="docutils literal notranslate"><span class="pre">-</span></code> 的操作码不返回结果，所有其他操作码正好返回一个值。
标有 <code class="docutils literal notranslate"><span class="pre">F</span></code>， <code class="docutils literal notranslate"><span class="pre">H</span></code>， <code class="docutils literal notranslate"><span class="pre">B</span></code>， <code class="docutils literal notranslate"><span class="pre">C</span></code>， <code class="docutils literal notranslate"><span class="pre">I</span></code> 和 <code class="docutils literal notranslate"><span class="pre">L</span></code> 的操作码分别
是从Frontier，Homestead，Byzantium，Constantinople，Istanbul或London版本出现的。</p>
<p>在下文中， <code class="docutils literal notranslate"><span class="pre">mem[a...b)</span></code> 表示从位置 <code class="docutils literal notranslate"><span class="pre">a</span></code> 开始到不包括位置 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的内存字节，
<code class="docutils literal notranslate"><span class="pre">storage[p]</span></code> 表示插槽 <code class="docutils literal notranslate"><span class="pre">p</span></code> 的存储内容。</p>
<p>由于Yul管理着局部变量和控制流，所以不能使用干扰这些功能的操作码。
这包括 <code class="docutils literal notranslate"><span class="pre">dup</span></code> 和 <code class="docutils literal notranslate"><span class="pre">swap</span></code> 指令，以及 <code class="docutils literal notranslate"><span class="pre">jump</span></code> 指令，标签和 <code class="docutils literal notranslate"><span class="pre">push</span></code> 指令。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>指令</p></th>
<th class="head"></th>
<th class="head"></th>
<th class="head"><p>解释</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>stop()</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>停止执行，与return(0, 0)相同</p></td>
</tr>
<tr class="row-odd"><td><p>add(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x + y</p></td>
</tr>
<tr class="row-even"><td><p>sub(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x - y</p></td>
</tr>
<tr class="row-odd"><td><p>mul(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x * y</p></td>
</tr>
<tr class="row-even"><td><p>div(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x / y 或 如果 y == 0，则为 0</p></td>
</tr>
<tr class="row-odd"><td><p>sdiv(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x / y，对于有符号的二进制补数，如果 y == 0，则为 0</p></td>
</tr>
<tr class="row-even"><td><p>mod(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x % y, 如果 y == 0，则为 0</p></td>
</tr>
<tr class="row-odd"><td><p>smod(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x % y, 对于有符号的二进制补数, 如果 y == 0，则为 0</p></td>
</tr>
<tr class="row-even"><td><p>exp(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x的y次方</p></td>
</tr>
<tr class="row-odd"><td><p>not(x)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x的位 &quot;非&quot;（x的每一个位都被否定）</p></td>
</tr>
<tr class="row-even"><td><p>lt(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>如果 x &lt; y，则为1，否则为0</p></td>
</tr>
<tr class="row-odd"><td><p>gt(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>如果 x &gt; y，则为1，否则为0</p></td>
</tr>
<tr class="row-even"><td><p>slt(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>如果 x &lt; y，则为1，否则为0，适用于有符号的二进制数</p></td>
</tr>
<tr class="row-odd"><td><p>sgt(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>如果 x &gt; y，则为1，否则为0，适用于有符号的二进制补数</p></td>
</tr>
<tr class="row-even"><td><p>eq(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>如果 x == y，则为1，否则为0</p></td>
</tr>
<tr class="row-odd"><td><p>iszero(x)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>如果 x == 0，则为1，否则为0</p></td>
</tr>
<tr class="row-even"><td><p>and(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x 和 y 的按位 &quot;与&quot;</p></td>
</tr>
<tr class="row-odd"><td><p>or(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x 和 y 的按位 &quot;或&quot;</p></td>
</tr>
<tr class="row-even"><td><p>xor(x, y)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x 和 y 的按位 &quot;异或&quot;</p></td>
</tr>
<tr class="row-odd"><td><p>byte(n, x)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>x的第n个字节，其中最重要的字节是第0个字节</p></td>
</tr>
<tr class="row-even"><td><p>shl(x, y)</p></td>
<td></td>
<td><p>C</p></td>
<td><p>将 y 逻辑左移 x 位</p></td>
</tr>
<tr class="row-odd"><td><p>shr(x, y)</p></td>
<td></td>
<td><p>C</p></td>
<td><p>将 y 逻辑右移 x 位</p></td>
</tr>
<tr class="row-even"><td><p>sar(x, y)</p></td>
<td></td>
<td><p>C</p></td>
<td><p>将 y 算术右移 x 位</p></td>
</tr>
<tr class="row-odd"><td><p>addmod(x, y, m)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>(x + y) % m，采用任意精度算术，如果m == 0则为0</p></td>
</tr>
<tr class="row-even"><td><p>mulmod(x, y, m)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>(x * y) % m，采用任意精度算术，如果m == 0则为0</p></td>
</tr>
<tr class="row-odd"><td><p>signextend(i, x)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>从第 (i*8+7) 位开始进行符号扩展，从最低符号位开始计算</p></td>
</tr>
<tr class="row-even"><td><p>keccak256(p, n)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>keccak(mem[p...(p+n)))</p></td>
</tr>
<tr class="row-odd"><td><p>pc()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>代码中的当前位置</p></td>
</tr>
<tr class="row-even"><td><p>pop(x)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>丢弃值 x</p></td>
</tr>
<tr class="row-odd"><td><p>mload(p)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>mem[p...(p+32))</p></td>
</tr>
<tr class="row-even"><td><p>mstore(p, v)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>mem[p...(p+32)) := v</p></td>
</tr>
<tr class="row-odd"><td><p>mstore8(p, v)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>mem[p] := v &amp; 0xff （(只修改了一个字节)）</p></td>
</tr>
<tr class="row-even"><td><p>sload(p)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>storage[p]</p></td>
</tr>
<tr class="row-odd"><td><p>sstore(p, v)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>storage[p] := v</p></td>
</tr>
<tr class="row-even"><td><p>msize()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>内存的大小，即最大的访问内存索引</p></td>
</tr>
<tr class="row-odd"><td><p>gas()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>仍可以执行的气体值</p></td>
</tr>
<tr class="row-even"><td><p>address()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>当前合约/执行环境的地址</p></td>
</tr>
<tr class="row-odd"><td><p>balance(a)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>地址为A的余额，以wei为单位</p></td>
</tr>
<tr class="row-even"><td><p>selfbalance()</p></td>
<td></td>
<td><p>I</p></td>
<td><p>相当于balance(address())，但更便宜</p></td>
</tr>
<tr class="row-odd"><td><p>caller()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>消息调用者（不包括 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 调用）。</p></td>
</tr>
<tr class="row-even"><td><p>callvalue()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>与当前调用一起发送的wei的数量</p></td>
</tr>
<tr class="row-odd"><td><p>calldataload(p)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>从位置p开始的调用数据（32字节）</p></td>
</tr>
<tr class="row-even"><td><p>calldatasize()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>调用数据的大小，以字节为单位</p></td>
</tr>
<tr class="row-odd"><td><p>calldatacopy(t, f, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>从位置f的calldata复制s字节到位置t的内存中</p></td>
</tr>
<tr class="row-even"><td><p>codesize()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>当前合约/执行环境的代码大小</p></td>
</tr>
<tr class="row-odd"><td><p>codecopy(t, f, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>从位置f的code中复制s字节到位置t的内存中</p></td>
</tr>
<tr class="row-even"><td><p>extcodesize(a)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>地址为a的代码的大小</p></td>
</tr>
<tr class="row-odd"><td><p>extcodecopy(a, t, f, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>像codecopy(t, f, s)一样，但在地址a处取代码</p></td>
</tr>
<tr class="row-even"><td><p>returndatasize()</p></td>
<td></td>
<td><p>B</p></td>
<td><p>最后返回数据的大小</p></td>
</tr>
<tr class="row-odd"><td><p>returndatacopy(t, f, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>B</p></td>
<td><p>从位置f的returndata复制s字节到位置t的内存中</p></td>
</tr>
<tr class="row-even"><td><p>extcodehash(a)</p></td>
<td></td>
<td><p>C</p></td>
<td><p>地址a的代码哈希值</p></td>
</tr>
<tr class="row-odd"><td><p>create(v, p, n)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>用代码mem[p...(p+n))创建新的合约，发送v数量的wei并返回新地址；
错误时返回0</p></td>
</tr>
<tr class="row-even"><td><p>create2(v, p, n, s)</p></td>
<td></td>
<td><p>C</p></td>
<td><p>在keccak256(0xff . this . s . keccak256(mem[p...(p+n)))地址处
创建代码为mem[p...(p+n)]的新合约
并发送v 数量个wei和返回新地址， 其中 <code class="docutils literal notranslate"><span class="pre">0xff</span></code> 是一个1字节的值，
<code class="docutils literal notranslate"><span class="pre">this</span></code> 是当前合约的地址，
是一个20字节的值， <code class="docutils literal notranslate"><span class="pre">s</span></code> 是一个256位的大端的值;
错误时返回0</p></td>
</tr>
<tr class="row-odd"><td><p>call(g, a, v, in,
insize, out, outsize)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>调用地址 a 上的合约，以 mem[in..(in+insize)) 作为输入
一并发送 g 数量的 gas 和 v 数量的 wei，
以 mem[out..(out+outsize)) 作为输出空间。 若错误，返回 0 （比如，gas 用光）
若成功，返回 1
<a class="reference internal" href="#yul-call-return-area"><span class="std std-ref">查看更多</span></a></p></td>
</tr>
<tr class="row-even"><td><p>callcode(g, a, v, in,
insize, out, outsize)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">call</span></code>  但仅仅使用地址 a 上的代码，
执行时留在当前合约的上下文当中
<a class="reference internal" href="#yul-call-return-area"><span class="std std-ref">查看更多</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>delegatecall(g, a, in,
insize, out, outsize)</p></td>
<td></td>
<td><p>H</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">callcode</span></code>, 但同时保留 <code class="docutils literal notranslate"><span class="pre">caller</span></code>
和 <code class="docutils literal notranslate"><span class="pre">callvalue</span></code>
<a class="reference internal" href="#yul-call-return-area"><span class="std std-ref">查看更多</span></a></p></td>
</tr>
<tr class="row-even"><td><p>staticcall(g, a, in,
insize, out, outsize)</p></td>
<td></td>
<td><p>B</p></td>
<td><p>相当于 <code class="docutils literal notranslate"><span class="pre">call(g,</span> <span class="pre">a,</span> <span class="pre">0,</span> <span class="pre">in,</span> <span class="pre">insize,</span> <span class="pre">out,</span> <span class="pre">outsize)</span></code>
但不允许状态变量的修改
<a class="reference internal" href="#yul-call-return-area"><span class="std std-ref">查看更多</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>return(p, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>终止执行，返回 mem[p..(p+s)) 上的数据</p></td>
</tr>
<tr class="row-even"><td><p>revert(p, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>B</p></td>
<td><p>终止执行，恢复状态变更，返回 mem[p..(p+s)) 上的数据</p></td>
</tr>
<tr class="row-odd"><td><p>selfdestruct(a)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>终止执行，销毁当前合约，并且将余额发送到地址 a</p></td>
</tr>
<tr class="row-even"><td><p>invalid()</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>以无效指令终止执行</p></td>
</tr>
<tr class="row-odd"><td><p>log0(p, s)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>用 mem[p..(p+s)] 上的数据产生日志，但没有 topic</p></td>
</tr>
<tr class="row-even"><td><p>log1(p, s, t1)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>用 mem[p..(p+s)] 上的数据和 topic t1 产生日志</p></td>
</tr>
<tr class="row-odd"><td><p>log2(p, s, t1, t2)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>用 mem[p..(p+s)] 上的数据和 topic t1，t2 产生日志</p></td>
</tr>
<tr class="row-even"><td><p>log3(p, s, t1, t2, t3)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>用 mem[p..(p+s)] 上的数据和 topic t1，t2，t3 产生日志</p></td>
</tr>
<tr class="row-odd"><td><p>log4(p, s, t1, t2, t3,
t4)</p></td>
<td><p><cite>-</cite></p></td>
<td><p>F</p></td>
<td><p>用 mem[p..(p+s)] 上的数据和 topic t1，t2，t3，t4 产生日志</p></td>
</tr>
<tr class="row-even"><td><p>chainid()</p></td>
<td></td>
<td><p>I</p></td>
<td><p>执行链的ID（EIP-1344）</p></td>
</tr>
<tr class="row-odd"><td><p>basefee()</p></td>
<td></td>
<td><p>L</p></td>
<td><p>当前区块的基本费用（EIP-3198和EIP-1559）</p></td>
</tr>
<tr class="row-even"><td><p>origin()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>交易发送者</p></td>
</tr>
<tr class="row-odd"><td><p>gasprice()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>交易的气体价格n</p></td>
</tr>
<tr class="row-even"><td><p>blockhash(b)</p></td>
<td></td>
<td><p>F</p></td>
<td><p>区块编号b的哈希值--只针对最近的256个区块，不包括当前区块。</p></td>
</tr>
<tr class="row-odd"><td><p>coinbase()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>目前的挖矿的受益者</p></td>
</tr>
<tr class="row-even"><td><p>timestamp()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>自 epoch 开始的，当前块的时间戳，以秒为单位</p></td>
</tr>
<tr class="row-odd"><td><p>number()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>当前区块号</p></td>
</tr>
<tr class="row-even"><td><p>difficulty()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>当前区块的难度</p></td>
</tr>
<tr class="row-odd"><td><p>gaslimit()</p></td>
<td></td>
<td><p>F</p></td>
<td><p>当前区块的区块 gas 限制</p></td>
</tr>
</tbody>
</table>
<div class="admonition note" id="yul-call-return-area">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">call*</span></code> 指令使用 <code class="docutils literal notranslate"><span class="pre">out</span></code> 和 <code class="docutils literal notranslate"><span class="pre">outsize</span></code> 参数来在内存中定义的一个区域，
用于放置返回或失败数据。这个区域的写入取决于被调用的合约返回多少字节。
如果它返回更多的数据，只有第一个 <code class="docutils literal notranslate"><span class="pre">outsize</span></code> 字节被写入。您可以使用 <code class="docutils literal notranslate"><span class="pre">returndatacopy</span></code> 操作码访问其余的数据。
如果它返回较少的数据，那么剩下的字节根本不被触及。
您需要使用 <code class="docutils literal notranslate"><span class="pre">returndatacopy</span></code> 操作码来检查这个内存区域的哪一部分包含返回数据。
剩下的字节将保留调用前的值。</p>
</div>
<p>在一些内部语言中，还有一些额外的函数：</p>
<section id="datasize-dataoffset-datacopy">
<h5>datasize, dataoffset, datacopy<a class="headerlink" href="#datasize-dataoffset-datacopy" title="此标题的永久链接"></a></h5>
<p>函数 <code class="docutils literal notranslate"><span class="pre">datasize(x)</span></code>， <code class="docutils literal notranslate"><span class="pre">dataoffset(x)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">datacopy(t,</span> <span class="pre">f,</span> <span class="pre">l)</span></code> 用来访问Yul对象的其他部分。</p>
<p><code class="docutils literal notranslate"><span class="pre">datasize</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dataoffset</span></code> 只能接受字符串字面量（其他对象的名称）作为参数，
并分别返回数据区的大小和偏移量。
对于EVM， <code class="docutils literal notranslate"><span class="pre">datacopy</span></code> 函数等同于 <code class="docutils literal notranslate"><span class="pre">codecopy</span></code>。</p>
</section>
<section id="setimmutable-loadimmutable">
<h5>setimmutable, loadimmutable<a class="headerlink" href="#setimmutable-loadimmutable" title="此标题的永久链接"></a></h5>
<p>函数 <code class="docutils literal notranslate"><span class="pre">setimmutable(offset,</span> <span class="pre">&quot;name&quot;,</span> <span class="pre">value)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">loadimmutable(&quot;name&quot;)</span></code> 用于Solidity中的不可变机制，
不能很好地映射到纯Yul。
对 <code class="docutils literal notranslate"><span class="pre">setimmutable(offset,</span> <span class="pre">&quot;name&quot;,</span> <span class="pre">value)</span></code> 的调用假定包含给定不可变的命名的合约的运行时代码
在偏移量 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 处被复制到内存中，并将把 <code class="docutils literal notranslate"><span class="pre">value</span></code> 写到内存中的所有位置（相对于 <code class="docutils literal notranslate"><span class="pre">offset</span></code>），
这些位置包含在运行时代码中为调用 <code class="docutils literal notranslate"><span class="pre">loadimmutable(&quot;name&quot;)</span></code> 产生的占位符。</p>
</section>
<section id="linkersymbol">
<h5>linkersymbol<a class="headerlink" href="#linkersymbol" title="此标题的永久链接"></a></h5>
<p>函数 <code class="docutils literal notranslate"><span class="pre">linkersymbol(&quot;library_id&quot;)</span></code> 是一个占位符，用来表示被链接器替换的地址字头。
它的第一个也是唯一的参数必须是一个字符串字面量，并且唯一地代表要插入的地址。
标识符可以是任意的，但是当编译器从Solidity源产生Yul代码时，它使用一个库名，
并以定义该库的源单元的名称作为限定。
要用一个特定的库地址链接代码，必须在命令行上的 <code class="docutils literal notranslate"><span class="pre">--libraries</span></code> 选项中提供相同的标识符。</p>
<p>例如，这段代码</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IGEgOj0gbGlua2Vyc3ltYm9sKCJmaWxlLnNvbDpNYXRoIik="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="n">linkersymbol</span><span class="p">(</span><span class="s">&quot;file.sol:Math&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>相当于</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IGEgOj0gMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkw"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">a</span> <span class="o">:=</span> <span class="mh">0x1234567890123456789012345678901234567890</span>
</pre></div>
</div>
<p>当使用 <code class="docutils literal notranslate"><span class="pre">--libraries</span> <span class="pre">&quot;file.sol:Math=0x1234567890123456789012345678901234567890</span></code> 选项调用链接器时。</p>
<p>请参阅 <a class="reference internal" href="index.html#commandline-compiler"><span class="std std-ref">使用命令行编译器</span></a> 以了解有关 Solidity 链接器的详情。</p>
</section>
<section id="memoryguard">
<h5>memoryguard<a class="headerlink" href="#memoryguard" title="此标题的永久链接"></a></h5>
<p>调用 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">ptr</span> <span class="pre">:=</span> <span class="pre">memoryguard(size)</span></code> 的调用者（其中 <code class="docutils literal notranslate"><span class="pre">size</span></code> 必须是一个数字字面量）
承诺他们只使用 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">size]</span></code> 范围内的内存，或者从 <code class="docutils literal notranslate"><span class="pre">ptr</span></code> 开始的无界范围。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">memoryguard</span></code> 调用的存在表明所有的内存访问都遵守这一限制，
它允许优化器执行额外的优化步骤，
例如堆栈限制规避器，它试图将原本无法到达的堆栈变量转移到内存中。</p>
<p>Yul优化器承诺只使用内存范围 <code class="docutils literal notranslate"><span class="pre">[size,</span> <span class="pre">ptr)</span></code> 来实现其目的。
如果优化器不需要保留任何内存，它认为 <code class="docutils literal notranslate"><span class="pre">ptr</span> <span class="pre">==</span> <span class="pre">size</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">memoryguard</span></code> 可以被多次调用，但是需要在一个Yul子对象内有相同的字样作为参数。
如果在一个子对象中发现至少一个 <code class="docutils literal notranslate"><span class="pre">memoryguard</span></code> 的调用，额外的优化步骤将在它身上运行。</p>
</section>
<section id="verbatim">
<span id="yul-verbatim"></span><h5>verbatim<a class="headerlink" href="#verbatim" title="此标题的永久链接"></a></h5>
<p>一组 <code class="docutils literal notranslate"><span class="pre">verbatim...</span></code> 内置函数可以让您为Yul编译器不知道的操作码创建字节码。
它还允许您创建不会被优化器修改的字节码序列。</p>
<p>这些函数是 <code class="docutils literal notranslate"><span class="pre">verbatim_&lt;n&gt;i_&lt;m&gt;o(&quot;&lt;data&gt;&quot;,</span> <span class="pre">...)</span></code>，其中</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> 是一个介于0和99之间的小数，指定输入栈槽/变量的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m</span></code> 是一个介于0和99之间的小数，指定输出栈槽/变量的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> 是一个字符串字面量，包含字节的序列</p></li>
</ul>
<p>例如，如果您想定义一个函数，将输入值乘以2，而不需要优化器触及常数2，您可以使用</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCmxldCBkb3VibGUgOj0gdmVyYmF0aW1fMWlfMW8oaGV4IjYwMDIwMiIsIHgp"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="ow">let</span> <span class="nv">double</span> <span class="o">:=</span> <span class="n">verbatim_1i_1o</span><span class="p">(</span><span class="s">hex&quot;600202&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>这段代码将产生一个 <code class="docutils literal notranslate"><span class="pre">dup1</span></code> 操作码来检索 <code class="docutils literal notranslate"><span class="pre">x</span></code>
（尽管优化器可能直接重新使用 <code class="docutils literal notranslate"><span class="pre">calldataload</span></code> 操作码的结果），
后面直接是 <code class="docutils literal notranslate"><span class="pre">600202</span></code>。该代码被假定为消耗 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的复制值，并在堆栈顶部产生结果。
然后编译器生成代码，为 <code class="docutils literal notranslate"><span class="pre">double</span></code> 分配一个堆栈槽，并将结果存储在那里。</p>
<p>与所有的操作码一样，参数被安排在堆栈中，最左边的参数在最上面，
而返回值则被假定是以最右边的变量在栈顶的方式排列的。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">verbatim</span></code> 可以用来生成任意的操作码，甚至是Solidity编译器不知道的操作码，
在与优化器一起使用 <code class="docutils literal notranslate"><span class="pre">verbatim</span></code> 时，必须小心。
即使优化器被关闭，代码生成器也必须确定堆栈布局，这意味着，例如，
使用 <code class="docutils literal notranslate"><span class="pre">verbatim</span></code> 来修改堆栈高度会导致未定义行为。</p>
<p>下面是一个不完全的列表，列出了对逐字字节码的限制，
这些限制不被编译器检查。违反这些限制会导致未定义的行为。</p>
<ul class="simple">
<li><p>控制流不应该跳入或跳出 verbatim 块，但它可以在同一个 verbatim 块内跳入。</p></li>
<li><p>除了输入和输出参数外，堆栈内容不应该被访问。</p></li>
<li><p>堆栈的高度差应该正好是 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span></code> （输出槽减去输入槽）。</p></li>
<li><p>Verbatim字节码不能对周围的字节码做任何假设。
所有需要的参数都必须作为堆栈变量传入。</p></li>
</ul>
<p>优化器不分析 verbatim 字节码，总是假设它修改了状态的所有方面，
因此只能在 <code class="docutils literal notranslate"><span class="pre">verbatim</span></code> 函数调用中做很少的优化。</p>
<p>优化器将 verbatim 字节码视为一个不透明的代码块。它不会分割它，
但可能会移动、重复或与相同的 verbatim 字节码块结合。
如果一个 verbatim 的字节码块不能被控制流所触及。
它可以被删除。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在讨论EVM的改进是否会破坏现有的智能合约时，
<code class="docutils literal notranslate"><span class="pre">verbatim</span></code> 内部的功能不能得到与Solidity编译器本身使用的功能一样的考虑。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为了避免混淆，所有以字符串 <code class="docutils literal notranslate"><span class="pre">verbatim</span></code> 开头的标识符都被保留，
不能用于用户定义的标识符。</p>
</div>
</section>
</section>
</section>
<section id="yul-object">
<span id="id17"></span><h3>Yul对象的规范<a class="headerlink" href="#yul-object" title="此标题的永久链接"></a></h3>
<p>Yul对象被用来分组命名代码和数据部分。
函数 <code class="docutils literal notranslate"><span class="pre">datasize</span></code>， <code class="docutils literal notranslate"><span class="pre">dataoffset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">datacopy</span></code> 可以用来从代码中访问这些部分。
十六进制字符串可用于指定十六进制编码的数据，
普通字符串为本地编码。对于代码，
<code class="docutils literal notranslate"><span class="pre">datacopy</span></code> 将访问其组装的二进制所表示的数据。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>对象 = &#39;object&#39; 字面量 &#39;{&#39; 代码 ( 对象 | 数据 )* &#39;}&#39;
代码 = &#39;code&#39; 块
数据 = &#39;data&#39; 字面量 ( 十六进制字面量 | 字面量 )
十六进制字面量 = &#39;hex&#39; (&#39;&quot;&#39; ([0-9a-fA-F]{2})* &#39;&quot;&#39; | &#39;\&#39;&#39; ([0-9a-fA-F]{2})* &#39;\&#39;&#39;)
字面量 = &#39;&quot;&#39; ([^&quot;\r\n\\] | &#39;\\&#39; .)* &#39;&quot;&#39;
</pre></div>
</div>
<p>对于上面的 <code class="docutils literal notranslate"><span class="pre">Block</span></code>，指的是前一章解释的Yul代码语法中的 <code class="docutils literal notranslate"><span class="pre">Block</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当一个对象的名称以 <code class="docutils literal notranslate"><span class="pre">_deployed</span></code> 结尾时，Yul 优化器将其视为部署的代码。
这样做的唯一后果是优化器中的不同 gas 成本启发式算法。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>可以定义名称中包含 <code class="docutils literal notranslate"><span class="pre">.</span></code> 的数据对象或子对象，
但不可能通过 <code class="docutils literal notranslate"><span class="pre">datasize</span></code>， <code class="docutils literal notranslate"><span class="pre">dataoffset</span></code> 或 <code class="docutils literal notranslate"><span class="pre">datacopy</span></code> 访问它们，
因为 <code class="docutils literal notranslate"><span class="pre">.</span></code> 是作为分隔符用来访问另一个对象内的对象。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>被称为 <code class="docutils literal notranslate"><span class="pre">&quot;.metadata&quot;</span></code> 的数据对象有特殊意义：
它不能从代码中访问，并且总是被附加到字节码的最末端，
无论它在对象中的位置如何。</p>
<p>其他具有特殊意义的数据对象在未来可能会被添加，
但它们的名字总是以 <code class="docutils literal notranslate"><span class="pre">.</span></code> 开头。</p>
</div>
<p>下面是一个Yul对象的例子：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=Ly8g5LiA5Liq5ZCI57qm55Sx5LiA5Liq5Y2V5LiA55qE5a+56LGh57uE5oiQ77yMCi8vIOWFtuWtkOWvueixoeS7o+ihqOimgemDqOe9sueahOS7o+eggeaIluWug+WPr+S7peWIm+W7uueahOWFtuS7luWQiOe6puOAggovLyDljZXkuKog4oCc5Luj56CB4oCdIOiKgueCueaYr+ivpeWvueixoeeahOWPr+aJp+ihjOS7o+eggeOAggovLyDmr4/kuIDkuKrvvIjlhbbku5bvvInlkb3lkI3nmoTlr7nosaHmiJbmlbDmja7pg6jliIbpg73ooqvluo/liJfljJbvvIwKLy8g5bm26KKr54m55q6K55qE5YaF572u5Ye95pWwIGRhdGFjb3B5IC8gZGF0YW9mZnNldCAvIGRhdGFzaXplIOaJgOiuv+mXrgovLyDlvZPliY3lr7nosaHjgIHlrZDlr7nosaHlkozlvZPliY3lr7nosaHlhoXnmoTmlbDmja7pobnpg73lnKjojIPlm7TlhoXjgIIKb2JqZWN0ICJDb250cmFjdDEiIHsKICAgIC8vIOi/meaYr+WQiOe6pueahOaehOmAoOWHveaVsOS7o+eggeOAggogICAgY29kZSB7CiAgICAgICAgZnVuY3Rpb24gYWxsb2NhdGUoc2l6ZSkgLT4gcHRyIHsKICAgICAgICAgICAgcHRyIDo9IG1sb2FkKDB4NDApCiAgICAgICAgICAgIC8vIOivt+azqOaEj++8jFNvbGlkaXR5IOeUn+aIkOeahCBJUiDku6PnoIHkuZ/kv53nlZnkuoblhoXlrZjlgY/np7vph48gYGAweDYwYGDvvIzkvYbkuIDkuKrnuq8gWXVsIOWvueixoeWPr+S7peiHqueUseWcsOS9v+eUqOWGheWtmOOAggogICAgICAgICAgICBpZiBpc3plcm8ocHRyKSB7IHB0ciA6PSAweDYwIH0KICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChwdHIsIHNpemUpKQogICAgICAgIH0KCiAgICAgICAgLy8g6aaW5YWI5Yib5bu6IOKAnENvbnRyYWN0MuKAnQogICAgICAgIGxldCBzaXplIDo9IGRhdGFzaXplKCJDb250cmFjdDIiKQogICAgICAgIGxldCBvZmZzZXQgOj0gYWxsb2NhdGUoc2l6ZSkKICAgICAgICAvLyDov5nlsIbovazljJbkuLpFVk3nmoTku6PnoIHmi7fotJ3jgIIKICAgICAgICBkYXRhY29weShvZmZzZXQsIGRhdGFvZmZzZXQoIkNvbnRyYWN0MiIpLCBzaXplKQogICAgICAgIC8vIOaehOmAoOWHveaVsOWPguaVsOaYr+S4gOS4quWNleS4gOeahOaVsOWtlyAweDEyMzQKICAgICAgICBtc3RvcmUoYWRkKG9mZnNldCwgc2l6ZSksIDB4MTIzNCkKICAgICAgICBwb3AoY3JlYXRlKG9mZnNldCwgYWRkKHNpemUsIDMyKSwgMCkpCgogICAgICAgIC8vIOeOsOWcqOi/lOWbnui/kOihjOaXtuWvueixoQogICAgICAgIC8vIOW9k+WJjeaJp+ihjOeahOS7o+eggeaYr+aehOmAoOWHveaVsOS7o+egge+8ieOAggogICAgICAgIHNpemUgOj0gZGF0YXNpemUoIkNvbnRyYWN0MV9kZXBsb3llZCIpCiAgICAgICAgb2Zmc2V0IDo9IGFsbG9jYXRlKHNpemUpCiAgICAgICAgLy8g6L+Z5bCG5Y+Y5oiQIEV3YXNtIOeahCDlhoXlrZgtPuWGheWtmCDlpI3liLYKICAgICAgICAvLyDlkowgRVZNIOeahOS7o+eggeWkjeWItuOAggogICAgICAgIGRhdGFjb3B5KG9mZnNldCwgZGF0YW9mZnNldCgiQ29udHJhY3QxX2RlcGxveWVkIiksIHNpemUpCiAgICAgICAgcmV0dXJuKG9mZnNldCwgc2l6ZSkKICAgIH0KCiAgICBkYXRhICJUYWJsZTIiIGhleCI0MTIzIgoKICAgIG9iamVjdCAiQ29udHJhY3QxX2RlcGxveWVkIiB7CiAgICAgICAgY29kZSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG9jYXRlKHNpemUpIC0+IHB0ciB7CiAgICAgICAgICAgICAgICBwdHIgOj0gbWxvYWQoMHg0MCkKICAgICAgICAgICAgICAgIC8vIOivt+azqOaEj++8jFNvbGlkaXR5IOeUn+aIkOeahCBJUiDku6PnoIHkuZ/kv53nlZnkuoblhoXlrZjlgY/np7vph48gYGAweDYwYGDvvIzkvYbkuIDkuKrnuq8gWXVsIOWvueixoeWPr+S7peiHqueUseWcsOS9v+eUqOWGheWtmOOAggogICAgICAgICAgICAgICAgaWYgaXN6ZXJvKHB0cikgeyBwdHIgOj0gMHg2MCB9CiAgICAgICAgICAgICAgICBtc3RvcmUoMHg0MCwgYWRkKHB0ciwgc2l6ZSkpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIOi/kOihjOaXtuS7o+eggQoKICAgICAgICAgICAgbXN0b3JlKDAsICJIZWxsbywgV29ybGQhIikKICAgICAgICAgICAgcmV0dXJuKDAsIDB4MjApCiAgICAgICAgfQogICAgfQoKICAgIC8vIOW1jOWFpeWvueixoeOAguS9v+eUqOaDheWGteaYr++8jOWklumdouaYr+S4gOS4quW3peWOguWQiOe6pu+8jAogICAgLy8g6ICMIENvbnRyYWN0MiDmmK/nlLHlt6XljoLliJvlu7rnmoTku6PnoIHjgIIKICAgIG9iamVjdCAiQ29udHJhY3QyIiB7CiAgICAgICAgY29kZSB7CiAgICAgICAgICAgIC8vIOatpOWkhOaYr+S7o+eggSAuLi4KICAgICAgICB9CgogICAgICAgIG9iamVjdCAiQ29udHJhY3QyX2RlcGxveWVkIiB7CiAgICAgICAgICAgIGNvZGUgewogICAgICAgICAgICAgICAgLy8g5q2k5aSE5piv5Luj56CBIC4uLgogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBkYXRhICJUYWJsZTEiIGhleCI0MTIzIgogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="c1">// 一个合约由一个单一的对象组成，</span>
<span class="c1">// 其子对象代表要部署的代码或它可以创建的其他合约。</span>
<span class="c1">// 单个 “代码” 节点是该对象的可执行代码。</span>
<span class="c1">// 每一个（其他）命名的对象或数据部分都被序列化，</span>
<span class="c1">// 并被特殊的内置函数 datacopy / dataoffset / datasize 所访问</span>
<span class="c1">// 当前对象、子对象和当前对象内的数据项都在范围内。</span>
<span class="k">object</span> <span class="s">&quot;Contract1&quot;</span> <span class="p">{</span>
    <span class="c1">// 这是合约的构造函数代码。</span>
    <span class="k">code</span> <span class="p">{</span>
        <span class="k">function</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ptr</span> <span class="p">{</span>
            <span class="n">ptr</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
            <span class="c1">// 请注意，Solidity 生成的 IR 代码也保留了内存偏移量 ``0x60``，但一个纯 Yul 对象可以自由地使用内存。</span>
            <span class="k">if</span> <span class="nf">iszero</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">ptr</span> <span class="o">:=</span> <span class="mh">0x60</span> <span class="p">}</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="c1">// 首先创建 “Contract2”</span>
        <span class="ow">let</span> <span class="nv">size</span> <span class="o">:=</span> <span class="k k-Function">datasize</span><span class="p">(</span><span class="s">&quot;Contract2&quot;</span><span class="p">)</span>
        <span class="ow">let</span> <span class="nv">offset</span> <span class="o">:=</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="c1">// 这将转化为EVM的代码拷贝。</span>
        <span class="k k-Function">datacopy</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="k k-Function">dataoffset</span><span class="p">(</span><span class="s">&quot;Contract2&quot;</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>
        <span class="c1">// 构造函数参数是一个单一的数字 0x1234</span>
        <span class="nf">mstore</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="mh">0x1234</span><span class="p">)</span>
        <span class="nf">pop</span><span class="p">(</span><span class="nf">create</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1">// 现在返回运行时对象</span>
        <span class="c1">// 当前执行的代码是构造函数代码）。</span>
        <span class="n">size</span> <span class="o">:=</span> <span class="k k-Function">datasize</span><span class="p">(</span><span class="s">&quot;Contract1_deployed&quot;</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">:=</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="c1">// 这将变成 Ewasm 的 内存-&gt;内存 复制</span>
        <span class="c1">// 和 EVM 的代码复制。</span>
        <span class="k k-Function">datacopy</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="k k-Function">dataoffset</span><span class="p">(</span><span class="s">&quot;Contract1_deployed&quot;</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>
        <span class="nf">return</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">data</span> <span class="s">&quot;Table2&quot;</span> <span class="s">hex&quot;4123&quot;</span>

    <span class="k">object</span> <span class="s">&quot;Contract1_deployed&quot;</span> <span class="p">{</span>
        <span class="k">code</span> <span class="p">{</span>
            <span class="k">function</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ptr</span> <span class="p">{</span>
                <span class="n">ptr</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
                <span class="c1">// 请注意，Solidity 生成的 IR 代码也保留了内存偏移量 ``0x60``，但一个纯 Yul 对象可以自由地使用内存。</span>
                <span class="k">if</span> <span class="nf">iszero</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">ptr</span> <span class="o">:=</span> <span class="mh">0x60</span> <span class="p">}</span>
                <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
            <span class="p">}</span>

            <span class="c1">// 运行时代码</span>

            <span class="nf">mstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Hello, World!&quot;</span><span class="p">)</span>
            <span class="nf">return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 嵌入对象。使用情况是，外面是一个工厂合约，</span>
    <span class="c1">// 而 Contract2 是由工厂创建的代码。</span>
    <span class="k">object</span> <span class="s">&quot;Contract2&quot;</span> <span class="p">{</span>
        <span class="k">code</span> <span class="p">{</span>
            <span class="c1">// 此处是代码 ...</span>
        <span class="p">}</span>

        <span class="k">object</span> <span class="s">&quot;Contract2_deployed&quot;</span> <span class="p">{</span>
            <span class="k">code</span> <span class="p">{</span>
                <span class="c1">// 此处是代码 ...</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">data</span> <span class="s">&quot;Table1&quot;</span> <span class="s">hex&quot;4123&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id18">
<h3>Yul 优化器<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h3>
<p>Yul优化器对Yul代码进行操作，并对输入、输出和中间状态使用相同的语言。这使得优化器的调试和验证变得容易。</p>
<p>请参考一般的 <a class="reference internal" href="index.html#optimizer"><span class="std std-ref">优化器文档</span></a>，以了解关于不同优化阶段和如何使用优化器的更多细节。</p>
<p>如果您想在独立的Yul模式下使用Solidity，您可以用 <code class="docutils literal notranslate"><span class="pre">--optimize</span></code> 激活优化器，
并可选择用 <code class="docutils literal notranslate"><span class="pre">--optimize-runs</span></code> 指定 <a class="reference internal" href="index.html#optimizer-parameter-runs"><span class="std std-ref">预期合约执行次数</span></a>：</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>--strict-assembly<span class="w"> </span>--optimize<span class="w"> </span>--optimize-runs<span class="w"> </span><span class="m">200</span>
</pre></div>
</div>
<p>在Solidity模式下，Yul优化器与常规优化器一起被激活。</p>
<section id="optimization-step-sequence">
<span id="id19"></span><h4>优化步骤顺序<a class="headerlink" href="#optimization-step-sequence" title="此标题的永久链接"></a></h4>
<p>默认情况下，Yul优化器将其预定义的优化步骤序列应用于生成的程序集。
您可以使用 <code class="docutils literal notranslate"><span class="pre">--yul-optimizations</span></code> 选项覆盖这个序列，并提供您自己的序列：</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>solc<span class="w"> </span>--optimize<span class="w"> </span>--ir-optimized<span class="w"> </span>--yul-optimizations<span class="w"> </span><span class="s1">&#39;dhfoD[xarrscLMcCTU]uljmul&#39;</span>
</pre></div>
</div>
<p>优化步骤的顺序很重要，会影响到输出的质量。
此外，应用一个步骤可能为其他已经应用的步骤发现新的优化机会，所以重复步骤往往是有益的。
通过用方括号（ <code class="docutils literal notranslate"><span class="pre">[]</span></code> ）包围序列的一部分，您告诉优化器重复应用该部分，
直到它不再改善优化结果的大小。您可以在一个序列中多次使用方括号，但它们不能被嵌套。</p>
<p>有以下优化步骤：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>缩写</p></th>
<th class="head"><p>全称</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">块展平器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">l</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">循环引用程序</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">通用子表达式消除器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">C</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">条件简化器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">U</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">有条件的非对称性放大器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">n</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">控制流简化器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">D</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">死代码消除器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">v</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">等价的存储清除器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">表达式内联</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">j</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">表达式连接器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">表达式简化器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">表达式拆分器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">I</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">循环条件进入正文</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">O</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">体外循环条件</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">循环初始重写器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">完全内联</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">函数分组器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">函数提升器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">F</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">函数特殊化器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">字面量再物质化器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">负载解析器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">M</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">循环不变代码模式</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">r</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">冗余赋值消除器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">基于推理的简化器</span></code> - 高度实验性</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">m</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">再物质化</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">V</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SSA反转器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SSA转换</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">结构简化器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">未使用过的处理器</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">未使用的函数参数管理器</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">初始化程序</span></code></p></td>
</tr>
</tbody>
</table>
<p>一些步骤依赖于 <code class="docutils literal notranslate"><span class="pre">块展平器</span></code>, <code class="docutils literal notranslate"><span class="pre">函数分组器</span></code>, <code class="docutils literal notranslate"><span class="pre">循环初始重写器</span></code> 所保证的属性。
由于这个原因，Yul优化器总是在应用用户提供的任何步骤之前应用它们。</p>
<p>基于推理的简化器 是一个优化器步骤，目前在默认步骤集中没有启用。
它使用一个SMT解算器来简化算术表达式和布尔条件。
它还没有得到彻底的测试或验证，可能会产生不可重现的结果，
所以请谨慎使用!</p>
</section>
</section>
<section id="erc20-yul">
<span id="erc20yul"></span><h3>完整的ERC20示例（基于yul）<a class="headerlink" href="#erc20-yul" title="此标题的永久链接"></a></h3>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=yul&amp;version=0.8.17&amp;code=b2JqZWN0ICJUb2tlbiIgewogICAgY29kZSB7CiAgICAgICAgLy8g5bCG5Yib5bu66ICF5a2Y5YKo5Zyo6Zu25Y+35qe95Lit44CCCiAgICAgICAgc3N0b3JlKDAsIGNhbGxlcigpKQoKICAgICAgICAvLyDpg6jnvbLlkIjnuqYKICAgICAgICBkYXRhY29weSgwLCBkYXRhb2Zmc2V0KCJydW50aW1lIiksIGRhdGFzaXplKCJydW50aW1lIikpCiAgICAgICAgcmV0dXJuKDAsIGRhdGFzaXplKCJydW50aW1lIikpCiAgICB9CiAgICBvYmplY3QgInJ1bnRpbWUiIHsKICAgICAgICBjb2RlIHsKICAgICAgICAgICAgLy8g6Ziy5q2i5Y+R6YCB5Lul5aSq55qE5L+d5oqk5o6q5pa9CiAgICAgICAgICAgIHJlcXVpcmUoaXN6ZXJvKGNhbGx2YWx1ZSgpKSkKCiAgICAgICAgICAgIC8vIOiwg+W6puWZqAogICAgICAgICAgICBzd2l0Y2ggc2VsZWN0b3IoKQogICAgICAgICAgICBjYXNlIDB4NzBhMDgyMzEgLyogImJhbGFuY2VPZihhZGRyZXNzKSIgKi8gewogICAgICAgICAgICAgICAgcmV0dXJuVWludChiYWxhbmNlT2YoZGVjb2RlQXNBZGRyZXNzKDApKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDB4MTgxNjBkZGQgLyogInRvdGFsU3VwcGx5KCkiICovIHsKICAgICAgICAgICAgICAgIHJldHVyblVpbnQodG90YWxTdXBwbHkoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDB4YTkwNTljYmIgLyogInRyYW5zZmVyKGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIHRyYW5zZmVyKGRlY29kZUFzQWRkcmVzcygwKSwgZGVjb2RlQXNVaW50KDEpKQogICAgICAgICAgICAgICAgcmV0dXJuVHJ1ZSgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAweDIzYjg3MmRkIC8qICJ0cmFuc2ZlckZyb20oYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpIiAqLyB7CiAgICAgICAgICAgICAgICB0cmFuc2ZlckZyb20oZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc0FkZHJlc3MoMSksIGRlY29kZUFzVWludCgyKSkKICAgICAgICAgICAgICAgIHJldHVyblRydWUoKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMHgwOTVlYTdiMyAvKiAiYXBwcm92ZShhZGRyZXNzLHVpbnQyNTYpIiAqLyB7CiAgICAgICAgICAgICAgICBhcHByb3ZlKGRlY29kZUFzQWRkcmVzcygwKSwgZGVjb2RlQXNVaW50KDEpKQogICAgICAgICAgICAgICAgcmV0dXJuVHJ1ZSgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAweGRkNjJlZDNlIC8qICJhbGxvd2FuY2UoYWRkcmVzcyxhZGRyZXNzKSIgKi8gewogICAgICAgICAgICAgICAgcmV0dXJuVWludChhbGxvd2FuY2UoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc0FkZHJlc3MoMSkpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMHg0MGMxMGYxOSAvKiAibWludChhZGRyZXNzLHVpbnQyNTYpIiAqLyB7CiAgICAgICAgICAgICAgICBtaW50KGRlY29kZUFzQWRkcmVzcygwKSwgZGVjb2RlQXNVaW50KDEpKQogICAgICAgICAgICAgICAgcmV0dXJuVHJ1ZSgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGVmYXVsdCB7CiAgICAgICAgICAgICAgICByZXZlcnQoMCwgMCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZnVuY3Rpb24gbWludChhY2NvdW50LCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIHJlcXVpcmUoY2FsbGVkQnlPd25lcigpKQoKICAgICAgICAgICAgICAgIG1pbnRUb2tlbnMoYW1vdW50KQogICAgICAgICAgICAgICAgYWRkVG9CYWxhbmNlKGFjY291bnQsIGFtb3VudCkKICAgICAgICAgICAgICAgIGVtaXRUcmFuc2ZlcigwLCBhY2NvdW50LCBhbW91bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNmZXIodG8sIGFtb3VudCkgewogICAgICAgICAgICAgICAgZXhlY3V0ZVRyYW5zZmVyKGNhbGxlcigpLCB0bywgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcHJvdmUoc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICByZXZlcnRJZlplcm9BZGRyZXNzKHNwZW5kZXIpCiAgICAgICAgICAgICAgICBzZXRBbGxvd2FuY2UoY2FsbGVyKCksIHNwZW5kZXIsIGFtb3VudCkKICAgICAgICAgICAgICAgIGVtaXRBcHByb3ZhbChjYWxsZXIoKSwgc3BlbmRlciwgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZmVyRnJvbShmcm9tLCB0bywgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBkZWNyZWFzZUFsbG93YW5jZUJ5KGZyb20sIGNhbGxlcigpLCBhbW91bnQpCiAgICAgICAgICAgICAgICBleGVjdXRlVHJhbnNmZXIoZnJvbSwgdG8sIGFtb3VudCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZVRyYW5zZmVyKGZyb20sIHRvLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIHJldmVydElmWmVyb0FkZHJlc3ModG8pCiAgICAgICAgICAgICAgICBkZWR1Y3RGcm9tQmFsYW5jZShmcm9tLCBhbW91bnQpCiAgICAgICAgICAgICAgICBhZGRUb0JhbGFuY2UodG8sIGFtb3VudCkKICAgICAgICAgICAgICAgIGVtaXRUcmFuc2Zlcihmcm9tLCB0bywgYW1vdW50KQogICAgICAgICAgICB9CgoKICAgICAgICAgICAgLyogLS0tLS0tLS0tLSBjYWxsZGF0YSDop6PnoIHlh73mlbAgLS0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0b3IoKSAtPiBzIHsKICAgICAgICAgICAgICAgIHMgOj0gZGl2KGNhbGxkYXRhbG9hZCgwKSwgMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDApCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZUFzQWRkcmVzcyhvZmZzZXQpIC0+IHYgewogICAgICAgICAgICAgICAgdiA6PSBkZWNvZGVBc1VpbnQob2Zmc2V0KQogICAgICAgICAgICAgICAgaWYgaXN6ZXJvKGlzemVybyhhbmQodiwgbm90KDB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZikpKSkgewogICAgICAgICAgICAgICAgICAgIHJldmVydCgwLCAwKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZUFzVWludChvZmZzZXQpIC0+IHYgewogICAgICAgICAgICAgICAgbGV0IHBvcyA6PSBhZGQoNCwgbXVsKG9mZnNldCwgMHgyMCkpCiAgICAgICAgICAgICAgICBpZiBsdChjYWxsZGF0YXNpemUoKSwgYWRkKHBvcywgMHgyMCkpIHsKICAgICAgICAgICAgICAgICAgICByZXZlcnQoMCwgMCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHYgOj0gY2FsbGRhdGFsb2FkKHBvcykKICAgICAgICAgICAgfQogICAgICAgICAgICAvKiAtLS0tLS0tLS0tIGNhbGxkYXRhIOe8lueggeWHveaVsCAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHVyblVpbnQodikgewogICAgICAgICAgICAgICAgbXN0b3JlKDAsIHYpCiAgICAgICAgICAgICAgICByZXR1cm4oMCwgMHgyMCkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkgewogICAgICAgICAgICAgICAgcmV0dXJuVWludCgxKQogICAgICAgICAgICB9CgogICAgICAgICAgICAvKiAtLS0tLS0tLSDkuovku7YgLS0tLS0tLS0tLSAqLwogICAgICAgICAgICBmdW5jdGlvbiBlbWl0VHJhbnNmZXIoZnJvbSwgdG8sIGFtb3VudCkgewogICAgICAgICAgICAgICAgbGV0IHNpZ25hdHVyZUhhc2ggOj0gMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmCiAgICAgICAgICAgICAgICBlbWl0RXZlbnQoc2lnbmF0dXJlSGFzaCwgZnJvbSwgdG8sIGFtb3VudCkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBlbWl0QXBwcm92YWwoZnJvbSwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlSGFzaCA6PSAweDhjNWJlMWU1ZWJlYzdkNWJkMTRmNzE0MjdkMWU4NGYzZGQwMzE0YzBmN2IyMjkxZTViMjAwYWM4YzdjM2I5MjUKICAgICAgICAgICAgICAgIGVtaXRFdmVudChzaWduYXR1cmVIYXNoLCBmcm9tLCBzcGVuZGVyLCBhbW91bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZW1pdEV2ZW50KHNpZ25hdHVyZUhhc2gsIGluZGV4ZWQxLCBpbmRleGVkMiwgbm9uSW5kZXhlZCkgewogICAgICAgICAgICAgICAgbXN0b3JlKDAsIG5vbkluZGV4ZWQpCiAgICAgICAgICAgICAgICBsb2czKDAsIDB4MjAsIHNpZ25hdHVyZUhhc2gsIGluZGV4ZWQxLCBpbmRleGVkMikKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLyogLS0tLS0tLS0g5a2Y5YKo5biD5bGAIC0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gb3duZXJQb3MoKSAtPiBwIHsgcCA6PSAwIH0KICAgICAgICAgICAgZnVuY3Rpb24gdG90YWxTdXBwbHlQb3MoKSAtPiBwIHsgcCA6PSAxIH0KICAgICAgICAgICAgZnVuY3Rpb24gYWNjb3VudFRvU3RvcmFnZU9mZnNldChhY2NvdW50KSAtPiBvZmZzZXQgewogICAgICAgICAgICAgICAgb2Zmc2V0IDo9IGFkZCgweDEwMDAsIGFjY291bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSAtPiBvZmZzZXQgewogICAgICAgICAgICAgICAgb2Zmc2V0IDo9IGFjY291bnRUb1N0b3JhZ2VPZmZzZXQoYWNjb3VudCkKICAgICAgICAgICAgICAgIG1zdG9yZSgwLCBvZmZzZXQpCiAgICAgICAgICAgICAgICBtc3RvcmUoMHgyMCwgc3BlbmRlcikKICAgICAgICAgICAgICAgIG9mZnNldCA6PSBrZWNjYWsyNTYoMCwgMHg0MCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLyogLS0tLS0tLS0g5a2Y5YKo6K6/6ZeuIC0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gb3duZXIoKSAtPiBvIHsKICAgICAgICAgICAgICAgIG8gOj0gc2xvYWQob3duZXJQb3MoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiB0b3RhbFN1cHBseSgpIC0+IHN1cHBseSB7CiAgICAgICAgICAgICAgICBzdXBwbHkgOj0gc2xvYWQodG90YWxTdXBwbHlQb3MoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBtaW50VG9rZW5zKGFtb3VudCkgewogICAgICAgICAgICAgICAgc3N0b3JlKHRvdGFsU3VwcGx5UG9zKCksIHNhZmVBZGQodG90YWxTdXBwbHkoKSwgYW1vdW50KSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBiYWxhbmNlT2YoYWNjb3VudCkgLT4gYmFsIHsKICAgICAgICAgICAgICAgIGJhbCA6PSBzbG9hZChhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFRvQmFsYW5jZShhY2NvdW50LCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgOj0gYWNjb3VudFRvU3RvcmFnZU9mZnNldChhY2NvdW50KQogICAgICAgICAgICAgICAgc3N0b3JlKG9mZnNldCwgc2FmZUFkZChzbG9hZChvZmZzZXQpLCBhbW91bnQpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlZHVjdEZyb21CYWxhbmNlKGFjY291bnQsIGFtb3VudCkgewogICAgICAgICAgICAgICAgbGV0IG9mZnNldCA6PSBhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpCiAgICAgICAgICAgICAgICBsZXQgYmFsIDo9IHNsb2FkKG9mZnNldCkKICAgICAgICAgICAgICAgIHJlcXVpcmUobHRlKGFtb3VudCwgYmFsKSkKICAgICAgICAgICAgICAgIHNzdG9yZShvZmZzZXQsIHN1YihiYWwsIGFtb3VudCkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFjY291bnQsIHNwZW5kZXIpIC0+IGFtb3VudCB7CiAgICAgICAgICAgICAgICBhbW91bnQgOj0gc2xvYWQoYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBzZXRBbGxvd2FuY2UoYWNjb3VudCwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBzc3RvcmUoYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSwgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY3JlYXNlQWxsb3dhbmNlQnkoYWNjb3VudCwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0IDo9IGFsbG93YW5jZVN0b3JhZ2VPZmZzZXQoYWNjb3VudCwgc3BlbmRlcikKICAgICAgICAgICAgICAgIGxldCBjdXJyZW50QWxsb3dhbmNlIDo9IHNsb2FkKG9mZnNldCkKICAgICAgICAgICAgICAgIHJlcXVpcmUobHRlKGFtb3VudCwgY3VycmVudEFsbG93YW5jZSkpCiAgICAgICAgICAgICAgICBzc3RvcmUob2Zmc2V0LCBzdWIoY3VycmVudEFsbG93YW5jZSwgYW1vdW50KSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLyogLS0tLS0tLS0tLSDlt6Xlhbflh73mlbAgLS0tLS0tLS0tLSAqLwogICAgICAgICAgICBmdW5jdGlvbiBsdGUoYSwgYikgLT4gciB7CiAgICAgICAgICAgICAgICByIDo9IGlzemVybyhndChhLCBiKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBndGUoYSwgYikgLT4gciB7CiAgICAgICAgICAgICAgICByIDo9IGlzemVybyhsdChhLCBiKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBzYWZlQWRkKGEsIGIpIC0+IHIgewogICAgICAgICAgICAgICAgciA6PSBhZGQoYSwgYikKICAgICAgICAgICAgICAgIGlmIG9yKGx0KHIsIGEpLCBsdChyLCBiKSkgeyByZXZlcnQoMCwgMCkgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxlZEJ5T3duZXIoKSAtPiBjYm8gewogICAgICAgICAgICAgICAgY2JvIDo9IGVxKG93bmVyKCksIGNhbGxlcigpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHJldmVydElmWmVyb0FkZHJlc3MoYWRkcikgewogICAgICAgICAgICAgICAgcmVxdWlyZShhZGRyKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHJlcXVpcmUoY29uZGl0aW9uKSB7CiAgICAgICAgICAgICAgICBpZiBpc3plcm8oY29uZGl0aW9uKSB7IHJldmVydCgwLCAwKSB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-yul notranslate"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="s">&quot;Token&quot;</span> <span class="p">{</span>
    <span class="k">code</span> <span class="p">{</span>
        <span class="c1">// 将创建者存储在零号槽中。</span>
        <span class="nf">sstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">caller</span><span class="p">())</span>

        <span class="c1">// 部署合约</span>
        <span class="k k-Function">datacopy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k k-Function">dataoffset</span><span class="p">(</span><span class="s">&quot;runtime&quot;</span><span class="p">),</span> <span class="k k-Function">datasize</span><span class="p">(</span><span class="s">&quot;runtime&quot;</span><span class="p">))</span>
        <span class="nf">return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k k-Function">datasize</span><span class="p">(</span><span class="s">&quot;runtime&quot;</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">object</span> <span class="s">&quot;runtime&quot;</span> <span class="p">{</span>
        <span class="k">code</span> <span class="p">{</span>
            <span class="c1">// 防止发送以太的保护措施</span>
            <span class="n">require</span><span class="p">(</span><span class="nf">iszero</span><span class="p">(</span><span class="nf">callvalue</span><span class="p">()))</span>

            <span class="c1">// 调度器</span>
            <span class="k">switch</span> <span class="n">selector</span><span class="p">()</span>
            <span class="k">case</span> <span class="mh">0x70a08231</span> <span class="cm">/* &quot;balanceOf(address)&quot; */</span> <span class="p">{</span>
                <span class="n">returnUint</span><span class="p">(</span><span class="n">balanceOf</span><span class="p">(</span><span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="mh">0x18160ddd</span> <span class="cm">/* &quot;totalSupply()&quot; */</span> <span class="p">{</span>
                <span class="n">returnUint</span><span class="p">(</span><span class="n">totalSupply</span><span class="p">())</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="mh">0xa9059cbb</span> <span class="cm">/* &quot;transfer(address,uint256)&quot; */</span> <span class="p">{</span>
                <span class="n">transfer</span><span class="p">(</span><span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">decodeAsUint</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">returnTrue</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="mh">0x23b872dd</span> <span class="cm">/* &quot;transferFrom(address,address,uint256)&quot; */</span> <span class="p">{</span>
                <span class="n">transferFrom</span><span class="p">(</span><span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">decodeAsUint</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">returnTrue</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="mh">0x095ea7b3</span> <span class="cm">/* &quot;approve(address,uint256)&quot; */</span> <span class="p">{</span>
                <span class="n">approve</span><span class="p">(</span><span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">decodeAsUint</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">returnTrue</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="mh">0xdd62ed3e</span> <span class="cm">/* &quot;allowance(address,address)&quot; */</span> <span class="p">{</span>
                <span class="n">returnUint</span><span class="p">(</span><span class="n">allowance</span><span class="p">(</span><span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="mh">0x40c10f19</span> <span class="cm">/* &quot;mint(address,uint256)&quot; */</span> <span class="p">{</span>
                <span class="n">mint</span><span class="p">(</span><span class="n">decodeAsAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">decodeAsUint</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">returnTrue</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="k">default</span> <span class="p">{</span>
                <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">function</span> <span class="n">mint</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">require</span><span class="p">(</span><span class="n">calledByOwner</span><span class="p">())</span>

                <span class="n">mintTokens</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
                <span class="n">addToBalance</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
                <span class="n">emitTransfer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">transfer</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">executeTransfer</span><span class="p">(</span><span class="nf">caller</span><span class="p">(),</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">approve</span><span class="p">(</span><span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">revertIfZeroAddress</span><span class="p">(</span><span class="n">spender</span><span class="p">)</span>
                <span class="n">setAllowance</span><span class="p">(</span><span class="nf">caller</span><span class="p">(),</span> <span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
                <span class="n">emitApproval</span><span class="p">(</span><span class="nf">caller</span><span class="p">(),</span> <span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">transferFrom</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">decreaseAllowanceBy</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="nf">caller</span><span class="p">(),</span> <span class="n">amount</span><span class="p">)</span>
                <span class="n">executeTransfer</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">function</span> <span class="n">executeTransfer</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">revertIfZeroAddress</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
                <span class="n">deductFromBalance</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
                <span class="n">addToBalance</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
                <span class="n">emitTransfer</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>


            <span class="cm">/* ---------- calldata 解码函数 ----------- */</span>
            <span class="k">function</span> <span class="n">selector</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="p">{</span>
                <span class="n">s</span> <span class="o">:=</span> <span class="nf">div</span><span class="p">(</span><span class="nf">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mh">0x100000000000000000000000000000000000000000000000000000000</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">function</span> <span class="n">decodeAsAddress</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="p">{</span>
                <span class="n">v</span> <span class="o">:=</span> <span class="n">decodeAsUint</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
                <span class="k">if</span> <span class="nf">iszero</span><span class="p">(</span><span class="nf">iszero</span><span class="p">(</span><span class="nf">and</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">not</span><span class="p">(</span><span class="mh">0xffffffffffffffffffffffffffffffffffffffff</span><span class="p">))))</span> <span class="p">{</span>
                    <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">decodeAsUint</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">pos</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))</span>
                <span class="k">if</span> <span class="nf">lt</span><span class="p">(</span><span class="nf">calldatasize</span><span class="p">(),</span> <span class="nf">add</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))</span> <span class="p">{</span>
                    <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">v</span> <span class="o">:=</span> <span class="nf">calldataload</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="cm">/* ---------- calldata 编码函数 ---------- */</span>
            <span class="k">function</span> <span class="n">returnUint</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">mstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="nf">return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">returnTrue</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">returnUint</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="cm">/* -------- 事件 ---------- */</span>
            <span class="k">function</span> <span class="n">emitTransfer</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">signatureHash</span> <span class="o">:=</span> <span class="mh">0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span>
                <span class="n">emitEvent</span><span class="p">(</span><span class="n">signatureHash</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">emitApproval</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">signatureHash</span> <span class="o">:=</span> <span class="mh">0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925</span>
                <span class="n">emitEvent</span><span class="p">(</span><span class="n">signatureHash</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">emitEvent</span><span class="p">(</span><span class="n">signatureHash</span><span class="p">,</span> <span class="n">indexed1</span><span class="p">,</span> <span class="n">indexed2</span><span class="p">,</span> <span class="n">nonIndexed</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">mstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nonIndexed</span><span class="p">)</span>
                <span class="nf">log3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">signatureHash</span><span class="p">,</span> <span class="n">indexed1</span><span class="p">,</span> <span class="n">indexed2</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="cm">/* -------- 存储布局 ---------- */</span>
            <span class="k">function</span> <span class="n">ownerPos</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="p">{</span> <span class="n">p</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="k">function</span> <span class="n">totalSupplyPos</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="p">{</span> <span class="n">p</span> <span class="o">:=</span> <span class="mi">1</span> <span class="p">}</span>
            <span class="k">function</span> <span class="n">accountToStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">offset</span> <span class="p">{</span>
                <span class="n">offset</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="n">account</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">allowanceStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">offset</span> <span class="p">{</span>
                <span class="n">offset</span> <span class="o">:=</span> <span class="n">accountToStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">)</span>
                <span class="nf">mstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
                <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">spender</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">:=</span> <span class="nf">keccak256</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="cm">/* -------- 存储访问 ---------- */</span>
            <span class="k">function</span> <span class="n">owner</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">o</span> <span class="p">{</span>
                <span class="n">o</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">ownerPos</span><span class="p">())</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">totalSupply</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">supply</span> <span class="p">{</span>
                <span class="n">supply</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">totalSupplyPos</span><span class="p">())</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">mintTokens</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">sstore</span><span class="p">(</span><span class="n">totalSupplyPos</span><span class="p">(),</span> <span class="n">safeAdd</span><span class="p">(</span><span class="n">totalSupply</span><span class="p">(),</span> <span class="n">amount</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">balanceOf</span><span class="p">(</span><span class="n">account</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bal</span> <span class="p">{</span>
                <span class="n">bal</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">accountToStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">addToBalance</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">offset</span> <span class="o">:=</span> <span class="n">accountToStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">)</span>
                <span class="nf">sstore</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">safeAdd</span><span class="p">(</span><span class="nf">sload</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="n">amount</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">deductFromBalance</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">offset</span> <span class="o">:=</span> <span class="n">accountToStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">)</span>
                <span class="ow">let</span> <span class="nv">bal</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
                <span class="n">require</span><span class="p">(</span><span class="n">lte</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">bal</span><span class="p">))</span>
                <span class="nf">sstore</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nf">sub</span><span class="p">(</span><span class="n">bal</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">allowance</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">amount</span> <span class="p">{</span>
                <span class="n">amount</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">allowanceStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">setAllowance</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">sstore</span><span class="p">(</span><span class="n">allowanceStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">),</span> <span class="n">amount</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">decreaseAllowanceBy</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">offset</span> <span class="o">:=</span> <span class="n">allowanceStorageOffset</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">spender</span><span class="p">)</span>
                <span class="ow">let</span> <span class="nv">currentAllowance</span> <span class="o">:=</span> <span class="nf">sload</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
                <span class="n">require</span><span class="p">(</span><span class="n">lte</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">currentAllowance</span><span class="p">))</span>
                <span class="nf">sstore</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nf">sub</span><span class="p">(</span><span class="n">currentAllowance</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>
            <span class="p">}</span>

            <span class="cm">/* ---------- 工具函数 ---------- */</span>
            <span class="k">function</span> <span class="n">lte</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">:=</span> <span class="nf">iszero</span><span class="p">(</span><span class="nf">gt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">gte</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">:=</span> <span class="nf">iszero</span><span class="p">(</span><span class="nf">lt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">safeAdd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="nf">or</span><span class="p">(</span><span class="nf">lt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="nf">lt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="p">{</span> <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">calledByOwner</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">cbo</span> <span class="p">{</span>
                <span class="n">cbo</span> <span class="o">:=</span> <span class="nf">eq</span><span class="p">(</span><span class="n">owner</span><span class="p">(),</span> <span class="nf">caller</span><span class="p">())</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">revertIfZeroAddress</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">require</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">function</span> <span class="n">require</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nf">iszero</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span> <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<span id="document-style-guide"></span><section id="index-0">
<span id="id1"></span><h2>风格指南<a class="headerlink" href="#index-0" title="此标题的永久链接"></a></h2>
<section id="id2">
<h3>概述<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>本指南旨在为编写 Solidity 代码提供编码规范。
这个指南应该被认为是一个不断发展的文件，随着有用的约定被发现和旧的约定被淘汰，它将随着时间而改变。</p>
<p>许多项目会实施他们自己的编码风格指南。如遇冲突，应优先使用具体项目的风格指南。</p>
<p>本风格指南中的结构和许多建议是取自 python 的
<a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">pep8 风格指南</a>。</p>
<p>本指南并 <em>不是</em> 以指导正确或最佳的 solidity 编码方式为目的。
本指南的目的是保持代码的 <em>一致性</em> 。
来自 python 的参考文档 <a class="reference external" href="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds">pep8</a>，
很好地阐述了这个概念。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>风格指南是关于一致性的。重要的是与此风格指南保持一致，但项目中的一致性更重要。
一个模块或功能内的一致性是最重要的。</p>
<p>但最重要的是：<strong>知道什么时候不一致</strong> —— 有时风格指南不适用。如有疑问，请自行判断。
看看其他例子，并决定什么看起来最好，并应毫不犹豫地询问他人！</p>
</div>
</section>
<section id="id4">
<h3>代码结构<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<section id="id5">
<h4>缩进<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<p>每个缩进级别使用4个空格。</p>
</section>
<section id="id6">
<h4>制表符或空格<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<p>空格是首选的缩进方法。</p>
<p>应该避免混合使用制表符和空格。</p>
</section>
<section id="id7">
<h4>空行<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h4>
<p>在 solidity 源码中合约声明之间留出两个空行。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7CiAgICAvLyAuLi4KfQoKCmNvbnRyYWN0IEIgewogICAgLy8gLi4uCn0KCgpjb250cmFjdCBDIHsKICAgIC8vIC4uLgp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7CiAgICAvLyAuLi4KfQpjb250cmFjdCBCIHsKICAgIC8vIC4uLgp9Cgpjb250cmFjdCBDIHsKICAgIC8vIC4uLgp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在一个合约中的函数声明之间留有一个空行。</p>
<p>在相关联的各组单行语句之间可以省略空行。（例如抽象合约的 stub 函数）。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICBmdW5jdGlvbiBzcGFtKCkgcHVibGljIHZpcnR1YWwgcHVyZTsKICAgIGZ1bmN0aW9uIGhhbSgpIHB1YmxpYyB2aXJ0dWFsIHB1cmU7Cn0KCgpjb250cmFjdCBCIGlzIEEgewogICAgZnVuY3Rpb24gc3BhbSgpIHB1YmxpYyBwdXJlIG92ZXJyaWRlIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICBmdW5jdGlvbiBoYW0oKSBwdWJsaWMgcHVyZSBvdmVycmlkZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">spam</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>pure<span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">ham</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>pure<span class="p">;</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">spam</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>override<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">ham</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>override<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICBmdW5jdGlvbiBzcGFtKCkgdmlydHVhbCBwdXJlIHB1YmxpYzsKICAgIGZ1bmN0aW9uIGhhbSgpIHB1YmxpYyB2aXJ0dWFsIHB1cmU7Cn0KCgpjb250cmFjdCBCIGlzIEEgewogICAgZnVuY3Rpb24gc3BhbSgpIHB1YmxpYyBwdXJlIG92ZXJyaWRlIHsKICAgICAgICAvLyAuLi4KICAgIH0KICAgIGZ1bmN0aW9uIGhhbSgpIHB1YmxpYyBwdXJlIG92ZXJyaWRlIHsKICAgICAgICAvLyAuLi4KICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">spam</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span>pure<span class="w"> </span><span class="kt">public</span><span class="p">;</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">ham</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>pure<span class="p">;</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">spam</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>override<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">ham</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>override<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="maximum-line-length">
<span id="id8"></span><h4>代码行的最大长度<a class="headerlink" href="#maximum-line-length" title="此标题的永久链接"></a></h4>
<p>最大建议行长度为120个字符。</p>
<p>折行时应该遵从以下指引。</p>
<ol class="arabic simple">
<li><p>第一个参数不应该紧跟在左括号后边</p></li>
<li><p>用一个，且只用一个缩进</p></li>
<li><p>每个函数应该单起一行</p></li>
<li><p>结束符号 <code class="code docutils literal notranslate"><span class="pre">);</span></code> 应该单独放在最后一行</p></li>
</ol>
<p>函数调用</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dGhpc0Z1bmN0aW9uQ2FsbElzUmVhbGx5TG9uZygKICAgIGxvbmdBcmd1bWVudDEsCiAgICBsb25nQXJndW1lbnQyLAogICAgbG9uZ0FyZ3VtZW50MwopOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>thisFunctionCallIsReallyLong<span class="p">(</span>
<span class="w">    </span>longArgument1<span class="p">,</span>
<span class="w">    </span>longArgument2<span class="p">,</span>
<span class="w">    </span>longArgument3
<span class="p">);</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dGhpc0Z1bmN0aW9uQ2FsbElzUmVhbGx5TG9uZyhsb25nQXJndW1lbnQxLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25nQXJndW1lbnQyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25nQXJndW1lbnQzCik7Cgp0aGlzRnVuY3Rpb25DYWxsSXNSZWFsbHlMb25nKGxvbmdBcmd1bWVudDEsCiAgICBsb25nQXJndW1lbnQyLAogICAgbG9uZ0FyZ3VtZW50MwopOwoKdGhpc0Z1bmN0aW9uQ2FsbElzUmVhbGx5TG9uZygKICAgIGxvbmdBcmd1bWVudDEsIGxvbmdBcmd1bWVudDIsCiAgICBsb25nQXJndW1lbnQzCik7Cgp0aGlzRnVuY3Rpb25DYWxsSXNSZWFsbHlMb25nKApsb25nQXJndW1lbnQxLApsb25nQXJndW1lbnQyLApsb25nQXJndW1lbnQzCik7Cgp0aGlzRnVuY3Rpb25DYWxsSXNSZWFsbHlMb25nKAogICAgbG9uZ0FyZ3VtZW50MSwKICAgIGxvbmdBcmd1bWVudDIsCiAgICBsb25nQXJndW1lbnQzKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>thisFunctionCallIsReallyLong<span class="p">(</span>longArgument1<span class="p">,</span>
<span class="w">                              </span>longArgument2<span class="p">,</span>
<span class="w">                              </span>longArgument3
<span class="p">);</span>

thisFunctionCallIsReallyLong<span class="p">(</span>longArgument1<span class="p">,</span>
<span class="w">    </span>longArgument2<span class="p">,</span>
<span class="w">    </span>longArgument3
<span class="p">);</span>

thisFunctionCallIsReallyLong<span class="p">(</span>
<span class="w">    </span>longArgument1<span class="p">,</span><span class="w"> </span>longArgument2<span class="p">,</span>
<span class="w">    </span>longArgument3
<span class="p">);</span>

thisFunctionCallIsReallyLong<span class="p">(</span>
longArgument1<span class="p">,</span>
longArgument2<span class="p">,</span>
longArgument3
<span class="p">);</span>

thisFunctionCallIsReallyLong<span class="p">(</span>
<span class="w">    </span>longArgument1<span class="p">,</span>
<span class="w">    </span>longArgument2<span class="p">,</span>
<span class="w">    </span>longArgument3<span class="p">);</span>
</pre></div>
</div>
<p>赋值语句</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dGhpc0lzQUxvbmdOZXN0ZWRNYXBwaW5nW2JlaW5nXVtzZXRdW3RvU29tZVZhbHVlXSA9IHNvbWVGdW5jdGlvbigKICAgIGFyZ3VtZW50MSwKICAgIGFyZ3VtZW50MiwKICAgIGFyZ3VtZW50MywKICAgIGFyZ3VtZW50NAopOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>thisIsALongNestedMapping<span class="p">[</span>being<span class="p">][</span>set<span class="p">][</span>toSomeValue<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>someFunction<span class="p">(</span>
<span class="w">    </span>argument1<span class="p">,</span>
<span class="w">    </span>argument2<span class="p">,</span>
<span class="w">    </span>argument3<span class="p">,</span>
<span class="w">    </span>argument4
<span class="p">);</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dGhpc0lzQUxvbmdOZXN0ZWRNYXBwaW5nW2JlaW5nXVtzZXRdW3RvU29tZVZhbHVlXSA9IHNvbWVGdW5jdGlvbihhcmd1bWVudDEsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDQpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>thisIsALongNestedMapping<span class="p">[</span>being<span class="p">][</span>set<span class="p">][</span>toSomeValue<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>someFunction<span class="p">(</span>argument1<span class="p">,</span>
<span class="w">                                                                   </span>argument2<span class="p">,</span>
<span class="w">                                                                   </span>argument3<span class="p">,</span>
<span class="w">                                                                   </span>argument4<span class="p">);</span>
</pre></div>
</div>
<p>事件定义和事件发生</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZXZlbnQgTG9uZ0FuZExvdHNPZkFyZ3MoCiAgICBhZGRyZXNzIHNlbmRlciwKICAgIGFkZHJlc3MgcmVjaXBpZW50LAogICAgdWludDI1NiBwdWJsaWNLZXksCiAgICB1aW50MjU2IGFtb3VudCwKICAgIGJ5dGVzMzJbXSBvcHRpb25zCik7CgpMb25nQW5kTG90c09mQXJncygKICAgIHNlbmRlciwKICAgIHJlY2lwaWVudCwKICAgIHB1YmxpY0tleSwKICAgIGFtb3VudCwKICAgIG9wdGlvbnMKKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">event</span><span class="w"> </span><span class="nv">LongAndLotsOfArgs</span><span class="p">(</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">sender</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">publicKey</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bytes32</span><span class="p">[]</span><span class="w"> </span>options
<span class="p">);</span>

LongAndLotsOfArgs<span class="p">(</span>
<span class="w">    </span>sender<span class="p">,</span>
<span class="w">    </span>recipient<span class="p">,</span>
<span class="w">    </span>publicKey<span class="p">,</span>
<span class="w">    </span>amount<span class="p">,</span>
<span class="w">    </span>options
<span class="p">);</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZXZlbnQgTG9uZ0FuZExvdHNPZkFyZ3MoYWRkcmVzcyBzZW5kZXIsCiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgcmVjaXBpZW50LAogICAgICAgICAgICAgICAgICAgICAgICB1aW50MjU2IHB1YmxpY0tleSwKICAgICAgICAgICAgICAgICAgICAgICAgdWludDI1NiBhbW91bnQsCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzMzJbXSBvcHRpb25zKTsKCkxvbmdBbmRMb3RzT2ZBcmdzKHNlbmRlciwKICAgICAgICAgICAgICAgICAgcmVjaXBpZW50LAogICAgICAgICAgICAgICAgICBwdWJsaWNLZXksCiAgICAgICAgICAgICAgICAgIGFtb3VudCwKICAgICAgICAgICAgICAgICAgb3B0aW9ucyk7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">event</span><span class="w"> </span><span class="nv">LongAndLotsOfArgs</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">sender</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">publicKey</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">bytes32</span><span class="p">[]</span><span class="w"> </span>options<span class="p">);</span>

LongAndLotsOfArgs<span class="p">(</span>sender<span class="p">,</span>
<span class="w">                  </span>recipient<span class="p">,</span>
<span class="w">                  </span>publicKey<span class="p">,</span>
<span class="w">                  </span>amount<span class="p">,</span>
<span class="w">                  </span>options<span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id9">
<h4>源文件编码格式<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>首选 UTF-8 或 ASCII 编码。</p>
</section>
<section id="imports">
<h4>Imports 规范<a class="headerlink" href="#imports" title="此标题的永久链接"></a></h4>
<p>Import 语句应始终放在文件的顶部。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKaW1wb3J0ICIuL093bmVkLnNvbCI7Cgpjb250cmFjdCBBIHsKICAgIC8vIC4uLgp9CgoKY29udHJhY3QgQiBpcyBPd25lZCB7CiAgICAvLyAuLi4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./Owned.sol&quot;</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7CiAgICAvLyAuLi4KfQoKCmltcG9ydCAiLi9Pd25lZC5zb2wiOwoKCmNvbnRyYWN0IEIgaXMgT3duZWQgewogICAgLy8gLi4uCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>


<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./Owned.sol&quot;</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id10">
<h4>函数顺序<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h4>
<p>排序有助于读者识别他们可以调用哪些函数，并更容易地找到构造函数和 fallback 函数的定义。</p>
<p>函数应根据其可见性和顺序进行分组：</p>
<ul class="simple">
<li><p>构造函数</p></li>
<li><p>receive 函数（如果存在）</p></li>
<li><p>fallback 函数（如果存在）</p></li>
<li><p>外部函数</p></li>
<li><p>公共函数</p></li>
<li><p>内部函数</p></li>
<li><p>私有函数</p></li>
</ul>
<p>在一个分组中，把 <code class="docutils literal notranslate"><span class="pre">view</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数放在最后。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIC8vIC4uLgogICAgfQoKICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICBmYWxsYmFjaygpIGV4dGVybmFsIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICAvLyDlpJbpg6jlh73mlbAKICAgIC8vIC4uLgoKICAgIC8vIOaYryB2aWV3IOS/rumlsOeahOWklumDqOWHveaVsAogICAgLy8gLi4uCgogICAgLy8g5pivIHB1cmUg5L+u6aWw55qE5aSW6YOo5Ye95pWwCiAgICAvLyAuLi4KCiAgICAvLyDlhazlhbHlh73mlbAKICAgIC8vIC4uLgoKICAgIC8vIOWGhemDqOWHveaVsAogICAgLy8gLi4uCgogICAgLy8g56eB5pyJ5Ye95pWwCiAgICAvLyAuLi4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span>fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 外部函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// 是 view 修饰的外部函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// 是 pure 修饰的外部函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// 公共函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// 内部函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// 私有函数</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKCiAgICAvLyDlpJbpg6jlh73mlbAKICAgIC8vIC4uLgoKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgewogICAgICAgIC8vIC4uLgogICAgfQogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgewogICAgICAgIC8vIC4uLgogICAgfQoKICAgIC8vIOengeacieWHveaVsAogICAgLy8gLi4uCgogICAgLy8g5YWs5YWx5Ye95pWwCiAgICAvLyAuLi4KCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICAvLyDlhoXpg6jlh73mlbAKICAgIC8vIC4uLgp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// 外部函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span>fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 私有函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// 公共函数</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 内部函数</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id11">
<h4>表达式中的空格<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>在以下情况下避免无关的空格：</p>
<p>除单行函数声明外，紧接着小括号，中括号或者大括号的内容应该避免使用空格。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=c3BhbShoYW1bMV0sIENvaW4oe25hbWU6ICJoYW0ifSkpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>spam<span class="p">(</span>ham<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">],</span><span class="w"> </span>Coin<span class="p">({</span>name<span class="o">:</span><span class="w"> </span><span class="s2">&quot;ham&quot;</span><span class="p">}));</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=c3BhbSggaGFtWyAxIF0sIENvaW4oIHsgbmFtZTogImhhbSIgfSApICk7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>spam<span class="p">(</span><span class="w"> </span>ham<span class="p">[</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span><span class="p">],</span><span class="w"> </span>Coin<span class="p">(</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>name<span class="o">:</span><span class="w"> </span><span class="s2">&quot;ham&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
<p>除外：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gc2luZ2xlTGluZSgpIHB1YmxpYyB7IHNwYW0oKTsgfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">singleLine</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>spam<span class="p">();</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>紧接在逗号，分号之前：</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gc3BhbSh1aW50IGksIENvaW4gY29pbikgcHVibGljOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">spam</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="p">,</span><span class="w"> </span>Coin<span class="w"> </span>coin<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gc3BhbSh1aW50IGkgLCBDb2luIGNvaW4pIHB1YmxpYyA7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">spam</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">,</span><span class="w"> </span>Coin<span class="w"> </span>coin<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">;</span>
</pre></div>
</div>
<p>赋值或其他操作符两边多于一个的空格：</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=eCA9IDE7CnkgPSAyOwpsb25nVmFyaWFibGUgPSAzOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
y<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
longVariable<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=eCAgICAgICAgICAgID0gMTsKeSAgICAgICAgICAgID0gMjsKbG9uZ1ZhcmlhYmxlID0gMzs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>x<span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
y<span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
longVariable<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
</pre></div>
</div>
<p>在receive和fallback函数中不要包含空格：</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=cmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgewogICAgLi4uCn0KCmZhbGxiYWNrKCkgZXh0ZXJuYWwgewogICAgLi4uCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=cmVjZWl2ZSAoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgIC4uLgp9CgpmYWxsYmFjayAoKSBleHRlcm5hbCB7CiAgICAuLi4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>receive<span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

fallback<span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id12">
<h4>控制结构<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<p>用大括号表示一个合约，库，函数和结构。 应该为：</p>
<ul class="simple">
<li><p>开括号与声明应在同一行。</p></li>
<li><p>闭括号在与之前函数声明对应的开括号保持同一缩进级别上另起一行。</p></li>
<li><p>开括号前应该有一个空格。</p></li>
</ul>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29pbiB7CiAgICBzdHJ1Y3QgQmFuayB7CiAgICAgICAgYWRkcmVzcyBvd25lcjsKICAgICAgICB1aW50IGJhbGFuY2U7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Coin</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Bank</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29pbgp7CiAgICBzdHJ1Y3QgQmFuayB7CiAgICAgICAgYWRkcmVzcyBvd25lcjsKICAgICAgICB1aW50IGJhbGFuY2U7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Coin</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Bank</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于控制结构  <code class="docutils literal notranslate"><span class="pre">if</span></code>， <code class="docutils literal notranslate"><span class="pre">else</span></code>， <code class="docutils literal notranslate"><span class="pre">while</span></code>， 和 <code class="docutils literal notranslate"><span class="pre">for</span></code> 的实施建议与以上相同。</p>
<p>另外，诸如 <code class="docutils literal notranslate"><span class="pre">if</span></code>， <code class="docutils literal notranslate"><span class="pre">else</span></code>， <code class="docutils literal notranslate"><span class="pre">while</span></code>， 和 <code class="docutils literal notranslate"><span class="pre">for</span></code> 这类的控制结构
和条件表达式的块之间应该有一个单独的空格，
同样的，条件表达式的块和开括号之间也应该有一个空格。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aWYgKC4uLikgewogICAgLi4uCn0KCmZvciAoLi4uKSB7CiAgICAuLi4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">if</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">for</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aWYgKC4uLikKewogICAgLi4uCn0KCndoaWxlKC4uLil7Cn0KCmZvciAoLi4uKSB7CiAgICAuLi47fQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">if</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">while</span><span class="p">(...){</span>
<span class="p">}</span>

<span class="kt">for</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...;}</span>
</pre></div>
</div>
<p>对于控制结构， <em>如果</em> 其主体内容只包含一行，则可以省略括号。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aWYgKHggPCAxMCkKICAgIHggKz0gMTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aWYgKHggPCAxMCkKICAgIHNvbWVBcnJheS5wdXNoKENvaW4oewogICAgICAgIG5hbWU6ICdzcGFtJywKICAgICAgICB2YWx1ZTogNDIKICAgIH0pKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span>
<span class="w">    </span>someArray<span class="p">.</span>push<span class="p">(</span>Coin<span class="p">({</span>
<span class="w">        </span>name<span class="o">:</span><span class="w"> </span><span class="s1">&#39;spam&#39;</span><span class="p">,</span>
<span class="w">        </span>value<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">42</span>
<span class="w">    </span><span class="p">}));</span>
</pre></div>
</div>
<p>对于具有 <code class="docutils literal notranslate"><span class="pre">else</span></code> 或 <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> 子句的 <code class="docutils literal notranslate"><span class="pre">if</span></code> 块，
<code class="docutils literal notranslate"><span class="pre">else</span></code> 应该是与 <code class="docutils literal notranslate"><span class="pre">if</span></code> 的闭大括号放在同一行上。
这一规则区别于其他块状结构。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aWYgKHggPCAzKSB7CiAgICB4ICs9IDE7Cn0gZWxzZSBpZiAoeCA+IDcpIHsKICAgIHggLT0gMTsKfSBlbHNlIHsKICAgIHggPSA1Owp9CgoKaWYgKHggPCAzKQogICAgeCArPSAxOwplbHNlCiAgICB4IC09IDE7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="kt">else</span><span class="w"> </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="kt">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">)</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="kt">else</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=aWYgKHggPCAzKSB7CiAgICB4ICs9IDE7Cn0KZWxzZSB7CiAgICB4IC09IDE7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id13">
<h4>函数声明<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h4>
<p>对于简短的函数声明，建议函数体的开括号与函数声明保持在同一行。</p>
<p>闭大括号应该与函数声明的缩进级别相同。</p>
<p>开大括号之前应该有一个空格。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxOwp9CgpmdW5jdGlvbiBpbmNyZW1lbnQodWludCB4KSBwdWJsaWMgcHVyZSBvbmx5T3duZXIgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>onlyOwner<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkKewogICAgcmV0dXJuIHggKyAxOwp9CgpmdW5jdGlvbiBpbmNyZW1lbnQodWludCB4KSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KXsKICAgIHJldHVybiB4ICsgMTsKfQoKZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxOwogICAgfQoKZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxO30="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">){</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;}</span>
</pre></div>
</div>
<p>一个函数的修饰符顺序应该是：</p>
<ol class="arabic simple">
<li><p>可见性</p></li>
<li><p>可变性</p></li>
<li><p>虚拟性</p></li>
<li><p>覆盖性</p></li>
<li><p>自定义修饰符</p></li>
</ol>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gYmFsYW5jZSh1aW50IGZyb20pIHB1YmxpYyB2aWV3IG92ZXJyaWRlIHJldHVybnMgKHVpbnQpICB7CiAgICByZXR1cm4gYmFsYW5jZU9mW2Zyb21dOwp9CgpmdW5jdGlvbiBzaHV0ZG93bigpIHB1YmxpYyBvbmx5T3duZXIgewogICAgc2VsZmRlc3RydWN0KG93bmVyKTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">balance</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">from</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span>override<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>balanceOf<span class="p">[</span>from<span class="p">];</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">shutdown</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">    </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gYmFsYW5jZSh1aW50IGZyb20pIHB1YmxpYyBvdmVycmlkZSB2aWV3IHJldHVybnMgKHVpbnQpICB7CiAgICByZXR1cm4gYmFsYW5jZU9mW2Zyb21dOwp9CgpmdW5jdGlvbiBzaHV0ZG93bigpIG9ubHlPd25lciBwdWJsaWMgewogICAgc2VsZmRlc3RydWN0KG93bmVyKTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">balance</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">from</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>balanceOf<span class="p">[</span>from<span class="p">];</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">shutdown</span><span class="p">()</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于长的函数声明，建议将每个参数放在自己的行中，与函数主体的缩进程度相同。
闭小括号和开括号也应该放在自己的行中，与函数声明的缩进程度相同。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uSGFzTG90c09mQXJndW1lbnRzKAogICAgYWRkcmVzcyBhLAogICAgYWRkcmVzcyBiLAogICAgYWRkcmVzcyBjLAogICAgYWRkcmVzcyBkLAogICAgYWRkcmVzcyBlLAogICAgYWRkcmVzcyBmCikKICAgIHB1YmxpYwp7CiAgICBkb1NvbWV0aGluZygpOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionHasLotsOfArguments</span><span class="p">(</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">b</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">c</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">d</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">e</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">f</span>
<span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uSGFzTG90c09mQXJndW1lbnRzKGFkZHJlc3MgYSwgYWRkcmVzcyBiLCBhZGRyZXNzIGMsCiAgICBhZGRyZXNzIGQsIGFkZHJlc3MgZSwgYWRkcmVzcyBmKSBwdWJsaWMgewogICAgZG9Tb21ldGhpbmcoKTsKfQoKZnVuY3Rpb24gdGhpc0Z1bmN0aW9uSGFzTG90c09mQXJndW1lbnRzKGFkZHJlc3MgYSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgYiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgYywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgZikgcHVibGljIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0KCmZ1bmN0aW9uIHRoaXNGdW5jdGlvbkhhc0xvdHNPZkFyZ3VtZW50cygKICAgIGFkZHJlc3MgYSwKICAgIGFkZHJlc3MgYiwKICAgIGFkZHJlc3MgYywKICAgIGFkZHJlc3MgZCwKICAgIGFkZHJlc3MgZSwKICAgIGFkZHJlc3MgZikgcHVibGljIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionHasLotsOfArguments</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">b</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">c</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">d</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">e</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionHasLotsOfArguments</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">address</span><span class="w"> </span><span class="nv">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">address</span><span class="w"> </span><span class="nv">c</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">address</span><span class="w"> </span><span class="nv">d</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">address</span><span class="w"> </span><span class="nv">e</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">address</span><span class="w"> </span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionHasLotsOfArguments</span><span class="p">(</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">b</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">c</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">d</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">e</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果一个长函数声明有修饰符，那么每个修饰符都应该被丢到独立的一行。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZyhhZGRyZXNzIHgsIGFkZHJlc3MgeSwgYWRkcmVzcyB6KQogICAgcHVibGljCiAgICBvbmx5T3duZXIKICAgIHByaWNlZAogICAgcmV0dXJucyAoYWRkcmVzcykKewogICAgZG9Tb21ldGhpbmcoKTsKfQoKZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZygKICAgIGFkZHJlc3MgeCwKICAgIGFkZHJlc3MgeSwKICAgIGFkZHJlc3MgegopCiAgICBwdWJsaWMKICAgIG9ubHlPd25lcgogICAgcHJpY2VkCiAgICByZXR1cm5zIChhZGRyZXNzKQp7CiAgICBkb1NvbWV0aGluZygpOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">y</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">z</span><span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span>onlyOwner
<span class="w">    </span>priced
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">y</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">z</span>
<span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span>onlyOwner
<span class="w">    </span>priced
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZyhhZGRyZXNzIHgsIGFkZHJlc3MgeSwgYWRkcmVzcyB6KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpYwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubHlPd25lcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgKGFkZHJlc3MpIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0KCmZ1bmN0aW9uIHRoaXNGdW5jdGlvbk5hbWVJc1JlYWxseUxvbmcoYWRkcmVzcyB4LCBhZGRyZXNzIHksIGFkZHJlc3MgeikKICAgIHB1YmxpYyBvbmx5T3duZXIgcHJpY2VkIHJldHVybnMgKGFkZHJlc3MpCnsKICAgIGRvU29tZXRoaW5nKCk7Cn0KCmZ1bmN0aW9uIHRoaXNGdW5jdGlvbk5hbWVJc1JlYWxseUxvbmcoYWRkcmVzcyB4LCBhZGRyZXNzIHksIGFkZHJlc3MgeikKICAgIHB1YmxpYwogICAgb25seU93bmVyCiAgICBwcmljZWQKICAgIHJldHVybnMgKGFkZHJlc3MpIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">y</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">z</span><span class="p">)</span>
<span class="w">                                      </span><span class="kt">public</span>
<span class="w">                                      </span>onlyOwner
<span class="w">                                      </span>priced
<span class="w">                                      </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">y</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">z</span><span class="p">)</span>
<span class="w">    </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span>priced<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">y</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">z</span><span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span>onlyOwner
<span class="w">    </span>priced
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>多行输出参数和返回值语句应该遵从 <a class="reference internal" href="#maximum-line-length"><span class="std std-ref">代码行的最大长度</span></a> 一节的说明。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZygKICAgIGFkZHJlc3MgYSwKICAgIGFkZHJlc3MgYiwKICAgIGFkZHJlc3MgYwopCiAgICBwdWJsaWMKICAgIHJldHVybnMgKAogICAgICAgIGFkZHJlc3Mgc29tZUFkZHJlc3NOYW1lLAogICAgICAgIHVpbnQyNTYgTG9uZ0FyZ3VtZW50LAogICAgICAgIHVpbnQyNTYgQXJndW1lbnQKICAgICkKewogICAgZG9Tb21ldGhpbmcoKQoKICAgIHJldHVybiAoCiAgICAgICAgdmVyeUxvbmdSZXR1cm5BcmcxLAogICAgICAgIHZlcnlMb25nUmV0dXJuQXJnMiwKICAgICAgICB2ZXJ5TG9uZ1JldHVybkFyZzMKICAgICk7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">b</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">c</span>
<span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">someAddressName</span><span class="p">,</span>
<span class="w">        </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">LongArgument</span><span class="p">,</span>
<span class="w">        </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">Argument</span>
<span class="w">    </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">()</span>

<span class="w">    </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span>veryLongReturnArg1<span class="p">,</span>
<span class="w">        </span>veryLongReturnArg2<span class="p">,</span>
<span class="w">        </span>veryLongReturnArg3
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZygKICAgIGFkZHJlc3MgYSwKICAgIGFkZHJlc3MgYiwKICAgIGFkZHJlc3MgYwopCiAgICBwdWJsaWMKICAgIHJldHVybnMgKGFkZHJlc3Mgc29tZUFkZHJlc3NOYW1lLAogICAgICAgICAgICAgdWludDI1NiBMb25nQXJndW1lbnQsCiAgICAgICAgICAgICB1aW50MjU2IEFyZ3VtZW50KQp7CiAgICBkb1NvbWV0aGluZygpCgogICAgcmV0dXJuICh2ZXJ5TG9uZ1JldHVybkFyZzEsCiAgICAgICAgICAgIHZlcnlMb25nUmV0dXJuQXJnMSwKICAgICAgICAgICAgdmVyeUxvbmdSZXR1cm5BcmcxKTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">thisFunctionNameIsReallyLong</span><span class="p">(</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">b</span><span class="p">,</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">c</span>
<span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">someAddressName</span><span class="p">,</span>
<span class="w">             </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">LongArgument</span><span class="p">,</span>
<span class="w">             </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">Argument</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>doSomething<span class="p">()</span>

<span class="w">    </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>veryLongReturnArg1<span class="p">,</span>
<span class="w">            </span>veryLongReturnArg1<span class="p">,</span>
<span class="w">            </span>veryLongReturnArg1<span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于继承合约中需要参数的构造函数，如果函数声明很长或难以阅读，
建议将基础构造函数像多个修饰符的风格那样，每个下沉到一个新行上书写。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDln7rnoYDlkIjnuqbvvIzkuLrkuobkvb/ov5nmrrXku6PnoIHog73ooqvnvJbor5EKY29udHJhY3QgQiB7CiAgICBjb25zdHJ1Y3Rvcih1aW50KSB7CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQsIHVpbnQpIHsKICAgIH0KfQoKCmNvbnRyYWN0IEQgewogICAgY29uc3RydWN0b3IodWludCkgewogICAgfQp9CgoKY29udHJhY3QgQSBpcyBCLCBDLCBEIHsKICAgIHVpbnQgeDsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IHBhcmFtMSwgdWludCBwYXJhbTIsIHVpbnQgcGFyYW0zLCB1aW50IHBhcmFtNCwgdWludCBwYXJhbTUpCiAgICAgICAgQihwYXJhbTEpCiAgICAgICAgQyhwYXJhbTIsIHBhcmFtMykKICAgICAgICBEKHBhcmFtNCkKICAgIHsKICAgICAgICAvLyDnlKjlj4LmlbAgcGFyYW01IOWBmuS4gOS6m+S6i+aDhQogICAgICAgIHggPSBwYXJhbTU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>
<span class="c1">// 基础合约，为了使这段代码能被编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>B<span class="p">,</span><span class="w"> </span>C<span class="p">,</span><span class="w"> </span>D<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">param1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param3</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param5</span><span class="p">)</span>
<span class="w">        </span>B<span class="p">(</span>param1<span class="p">)</span>
<span class="w">        </span>C<span class="p">(</span>param2<span class="p">,</span><span class="w"> </span>param3<span class="p">)</span>
<span class="w">        </span>D<span class="p">(</span>param4<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 用参数 param5 做一些事情</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>param5<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKLy8g5Z+656GA5ZCI57qm77yM5Li65LqG5L2/6L+Z5q615Luj56CB6IO96KKr57yW6K+RCmNvbnRyYWN0IEIgewogICAgY29uc3RydWN0b3IodWludCkgewogICAgfQp9CgoKY29udHJhY3QgQyB7CiAgICBjb25zdHJ1Y3Rvcih1aW50LCB1aW50KSB7CiAgICB9Cn0KCgpjb250cmFjdCBEIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQpIHsKICAgIH0KfQoKCmNvbnRyYWN0IEEgaXMgQiwgQywgRCB7CiAgICB1aW50IHg7CgogICAgY29uc3RydWN0b3IodWludCBwYXJhbTEsIHVpbnQgcGFyYW0yLCB1aW50IHBhcmFtMywgdWludCBwYXJhbTQsIHVpbnQgcGFyYW01KQogICAgQihwYXJhbTEpCiAgICBDKHBhcmFtMiwgcGFyYW0zKQogICAgRChwYXJhbTQpIHsKICAgICAgICB4ID0gcGFyYW01OwogICAgfQp9CgoKY29udHJhY3QgWCBpcyBCLCBDLCBEIHsKICAgIHVpbnQgeDsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IHBhcmFtMSwgdWludCBwYXJhbTIsIHVpbnQgcGFyYW0zLCB1aW50IHBhcmFtNCwgdWludCBwYXJhbTUpCiAgICAgICAgQihwYXJhbTEpCiAgICAgICAgQyhwYXJhbTIsIHBhcmFtMykKICAgICAgICBEKHBhcmFtNCkgewogICAgICAgICAgICB4ID0gcGFyYW01OwogICAgICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// 基础合约，为了使这段代码能被编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>B<span class="p">,</span><span class="w"> </span>C<span class="p">,</span><span class="w"> </span>D<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">param1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param3</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param5</span><span class="p">)</span>
<span class="w">    </span>B<span class="p">(</span>param1<span class="p">)</span>
<span class="w">    </span>C<span class="p">(</span>param2<span class="p">,</span><span class="w"> </span>param3<span class="p">)</span>
<span class="w">    </span>D<span class="p">(</span>param4<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>param5<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">X</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>B<span class="p">,</span><span class="w"> </span>C<span class="p">,</span><span class="w"> </span>D<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">param1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param3</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">param5</span><span class="p">)</span>
<span class="w">        </span>B<span class="p">(</span>param1<span class="p">)</span>
<span class="w">        </span>C<span class="p">(</span>param2<span class="p">,</span><span class="w"> </span>param3<span class="p">)</span>
<span class="w">        </span>D<span class="p">(</span>param4<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>param5<span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当用单个语句声明简短函数时，允许在一行中完成。</p>
<p>允许：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=ZnVuY3Rpb24gc2hvcnRGdW5jdGlvbigpIHB1YmxpYyB7IGRvU29tZXRoaW5nKCk7IH0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">shortFunction</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>doSomething<span class="p">();</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>这些函数声明的准则旨在提高可读性。
因为本指南不会涵盖所有内容，作者应该自行作出最佳判断。</p>
</section>
<section id="id14">
<h4>映射<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h4>
<p>在变量声明中，不要用空格将关键字 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 和其类型分开。
不要用空格分隔任何嵌套的 <code class="docutils literal notranslate"><span class="pre">mapping</span></code> 关键词和其类型。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=bWFwcGluZyh1aW50ID0+IHVpbnQpIG1hcDsKbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpIHJlZ2lzdGVyZWRBZGRyZXNzZXM7Cm1hcHBpbmcodWludCA9PiBtYXBwaW5nKGJvb2wgPT4gRGF0YVtdKSkgcHVibGljIGRhdGE7Cm1hcHBpbmcodWludCA9PiBtYXBwaW5nKHVpbnQgPT4gcykpIGRhdGE7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>map<span class="p">;</span>
<span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>registeredAddresses<span class="p">;</span>
<span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Data<span class="p">[]))</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>data<span class="p">;</span>
<span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>s<span class="p">))</span><span class="w"> </span>data<span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=bWFwcGluZyAodWludCA9PiB1aW50KSBtYXA7Cm1hcHBpbmcoIGFkZHJlc3MgPT4gYm9vbCApIHJlZ2lzdGVyZWRBZGRyZXNzZXM7Cm1hcHBpbmcgKHVpbnQgPT4gbWFwcGluZyAoYm9vbCA9PiBEYXRhW10pKSBwdWJsaWMgZGF0YTsKbWFwcGluZyh1aW50ID0+IG1hcHBpbmcgKHVpbnQgPT4gcykpIGRhdGE7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>map<span class="p">;</span>
<span class="kt">mapping</span><span class="p">(</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">)</span><span class="w"> </span>registeredAddresses<span class="p">;</span>
<span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Data<span class="p">[]))</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>data<span class="p">;</span>
<span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>s<span class="p">))</span><span class="w"> </span>data<span class="p">;</span>
</pre></div>
</div>
</section>
<section id="id15">
<h4>变量声明<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h4>
<p>数组变量的声明在变量类型和括号之间不应该有空格。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludFtdIHg7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>x<span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=dWludCBbXSB4Ow=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span>x<span class="p">;</span>
</pre></div>
</div>
</section>
<section id="id16">
<h4>其他建议<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>字符串应该用双引号而不是单引号。</p></li>
</ul>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=c3RyID0gImZvbyI7CnN0ciA9ICJIYW1sZXQgc2F5cywgJ1RvIGJlIG9yIG5vdCB0byBiZS4uLiciOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>str<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="p">;</span>
str<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;Hamlet says, &#39;To be or not to be...&#39;&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=c3RyID0gJ2Jhcic7CnN0ciA9ICciQmUgeW91cnNlbGY7IGV2ZXJ5b25lIGVsc2UgaXMgYWxyZWFkeSB0YWtlbi4iIC1Pc2NhciBXaWxkZSc7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>str<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;bar&#39;</span><span class="p">;</span>
str<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&quot;Be yourself; everyone else is already taken.&quot; -Oscar Wilde&#39;</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>操作符两边应该各有一个空格。</p></li>
</ul>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=eCA9IDM7CnggPSAxMDAgLyAxMDsKeCArPSAzICsgNDsKeCB8PSB5ICYmIHo7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span>
x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">100</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">;</span>
x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">;</span>
x<span class="w"> </span><span class="o">|=</span><span class="w"> </span>y<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>z<span class="p">;</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=eD0zOwp4ID0gMTAwLzEwOwp4ICs9IDMrNDsKeCB8PSB5JiZ6Ow=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>x<span class="o">=</span><span class="m m-Decimal">3</span><span class="p">;</span>
x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">100</span><span class="o">/</span><span class="m m-Decimal">10</span><span class="p">;</span>
x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="o">+</span><span class="m m-Decimal">4</span><span class="p">;</span>
x<span class="w"> </span><span class="o">|=</span><span class="w"> </span>y<span class="o">&amp;&amp;</span>z<span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>为了表示优先级，高优先级操作符两边可以省略空格。
这样可以提高复杂语句的可读性。
您应该在操作符两边总是使用相同的空格数：</p></li>
</ul>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=eCA9IDIqKjMgKyA1Owp4ID0gMip5ICsgMyp6Owp4ID0gKGErYikgKiAoYS1iKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="o">**</span><span class="m m-Decimal">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span>
x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="o">*</span>y<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="o">*</span>z<span class="p">;</span>
x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>a<span class="o">+</span>b<span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>a<span class="o">-</span>b<span class="p">);</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=eCA9IDIqKiAzICsgNTsKeCA9IHkrejsKeCArPTE7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="o">**</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span>
x<span class="w"> </span><span class="o">=</span><span class="w"> </span>y<span class="o">+</span>z<span class="p">;</span>
x<span class="w"> </span><span class="o">+=</span><span class="m m-Decimal">1</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="id17">
<h3>布局顺序<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h3>
<p>按以下顺序布置合约的元素：</p>
<ol class="arabic simple">
<li><p>Pragma 语句</p></li>
<li><p>导入语句</p></li>
<li><p>接口</p></li>
<li><p>库</p></li>
<li><p>合约</p></li>
</ol>
<p>在每个合约，库或接口内，使用以下顺序：</p>
<ol class="arabic simple">
<li><p>类型声明</p></li>
<li><p>状态变量</p></li>
<li><p>事件</p></li>
<li><p>修饰符</p></li>
<li><p>函数</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在接近事件或状态变量的使用时，声明类型可能会更清楚。</p>
</div>
</section>
<section id="id18">
<h3>命名规范<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h3>
<p>当完全采纳和使用命名规范时会产生强大的作用。
当使用不同的规范时，则不会立即获取代码中传达的重要 <em>元</em> 信息。</p>
<p>这里给出的命名建议旨在提高可读性，
因此它们不是规则，而是透过名称来尝试和帮助传达最多的信息。</p>
<p>最后，基于代码库中的一致性，本文档中的任何规范总是可以被（代码库中的规范）取代。</p>
<section id="id19">
<h4>命名方式<a class="headerlink" href="#id19" title="此标题的永久链接"></a></h4>
<p>为了避免混淆，下面的名字用来指明不同的命名方式。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> （单个小写字母）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code> （单个大写字母）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lowercase</span></code> （小写）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UPPERCASE</span></code> （大写）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UPPER_CASE_WITH_UNDERSCORES</span></code> （大写和下划线）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CapitalizedWords</span></code> （驼峰式，首字母大写）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mixedCase</span></code>  （混合式，与驼峰式的区别在于首字母小写！）</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当在驼峰式命名中使用缩写时，应该将缩写中的所有字母都大写。 因此 HTTPServerError 比 HttpServerError 好。
当在混合式命名中使用缩写时，除了第一个缩写中的字母小写（如果它是整个名称的开头的话）以外，
其他缩写中的字母均大写。 因此 xmlHTTPRequest 比 XMLHTTPRequest 更好。</p>
</div>
</section>
<section id="id20">
<h4>应避免的名称<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> - el的小写方式</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">O</span></code> - oh的大写方式</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> - eye的大写方式</p></li>
</ul>
<p>切勿将任何这些用于单个字母的变量名称。 他们经常难以与数字 1 和 0 区分开。</p>
</section>
<section id="id21">
<h4>合约和库名称<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>合约和库名称应该使用驼峰式风格。比如： <code class="docutils literal notranslate"><span class="pre">SimpleToken</span></code>， <code class="docutils literal notranslate"><span class="pre">SmartBank</span></code>， <code class="docutils literal notranslate"><span class="pre">CertificateHashRepository</span></code>， <code class="docutils literal notranslate"><span class="pre">Player</span></code>， <code class="docutils literal notranslate"><span class="pre">Congress</span></code>， <code class="docutils literal notranslate"><span class="pre">Owned</span></code>.。</p></li>
<li><p>合约和库的名称也应与它们的文件名相符。</p></li>
<li><p>如果一个合约文件包括多个合约和/或库，那么文件名应该与 <em>核心合约</em> 相匹配。但是，如果可以避免的话，不建议这样做。</p></li>
</ul>
<p>如下面的例子所示，如果合约名称是 <code class="docutils literal notranslate"><span class="pre">Congress</span></code>，库名称是 <code class="docutils literal notranslate"><span class="pre">Owned</span></code>，
那么它们的相关文件名应该是 <code class="docutils literal notranslate"><span class="pre">Congress.sol</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Owned.sol</span></code>。</p>
<p>正确写法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKLy8gT3duZWQuc29sCmNvbnRyYWN0IE93bmVkIHsKICAgIGFkZHJlc3MgcHVibGljIG93bmVyOwoKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSBvd25lcik7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2Zlck93bmVyc2hpcChhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// Owned.sol</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Owned</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">owner</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferOwnership</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">Congress.sol</span></code> 合约里：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKaW1wb3J0ICIuL093bmVkLnNvbCI7CgoKY29udHJhY3QgQ29uZ3Jlc3MgaXMgT3duZWQsIFRva2VuUmVjaXBpZW50IHsKICAgIC8vLi4uCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./Owned.sol&quot;</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Congress</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="p">,</span><span class="w"> </span>TokenRecipient<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误写法:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKLy8gb3duZWQuc29sCmNvbnRyYWN0IG93bmVkIHsKICAgIGFkZHJlc3MgcHVibGljIG93bmVyOwoKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSBvd25lcik7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2Zlck93bmVyc2hpcChhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">// owned.sol</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">owner</span><span class="p">;</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferOwnership</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">Congress.sol</span></code> 合约里：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjcuMDsKCgppbXBvcnQgIi4vb3duZWQuc29sIjsKCgpjb250cmFjdCBDb25ncmVzcyBpcyBvd25lZCwgdG9rZW5SZWNpcGllbnQgewogICAgLy8uLi4KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.7.0</span><span class="p">;</span>


<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;./owned.sol&quot;</span><span class="p">;</span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Congress</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="p">,</span><span class="w"> </span>tokenRecipient<span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id22">
<h4>结构体名称<a class="headerlink" href="#id22" title="此标题的永久链接"></a></h4>
<p>结构体名称应该使用驼峰式风格。比如： <code class="docutils literal notranslate"><span class="pre">MyCoin</span></code>， <code class="docutils literal notranslate"><span class="pre">Position</span></code>， <code class="docutils literal notranslate"><span class="pre">PositionXY</span></code>。</p>
</section>
<section id="id23">
<h4>事件名称<a class="headerlink" href="#id23" title="此标题的永久链接"></a></h4>
<p>事件名称应该使用驼峰式风格。
比如： <code class="docutils literal notranslate"><span class="pre">Deposit</span></code>， <code class="docutils literal notranslate"><span class="pre">Transfer</span></code>， <code class="docutils literal notranslate"><span class="pre">Approval</span></code>， <code class="docutils literal notranslate"><span class="pre">BeforeTransfer</span></code>， <code class="docutils literal notranslate"><span class="pre">AfterTransfer</span></code>。</p>
</section>
<section id="id24">
<h4>函数名称<a class="headerlink" href="#id24" title="此标题的永久链接"></a></h4>
<p>函数名称应该使用混合式命名风格。
比如： <code class="docutils literal notranslate"><span class="pre">getBalance</span></code>， <code class="docutils literal notranslate"><span class="pre">transfer</span></code>， <code class="docutils literal notranslate"><span class="pre">verifyOwner</span></code>， <code class="docutils literal notranslate"><span class="pre">addMember</span></code>， <code class="docutils literal notranslate"><span class="pre">changeOwner</span></code>。</p>
</section>
<section id="id25">
<h4>函数参数命名<a class="headerlink" href="#id25" title="此标题的永久链接"></a></h4>
<p>函数参数命名应该使用混合式命名风格。
比如： <code class="docutils literal notranslate"><span class="pre">initialSupply</span></code>， <code class="docutils literal notranslate"><span class="pre">account</span></code>， <code class="docutils literal notranslate"><span class="pre">recipientAddress</span></code>， <code class="docutils literal notranslate"><span class="pre">senderAddress</span></code>， <code class="docutils literal notranslate"><span class="pre">newOwner</span></code>。</p>
<p>在编写操作自定义结构的库函数时，
这个结构体应该作为函数的第一个参数，并且应该始终命名为 <code class="docutils literal notranslate"><span class="pre">self</span></code>。</p>
</section>
<section id="id26">
<h4>局部变量和状态变量名称<a class="headerlink" href="#id26" title="此标题的永久链接"></a></h4>
<p>使用混合式命名风格。
比如： <code class="docutils literal notranslate"><span class="pre">totalSupply</span></code>， <code class="docutils literal notranslate"><span class="pre">remainingSupply</span></code>， <code class="docutils literal notranslate"><span class="pre">balancesOf</span></code>， <code class="docutils literal notranslate"><span class="pre">creatorAddress</span></code>， <code class="docutils literal notranslate"><span class="pre">isPreSale</span></code>， <code class="docutils literal notranslate"><span class="pre">tokenExchangeRate</span></code>。</p>
</section>
<section id="id27">
<h4>常量命名<a class="headerlink" href="#id27" title="此标题的永久链接"></a></h4>
<p>常量应该全都使用大写字母书写，并用下划线分割单词。
比如： <code class="docutils literal notranslate"><span class="pre">MAX_BLOCKS</span></code>， <code class="docutils literal notranslate"><span class="pre">TOKEN_NAME</span></code>， <code class="docutils literal notranslate"><span class="pre">TOKEN_TICKER</span></code>， <code class="docutils literal notranslate"><span class="pre">CONTRACT_VERSION</span></code>。</p>
</section>
<section id="id28">
<h4>修饰符命名<a class="headerlink" href="#id28" title="此标题的永久链接"></a></h4>
<p>使用混合式命名风格。比如： <code class="docutils literal notranslate"><span class="pre">onlyBy</span></code>， <code class="docutils literal notranslate"><span class="pre">onlyAfter</span></code>， <code class="docutils literal notranslate"><span class="pre">onlyDuringThePreSale</span></code>。</p>
</section>
<section id="id29">
<h4>枚举变量命名<a class="headerlink" href="#id29" title="此标题的永久链接"></a></h4>
<p>在声明简单类型时，枚举应该使用驼峰式风格。
比如： <code class="docutils literal notranslate"><span class="pre">TokenGroup</span></code>， <code class="docutils literal notranslate"><span class="pre">Frame</span></code>， <code class="docutils literal notranslate"><span class="pre">HashStyle</span></code>， <code class="docutils literal notranslate"><span class="pre">CharacterLocation</span></code>。</p>
</section>
<section id="id30">
<h4>避免命名冲突<a class="headerlink" href="#id30" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">singleTrailingUnderscore_</span></code></p></li>
</ul>
</section>
<section id="id31">
<h4>当所需的名称与现有状态变量，函数，内置或其他保留关键字名称冲突时，建议使用此约定。<a class="headerlink" href="#id31" title="此标题的永久链接"></a></h4>
</section>
</section>
<section id="natspec">
<span id="style-guide-natspec"></span><h3>NatSpec<a class="headerlink" href="#natspec" title="此标题的永久链接"></a></h3>
<p>Solidity合约也可以包含NatSpec注释。
它们用三重斜线（ <code class="docutils literal notranslate"><span class="pre">///</span></code>）或双星号块（ <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">...</span> <span class="pre">*/</span></code>）来写，
它们应该直接用在函数声明或语句之上。</p>
<p>例如，来自 <a class="reference internal" href="index.html#simple-smart-contract"><span class="std std-ref">一个简单的智能合约</span></a> 的合约在添加了注释后看起来就像下面这个：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vLyBAYXV0aG9yIFNvbGlkaXR55Zui6ZifCi8vLyBAdGl0bGUg5LiA5Liq566A5Y2V55qE5a2Y5YKo5L6L5a2QCmNvbnRyYWN0IFNpbXBsZVN0b3JhZ2UgewogICAgdWludCBzdG9yZWREYXRhOwoKICAgIC8vLyDlrZjlgqggYHhg44CCCiAgICAvLy8gQHBhcmFtIHgg6KaB5a2Y5YKo55qE5paw5YC8CiAgICAvLy8gQGRldiDlsIbmlbDlrZflrZjlgqjlnKjnirbmgIHlj5jph48gYHN0b3JlZERhdGFgIOS4rQogICAgZnVuY3Rpb24gc2V0KHVpbnQgeCkgcHVibGljIHsKICAgICAgICBzdG9yZWREYXRhID0geDsKICAgIH0KCiAgICAvLy8g6L+U5Zue5a2Y5YKo55qE5YC844CCCiAgICAvLy8gQGRldiDmo4DntKLnirbmgIHlj5jph48gYHN0b3JlZERhdGFgIOeahOWAvAogICAgLy8vIEByZXR1cm4g5a2Y5YKo55qE5YC8CiAgICBmdW5jdGlvbiBnZXQoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHN0b3JlZERhdGE7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span>

<span class="c1">/// @author Solidity团队</span>
<span class="c1">/// @title 一个简单的存储例子</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleStorage</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">storedData</span><span class="p">;</span>

<span class="w">    </span><span class="c1">/// 存储 `x`。</span>
<span class="w">    </span><span class="c1">/// @param x 要存储的新值</span>
<span class="w">    </span><span class="c1">/// @dev 将数字存储在状态变量 `storedData` 中</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">set</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>storedData<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 返回存储的值。</span>
<span class="w">    </span><span class="c1">/// @dev 检索状态变量 `storedData` 的值</span>
<span class="w">    </span><span class="c1">/// @return 存储的值</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">get</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>storedData<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>建议 Solidity 合约使用 <a class="reference internal" href="index.html#natspec"><span class="std std-ref">NatSpec</span></a> 对所有公共接口（ABI 中的一切）进行完全注释。</p>
<p>请参阅关于 <a class="reference internal" href="index.html#natspec"><span class="std std-ref">NatSpec</span></a> 的部分，以获得详细解释。</p>
</section>
</section>
<span id="document-common-patterns"></span><section id="id1">
<h2>通用模式<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<section id="withdrawal-pattern">
<span id="index-0"></span><span id="id2"></span><h3>从合约中提款<a class="headerlink" href="#withdrawal-pattern" title="此标题的永久链接"></a></h3>
<p>在某个操作之后发送资金的推荐方式是使用取回（withdrawal）模式。
尽管在某个操作之后，最直接地发送以太币方法是一个 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 调用，
但这并不推荐,因为这会引入一个潜在的安全风险。
您可能需要参考 <a class="reference internal" href="index.html#security-considerations"><span class="std std-ref">安全考虑</span></a> 来获取更多信息。</p>
<p>下面是一个合约中实际提款模式的例子，其目标是向合约发送最多的钱，
以成为 “首富”，其灵感来自于 <a class="reference external" href="https://www.kingoftheether.com/">King of the Ether</a>。</p>
<p>在下面的合约中，如果您不再是最富有的人，您将收到取代您成为“最富有”的人发送到合约的资金。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFdpdGhkcmF3YWxDb250cmFjdCB7CiAgICBhZGRyZXNzIHB1YmxpYyByaWNoZXN0OwogICAgdWludCBwdWJsaWMgbW9zdFNlbnQ7CgogICAgbWFwcGluZyAoYWRkcmVzcyA9PiB1aW50KSBwZW5kaW5nV2l0aGRyYXdhbHM7CgogICAgLy8vIOWPkemAgeeahOS7peWkquaVsOmHj+S4jemrmOS6juebruWJjeeahOacgOmrmOmHj+OAggogICAgZXJyb3IgTm90RW5vdWdoRXRoZXIoKTsKCiAgICBjb25zdHJ1Y3RvcigpIHBheWFibGUgewogICAgICAgIHJpY2hlc3QgPSBtc2cuc2VuZGVyOwogICAgICAgIG1vc3RTZW50ID0gbXNnLnZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGJlY29tZVJpY2hlc3QoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA8PSBtb3N0U2VudCkgcmV2ZXJ0IE5vdEVub3VnaEV0aGVyKCk7CiAgICAgICAgcGVuZGluZ1dpdGhkcmF3YWxzW3JpY2hlc3RdICs9IG1zZy52YWx1ZTsKICAgICAgICByaWNoZXN0ID0gbXNnLnNlbmRlcjsKICAgICAgICBtb3N0U2VudCA9IG1zZy52YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIHB1YmxpYyB7CiAgICAgICAgdWludCBhbW91bnQgPSBwZW5kaW5nV2l0aGRyYXdhbHNbbXNnLnNlbmRlcl07CiAgICAgICAgLy8g6K6w5b6X5Zyo5Y+R6YCB5YmN5bCG5b6F5aSE55CG55qE6YCA5qy+5b2S6Zu277yMCiAgICAgICAgLy8g5Lul6Ziy5q2i6YeN5YWl5pS75Ye7CiAgICAgICAgcGVuZGluZ1dpdGhkcmF3YWxzW21zZy5zZW5kZXJdID0gMDsKICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">WithdrawalContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">richest</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">mostSent</span><span class="p">;</span>

<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pendingWithdrawals<span class="p">;</span>

<span class="w">    </span><span class="c1">/// 发送的以太数量不高于目前的最高量。</span>
<span class="w">    </span>error<span class="w"> </span>NotEnoughEther<span class="p">();</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>richest<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">        </span>mostSent<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">becomeRichest</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>mostSent<span class="p">)</span><span class="w"> </span>revert<span class="w"> </span>NotEnoughEther<span class="p">();</span>
<span class="w">        </span>pendingWithdrawals<span class="p">[</span>richest<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">        </span>richest<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">        </span>mostSent<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pendingWithdrawals<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">        </span><span class="c1">// 记得在发送前将待处理的退款归零，</span>
<span class="w">        </span><span class="c1">// 以防止重入攻击</span>
<span class="w">        </span>pendingWithdrawals<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是一个相反的直接使用发送模式的例子：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFNlbmRDb250cmFjdCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHJpY2hlc3Q7CiAgICB1aW50IHB1YmxpYyBtb3N0U2VudDsKCiAgICAvLy8g5Y+R6YCB55qE5Lul5aSq5pWw6YeP5LiN6auY5LqO55uu5YmN55qE5pyA6auY6YeP44CCCiAgICBlcnJvciBOb3RFbm91Z2hFdGhlcigpOwoKICAgIGNvbnN0cnVjdG9yKCkgcGF5YWJsZSB7CiAgICAgICAgcmljaGVzdCA9IHBheWFibGUobXNnLnNlbmRlcik7CiAgICAgICAgbW9zdFNlbnQgPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gYmVjb21lUmljaGVzdCgpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICBpZiAobXNnLnZhbHVlIDw9IG1vc3RTZW50KSByZXZlcnQgTm90RW5vdWdoRXRoZXIoKTsKICAgICAgICAvLyDov5nkuIDooYzkvJrlr7zoh7Tpl67popjvvIjor6bop4HkuIvmlofvvIkKICAgICAgICByaWNoZXN0LnRyYW5zZmVyKG1zZy52YWx1ZSk7CiAgICAgICAgcmljaGVzdCA9IHBheWFibGUobXNnLnNlbmRlcik7CiAgICAgICAgbW9zdFNlbnQgPSBtc2cudmFsdWU7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">SendContract</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>richest<span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">mostSent</span><span class="p">;</span>

<span class="w">    </span><span class="c1">/// 发送的以太数量不高于目前的最高量。</span>
<span class="w">    </span>error<span class="w"> </span>NotEnoughEther<span class="p">();</span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>richest<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span>mostSent<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">becomeRichest</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>mostSent<span class="p">)</span><span class="w"> </span>revert<span class="w"> </span>NotEnoughEther<span class="p">();</span>
<span class="w">        </span><span class="c1">// 这一行会导致问题（详见下文）</span>
<span class="w">        </span>richest<span class="p">.</span>transfer<span class="p">(</span><span class="k">msg.value</span><span class="p">);</span>
<span class="w">        </span>richest<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span>mostSent<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，在这个例子中，攻击者可以通过使 <code class="docutils literal notranslate"><span class="pre">richest</span></code> 成为一个有 receive 或 fallback 函数的合约的地址
而使合约陷入无法使用的状态（例如，通过使用 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 或只是消耗超过转给他们的2300 gas 津贴）。
这样，每当调用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 向 “中毒” 的合约交付资金时，它就会失败，
因此 <code class="docutils literal notranslate"><span class="pre">becomeRichest</span></code> 也会失败，合约会永远被卡住。</p>
<p>相反，如果您使用第一个例子中的 “取回（withdraw）”模式，
那么攻击者只能使他/她自己的“取回”失败，并不会导致整个合约无法运作。</p>
</section>
<section id="index-1">
<span id="id3"></span><h3>限制访问<a class="headerlink" href="#index-1" title="此标题的永久链接"></a></h3>
<p>限制访问是合约的一个常见模式。
请注意，您永远无法限制任何人类或机器阅读您的交易内容或您的合约状态。
您可以通过使用加密来增加一点难度，
但如果您想让您的合约读取这些数据，那么其他人也将可以做到。</p>
<p>您可以限制 <strong>其他合约</strong> 对您的合约状态的读取权限。
这实际上是默认的，除非您声明您的状态变量为 <code class="docutils literal notranslate"><span class="pre">public</span></code>。</p>
<p>此外，您可以限制谁可以对您的合约的状态进行修改或调用您的合约的功能，
这就是本节的内容。</p>
<p id="index-2">使用 <strong>函数修饰符</strong> 使这些限制变得非常明确。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IEFjY2Vzc1Jlc3RyaWN0aW9uIHsKICAgIC8vIOi/meS6m+WwhuWcqOaehOmAoOmYtuauteiiq+i1i+WAvAogICAgLy8g5YW25Lit77yMYG1zZy5zZW5kZXJgIOaYrwogICAgLy8g5Yib5bu66L+Z5Liq5ZCI57qm55qE6LSm5oi344CCCiAgICBhZGRyZXNzIHB1YmxpYyBvd25lciA9IG1zZy5zZW5kZXI7CiAgICB1aW50IHB1YmxpYyBjcmVhdGlvblRpbWUgPSBibG9jay50aW1lc3RhbXA7CgogICAgLy8g546w5Zyo5YiX5Ye65LqG6K+l5ZCI57qm5Y+v6IO95Lqn55Sf55qE6ZSZ6K+v77yMCiAgICAvLyDlubblnKjnibnliKvms6jph4rkuK3kvZzkuobmloflrZfop6Pph4rjgIIKCiAgICAvLy8g6LCD55So6ICF5pyq6KKr5o6I5p2D6L+b6KGM5q2k5pON5L2c44CCCiAgICBlcnJvciBVbmF1dGhvcml6ZWQoKTsKCiAgICAvLy8g5Ye95pWw6LCD55So6L+H5pep44CCCiAgICBlcnJvciBUb29FYXJseSgpOwoKICAgIC8vLyDlh73mlbDosIPnlKjml7bmsqHmnInlj5HpgIHotrPlpJ/nmoTku6XlpKrjgIIKICAgIGVycm9yIE5vdEVub3VnaEV0aGVyKCk7CgogICAgLy8g5L+u6aWw5Zmo5Y+v5Lul55So5p2l5pu05pS5CiAgICAvLyDkuIDkuKrlh73mlbDnmoTlh73mlbDkvZPjgIIKICAgIC8vIOWmguaenOS9v+eUqOi/meS4quS/rumlsOWZqO+8jAogICAgLy8g5a6D5Lya6aKE572u5LiA5Liq5qOA5p+l77yM5LuF5YWB6K64CiAgICAvLyDmnaXoh6rnibnlrprlnLDlnYDnmoQKICAgIC8vIOWHveaVsOiwg+eUqOOAggogICAgbW9kaWZpZXIgb25seUJ5KGFkZHJlc3MgYWNjb3VudCkKICAgIHsKICAgICAgICBpZiAobXNnLnNlbmRlciAhPSBhY2NvdW50KQogICAgICAgICAgICByZXZlcnQgVW5hdXRob3JpemVkKCk7CiAgICAgICAgLy8g5LiN6KaB5b+Y6K6w5YaZIOKAnF874oCd77yBCiAgICAgICAgLy8g5a6D5Lya6KKr5a6e6ZmF5L2/55So6L+Z5Liq5L+u6aWw5Zmo55qECiAgICAgICAgLy8g5Ye95pWw5L2T5omA5pu/5Luj44CCCiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8g5L2/IGBuZXdPd25lcmAg5oiQ5Li66L+Z5Liq5ZCI57qm55qE5paw5omA5pyJ6ICF44CCCiAgICBmdW5jdGlvbiBjaGFuZ2VPd25lcihhZGRyZXNzIG5ld093bmVyKQogICAgICAgIHB1YmxpYwogICAgICAgIG9ubHlCeShvd25lcikKICAgIHsKICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQoKICAgIG1vZGlmaWVyIG9ubHlBZnRlcih1aW50IHRpbWUpIHsKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wIDwgdGltZSkKICAgICAgICAgICAgcmV2ZXJ0IFRvb0Vhcmx5KCk7CiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8g5oq55o6J5omA5pyJ6ICF5L+h5oGv44CCCiAgICAvLy8g5LuF5YWB6K645Zyo5ZCI57qm5Yib5bu65oiQ5YqfIDYg5ZGo5Lul5ZCOCiAgICAvLy8g55qE5pe26Ze06KKr6LCD55So44CCCiAgICBmdW5jdGlvbiBkaXNvd24oKQogICAgICAgIHB1YmxpYwogICAgICAgIG9ubHlCeShvd25lcikKICAgICAgICBvbmx5QWZ0ZXIoY3JlYXRpb25UaW1lICsgNiB3ZWVrcykKICAgIHsKICAgICAgICBkZWxldGUgb3duZXI7CiAgICB9CgogICAgLy8g6L+Z5Liq5L+u6aWw5Zmo6KaB5rGC5a+55Ye95pWw6LCD55SoCiAgICAvLyDnu5HlrprkuIDlrprnmoTotLnnlKjjgIIKICAgIC8vIOWmguaenOiwg+eUqOaWueWPkemAgeS6hui/h+WkmueahOi0ueeUqO+8jAogICAgLy8g5LuWL+WlueS8muW+l+WIsOmAgOasvu+8jOS9humcgOimgeWFiOaJp+ihjOWHveaVsOS9k+OAggogICAgLy8g6L+Z5ZyoIDAuNC4wIOeJiOacrOS7peWJjeeahCBTb2xpZGl0eSDkuK3lvojljbHpmanvvIwKICAgIC8vIOWboOS4uuW+iOWPr+iDveS8mui3s+i/hyBgXztgIOS5i+WQjueahOS7o+eggeOAggogICAgbW9kaWZpZXIgY29zdHModWludCBhbW91bnQpIHsKICAgICAgICBpZiAobXNnLnZhbHVlIDwgYW1vdW50KQogICAgICAgICAgICByZXZlcnQgTm90RW5vdWdoRXRoZXIoKTsKCiAgICAgICAgXzsKICAgICAgICBpZiAobXNnLnZhbHVlID4gYW1vdW50KQogICAgICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKG1zZy52YWx1ZSAtIGFtb3VudCk7CiAgICB9CgogICAgZnVuY3Rpb24gZm9yY2VPd25lckNoYW5nZShhZGRyZXNzIG5ld093bmVyKQogICAgICAgIHB1YmxpYwogICAgICAgIHBheWFibGUKICAgICAgICBjb3N0cygyMDAgZXRoZXIpCiAgICB7CiAgICAgICAgb3duZXIgPSBuZXdPd25lcjsKICAgICAgICAvLyDov5nlj6rmmK/npLrkvovmnaHku7YKICAgICAgICBpZiAodWludDE2MChvd25lcikgJiAwID09IDEpCiAgICAgICAgICAgIC8vIOi/meaXoOazleWcqCAwLjQuMCDniYjmnKzkuYvliY3nmoQKICAgICAgICAgICAgLy8gU29saWRpdHkg5LiK6L+b6KGM6YCA6L+Y44CCCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAvLyDpgIDov5jlpJrku5jnmoTotLnnlKgKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">AccessRestriction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 这些将在构造阶段被赋值</span>
<span class="w">    </span><span class="c1">// 其中，`msg.sender` 是</span>
<span class="w">    </span><span class="c1">// 创建这个合约的账户。</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">creationTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">block.timestamp</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 现在列出了该合约可能产生的错误，</span>
<span class="w">    </span><span class="c1">// 并在特别注释中作了文字解释。</span>

<span class="w">    </span><span class="c1">/// 调用者未被授权进行此操作。</span>
<span class="w">    </span>error<span class="w"> </span>Unauthorized<span class="p">();</span>

<span class="w">    </span><span class="c1">/// 函数调用过早。</span>
<span class="w">    </span>error<span class="w"> </span>TooEarly<span class="p">();</span>

<span class="w">    </span><span class="c1">/// 函数调用时没有发送足够的以太。</span>
<span class="w">    </span>error<span class="w"> </span>NotEnoughEther<span class="p">();</span>

<span class="w">    </span><span class="c1">// 修饰器可以用来更改</span>
<span class="w">    </span><span class="c1">// 一个函数的函数体。</span>
<span class="w">    </span><span class="c1">// 如果使用这个修饰器，</span>
<span class="w">    </span><span class="c1">// 它会预置一个检查，仅允许</span>
<span class="w">    </span><span class="c1">// 来自特定地址的</span>
<span class="w">    </span><span class="c1">// 函数调用。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyBy<span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">account</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>account<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>Unauthorized<span class="p">();</span>
<span class="w">        </span><span class="c1">// 不要忘记写 “_;”！</span>
<span class="w">        </span><span class="c1">// 它会被实际使用这个修饰器的</span>
<span class="w">        </span><span class="c1">// 函数体所替代。</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 使 `newOwner` 成为这个合约的新所有者。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeOwner</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>onlyBy<span class="p">(</span>owner<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyAfter<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>time<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>TooEarly<span class="p">();</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// 抹掉所有者信息。</span>
<span class="w">    </span><span class="c1">/// 仅允许在合约创建成功 6 周以后</span>
<span class="w">    </span><span class="c1">/// 的时间被调用。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">disown</span><span class="p">()</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>onlyBy<span class="p">(</span>owner<span class="p">)</span>
<span class="w">        </span>onlyAfter<span class="p">(</span>creationTime<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">6</span><span class="w"> </span>weeks<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>delete<span class="w"> </span>owner<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 这个修饰器要求对函数调用</span>
<span class="w">    </span><span class="c1">// 绑定一定的费用。</span>
<span class="w">    </span><span class="c1">// 如果调用方发送了过多的费用，</span>
<span class="w">    </span><span class="c1">// 他/她会得到退款，但需要先执行函数体。</span>
<span class="w">    </span><span class="c1">// 这在 0.4.0 版本以前的 Solidity 中很危险，</span>
<span class="w">    </span><span class="c1">// 因为很可能会跳过 `_;` 之后的代码。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>costs<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>amount<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>NotEnoughEther<span class="p">();</span>

<span class="w">        </span>_<span class="p">;</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>amount<span class="p">)</span>
<span class="w">            </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">).</span>transfer<span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span>amount<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">forceOwnerChange</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span><span class="kt">payable</span>
<span class="w">        </span>costs<span class="p">(</span><span class="m m-Decimal">200</span><span class="w"> </span>ether<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span>
<span class="w">        </span><span class="c1">// 这只是示例条件</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="kt">uint160</span><span class="p">(</span>owner<span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">)</span>
<span class="w">            </span><span class="c1">// 这无法在 0.4.0 版本之前的</span>
<span class="w">            </span><span class="c1">// Solidity 上进行退还。</span>
<span class="w">            </span><span class="kt">return</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 退还多付的费用</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在下一个例子中，将讨论一种更专业的限制函数调用访问的方式。</p>
</section>
<section id="index-3">
<span id="id4"></span><h3>状态机<a class="headerlink" href="#index-3" title="此标题的永久链接"></a></h3>
<p>合约通常会像状态机那样运作，这意味着它们有特定的 <strong>阶段</strong>，
使它们有不同的表现或者仅允许特定的不同函数被调用。
一个函数调用通常会结束一个阶段，
并将合约转换到下一个阶段（特别是如果一个合约是以 <strong>交互</strong> 来建模的时候）。
通过达到特定的 <strong>时间</strong> 点来达到某些阶段也是很常见的。</p>
<p>一个典型的例子是盲拍（blind auction）合约，
它起始于“接受盲目出价”，
然后转换到“公示出价”，
最后结束于“确定拍卖结果”。</p>
<p id="index-4">函数修饰器可以用在这种情况下来对状态进行建模，
并确保合约被正常的使用。</p>
<section id="id5">
<h4>示例<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<p>在下边的示例中， 修饰器 <code class="docutils literal notranslate"><span class="pre">atStage</span></code> 确保了函数仅在特定的阶段才可以被调用。</p>
<p>自动定时过渡是由修饰器 <code class="docutils literal notranslate"><span class="pre">timedTransitions</span></code> 处理的，它应该用于所有函数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>修饰器的顺序非常重要</strong>.
如果 atStage 和 timedTransitions 要一起使用，
请确保在 timedTransitions 之后声明 atStage，
以便新的状态可以 首先被反映到账户中。</p>
</div>
<p>最后， 修饰器 <code class="docutils literal notranslate"><span class="pre">transitionNext</span></code> 能够用来在函数执行结束时自动转换到下一个阶段。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>修饰器可以被忽略</strong>.
这只适用于0.4.0版本之前的Solidity：
由于修饰器是通过简单地替换代码而不是使用函数调用来应用的，
如果函数本身使用 return，可以跳过 transitionNext 修饰器中的代码。
如果您想这样做，请确保从这些函数中手动调用 nextStage。
从0.4.0版本开始，即使函数明确返回，修饰器代码也会运行。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFN0YXRlTWFjaGluZSB7CiAgICBlbnVtIFN0YWdlcyB7CiAgICAgICAgQWNjZXB0aW5nQmxpbmRlZEJpZHMsCiAgICAgICAgUmV2ZWFsQmlkcywKICAgICAgICBBbm90aGVyU3RhZ2UsCiAgICAgICAgQXJlV2VEb25lWWV0LAogICAgICAgIEZpbmlzaGVkCiAgICB9CiAgICAvLy8g5q2k6Zi25q615LiN6IO96LCD55So6K+l5Ye95pWw44CCCiAgICBlcnJvciBGdW5jdGlvbkludmFsaWRBdFRoaXNTdGFnZSgpOwoKICAgIC8vIOi/meaYr+W9k+WJjemYtuauteOAggogICAgU3RhZ2VzIHB1YmxpYyBzdGFnZSA9IFN0YWdlcy5BY2NlcHRpbmdCbGluZGVkQmlkczsKCiAgICB1aW50IHB1YmxpYyBjcmVhdGlvblRpbWUgPSBibG9jay50aW1lc3RhbXA7CgogICAgbW9kaWZpZXIgYXRTdGFnZShTdGFnZXMgc3RhZ2VfKSB7CiAgICAgICAgaWYgKHN0YWdlICE9IHN0YWdlXykKICAgICAgICAgICAgcmV2ZXJ0IEZ1bmN0aW9uSW52YWxpZEF0VGhpc1N0YWdlKCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBuZXh0U3RhZ2UoKSBpbnRlcm5hbCB7CiAgICAgICAgc3RhZ2UgPSBTdGFnZXModWludChzdGFnZSkgKyAxKTsKICAgIH0KCiAgICAvLyDmiafooYzln7rkuo7ml7bpl7TnmoTpmLbmrrXovazmjaLjgIIKICAgIC8vIOivt+ehruS/nemmluWFiOWjsOaYjui/meS4quS/rumlsOWZqO+8jAogICAgLy8g5ZCm5YiZ5paw6Zi25q615LiN5Lya6KKr5bim5YWl6LSm5oi344CCCiAgICBtb2RpZmllciB0aW1lZFRyYW5zaXRpb25zKCkgewogICAgICAgIGlmIChzdGFnZSA9PSBTdGFnZXMuQWNjZXB0aW5nQmxpbmRlZEJpZHMgJiYKICAgICAgICAgICAgICAgICAgICBibG9jay50aW1lc3RhbXAgPj0gY3JlYXRpb25UaW1lICsgMTAgZGF5cykKICAgICAgICAgICAgbmV4dFN0YWdlKCk7CiAgICAgICAgaWYgKHN0YWdlID09IFN0YWdlcy5SZXZlYWxCaWRzICYmCiAgICAgICAgICAgICAgICBibG9jay50aW1lc3RhbXAgPj0gY3JlYXRpb25UaW1lICsgMTIgZGF5cykKICAgICAgICAgICAgbmV4dFN0YWdlKCk7CiAgICAgICAgLy8g55Sx5Lqk5piT6Kem5Y+R55qE5YW25LuW6Zi25q616L2s5o2iCiAgICAgICAgXzsKICAgIH0KCiAgICAvLyDov5nph4znmoTkv67ppbDlmajpobrluo/pnZ7luLjph43opoHvvIEKICAgIGZ1bmN0aW9uIGJpZCgpCiAgICAgICAgcHVibGljCiAgICAgICAgcGF5YWJsZQogICAgICAgIHRpbWVkVHJhbnNpdGlvbnMKICAgICAgICBhdFN0YWdlKFN0YWdlcy5BY2NlcHRpbmdCbGluZGVkQmlkcykKICAgIHsKICAgICAgICAvLyDmiJHku6zkuI3kvJrlnKjov5nph4zlrp7njrDlrp7pmYXlip/og73vvIjlm6DkuLrov5nku4XmmK/kuKrku6PnoIHnpLrkvovvvIzor5HogIXms6jvvIkKICAgIH0KCiAgICBmdW5jdGlvbiByZXZlYWwoKQogICAgICAgIHB1YmxpYwogICAgICAgIHRpbWVkVHJhbnNpdGlvbnMKICAgICAgICBhdFN0YWdlKFN0YWdlcy5SZXZlYWxCaWRzKQogICAgewogICAgfQoKICAgIC8vIOi/meS4quS/rumlsOWZqOWcqOWHveaVsOaJp+ihjOe7k+adn+S5i+WQjgogICAgLy8g5L2/5ZCI57qm6L+b5YWl5LiL5LiA5Liq6Zi25q6144CCCiAgICBtb2RpZmllciB0cmFuc2l0aW9uTmV4dCgpCiAgICB7CiAgICAgICAgXzsKICAgICAgICBuZXh0U3RhZ2UoKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkKICAgICAgICBwdWJsaWMKICAgICAgICB0aW1lZFRyYW5zaXRpb25zCiAgICAgICAgYXRTdGFnZShTdGFnZXMuQW5vdGhlclN0YWdlKQogICAgICAgIHRyYW5zaXRpb25OZXh0CiAgICB7CiAgICB9CgogICAgZnVuY3Rpb24gaCgpCiAgICAgICAgcHVibGljCiAgICAgICAgdGltZWRUcmFuc2l0aW9ucwogICAgICAgIGF0U3RhZ2UoU3RhZ2VzLkFyZVdlRG9uZVlldCkKICAgICAgICB0cmFuc2l0aW9uTmV4dAogICAgewogICAgfQoKICAgIGZ1bmN0aW9uIGkoKQogICAgICAgIHB1YmxpYwogICAgICAgIHRpbWVkVHJhbnNpdGlvbnMKICAgICAgICBhdFN0YWdlKFN0YWdlcy5GaW5pc2hlZCkKICAgIHsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">StateMachine</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">Stages</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>AcceptingBlindedBids<span class="p">,</span>
<span class="w">        </span>RevealBids<span class="p">,</span>
<span class="w">        </span>AnotherStage<span class="p">,</span>
<span class="w">        </span>AreWeDoneYet<span class="p">,</span>
<span class="w">        </span>Finished
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">/// 此阶段不能调用该函数。</span>
<span class="w">    </span>error<span class="w"> </span>FunctionInvalidAtThisStage<span class="p">();</span>

<span class="w">    </span><span class="c1">// 这是当前阶段。</span>
<span class="w">    </span>Stages<span class="w"> </span><span class="kt">public</span><span class="w"> </span>stage<span class="w"> </span><span class="o">=</span><span class="w"> </span>Stages<span class="p">.</span>AcceptingBlindedBids<span class="p">;</span>

<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">creationTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">block.timestamp</span><span class="p">;</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>atStage<span class="p">(</span>Stages<span class="w"> </span>stage_<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>stage<span class="w"> </span><span class="o">!=</span><span class="w"> </span>stage_<span class="p">)</span>
<span class="w">            </span>revert<span class="w"> </span>FunctionInvalidAtThisStage<span class="p">();</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">nextStage</span><span class="p">()</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>stage<span class="w"> </span><span class="o">=</span><span class="w"> </span>Stages<span class="p">(</span><span class="kt">uint</span><span class="p">(</span>stage<span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 执行基于时间的阶段转换。</span>
<span class="w">    </span><span class="c1">// 请确保首先声明这个修饰器，</span>
<span class="w">    </span><span class="c1">// 否则新阶段不会被带入账户。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>timedTransitions<span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>stage<span class="w"> </span><span class="o">==</span><span class="w"> </span>Stages<span class="p">.</span>AcceptingBlindedBids<span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>creationTime<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="w"> </span>days<span class="p">)</span>
<span class="w">            </span>nextStage<span class="p">();</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>stage<span class="w"> </span><span class="o">==</span><span class="w"> </span>Stages<span class="p">.</span>RevealBids<span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                </span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>creationTime<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">12</span><span class="w"> </span>days<span class="p">)</span>
<span class="w">            </span>nextStage<span class="p">();</span>
<span class="w">        </span><span class="c1">// 由交易触发的其他阶段转换</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 这里的修饰器顺序非常重要！</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">bid</span><span class="p">()</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span><span class="kt">payable</span>
<span class="w">        </span>timedTransitions
<span class="w">        </span>atStage<span class="p">(</span>Stages<span class="p">.</span>AcceptingBlindedBids<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 我们不会在这里实现实际功能（因为这仅是个代码示例，译者注）</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">reveal</span><span class="p">()</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>timedTransitions
<span class="w">        </span>atStage<span class="p">(</span>Stages<span class="p">.</span>RevealBids<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 这个修饰器在函数执行结束之后</span>
<span class="w">    </span><span class="c1">// 使合约进入下一个阶段。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>transitionNext<span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">        </span>nextStage<span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>timedTransitions
<span class="w">        </span>atStage<span class="p">(</span>Stages<span class="p">.</span>AnotherStage<span class="p">)</span>
<span class="w">        </span>transitionNext
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">h</span><span class="p">()</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>timedTransitions
<span class="w">        </span>atStage<span class="p">(</span>Stages<span class="p">.</span>AreWeDoneYet<span class="p">)</span>
<span class="w">        </span>transitionNext
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">i</span><span class="p">()</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">        </span>timedTransitions
<span class="w">        </span>atStage<span class="p">(</span>Stages<span class="p">.</span>Finished<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<span id="document-bugs"></span><section id="bug">
<span id="known-bugs"></span><span id="index-0"></span><h2>已知bug列表<a class="headerlink" href="#bug" title="此标题的永久链接"></a></h2>
<p>下面，您可以找到一个JSON格式的列表，其中包括Solidity编译器中一些已知的与安全有关的错误。
该文件本身托管在 <a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/docs/bugs.json">Github 仓库</a>。
该列表最早可以追溯到0.3.0版本，只有在此之前的版本中已知的错误没有列出。</p>
<p>还有一个文件叫
<a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/docsbugs_by_version.json">bugs_by_version.json</a>，
它可以用来检查哪些bug影响到特定版本的编译器。</p>
<p>合约源码验证工具以及其他与合约交互的工具应根据以下标准查阅此列表：</p>
<ul class="simple">
<li><p>如果合约是用夜间编译器版本而不是发布版本编译的，那就有点可疑了。
此列表不跟踪未发布或夜间版本。</p></li>
<li><p>如果合约的编译版本不是合约创建时的最新版本，则也有点可疑。
对于从其他合约创建的合约，您必须按照创建链返回到事务，并使用该事务的日期作为创建日期。</p></li>
<li><p>如果合约是用包含已知bug的编译器编译的，并且合约是在已发布包含修复程序的较新编译器版本时创建的，
则这是高度可疑的。</p></li>
</ul>
<p>下面的已知错误的JSON文件是一个对象数组，每个错误都有一个对象，其键值如下：</p>
<dl class="simple">
<dt>uid</dt><dd><p>以 <code class="docutils literal notranslate"><span class="pre">SOL-&lt;year&gt;-&lt;number&gt;</span></code> 的形式给予该错误的唯一标识符。
有可能存在多个具有相同uid的条目。
这意味着多个版本范围受到同一错误的影响。</p>
</dd>
<dt>name</dt><dd><p>给予该错误的唯一名称</p>
</dd>
<dt>summary</dt><dd><p>对该错误的简短描述</p>
</dd>
<dt>description</dt><dd><p>该错误的详细描述</p>
</dd>
<dt>link</dt><dd><p>有更多详细信息的网站的URL，可选</p>
</dd>
<dt>introduced</dt><dd><p>第一个包含该错误的发布的编译器版本，可选</p>
</dd>
<dt>fixed</dt><dd><p>第一个不再包含该错误的发布的编译器版本</p>
</dd>
<dt>publish</dt><dd><p>bug公开的日期，可选</p>
</dd>
<dt>severity</dt><dd><p>bug的严重程度：非常低，低，中，高。
考虑合约测试中的可发现性，发生的可能性和错误造成的潜在损害。</p>
</dd>
<dt>conditions</dt><dd><p>必须满足的条件才能触发该错误。可以使用以下键：
<code class="docutils literal notranslate"><span class="pre">optimizer</span></code>, 布尔值，表示优化器必须打开才会出现该错误。
<code class="docutils literal notranslate"><span class="pre">evmVersion</span></code>, 一个字符串，表示哪个EVM版本的编译器设置触发了该错误。
这个字符串可以包含比较运算符。例如， <code class="docutils literal notranslate"><span class="pre">&quot;&gt;=constantinople&quot;</span></code> 表示
当EVM版本设置为 <code class="docutils literal notranslate"><span class="pre">constantinople</span></code> 或更高时，该错误就会出现。
如果没有给出条件，则假定该错误存在。</p>
</dd>
<dt>check</dt><dd><p>这个字段包含不同的检查，报告智能合约是否包含错误。
第一种类型的检查是Javascript正则表达式，如果存在该错误，将与源代码（“source-regex”）进行匹配。
如果没有匹配，那么该漏洞很可能不存在。如果有一个匹配，则该错误可能存在。
为了提高准确性，检查应该在剥离注释后应用于源代码。
第二种类型的检查是在Solidity程序的紧凑AST上检查的模式（“ast-compact-json path”）。
指定的搜索查询是一个 <a class="reference external" href="https://github.com/json-path/JsonPath">JsonPath</a> 表达式。
如果Solidity AST中至少有一个路径与该查询相匹配，则该错误可能存在。</p>
</dd>
</dl>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;StorageWriteRemovalBeforeConditionalTermination&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling functions that conditionally terminate the external EVM call using the assembly statements ``return(...)`` or ``stop()`` may result in incorrect removals of prior storage writes.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;A call to a Yul function that conditionally terminates the external EVM call could result in prior storage writes being incorrectly removed by the Yul optimizer. This used to happen in cases in which it would have been valid to remove the store, if the Yul function in question never actually terminated the external call, and the control flow always returned back to the caller instead. Conditional termination within the same Yul block instead of within a called function was not affected. In Solidity with optimized via-IR code generation, any storage write before a function conditionally calling ``return(...)`` or ``stop()`` in inline assembly, may have been incorrectly removed, whenever it would have been valid to remove the write without the ``return(...)`` or ``stop()``. In optimized legacy code generation, only inline assembly that did not refer to any Solidity variables and that involved conditionally-terminating user-defined assembly functions could be affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/09/08/storage-write-removal-before-conditional-termination/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.13&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.17&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;AbiReencodingHeadOverflowWithStaticArrayCleanup&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABI-encoding a tuple with a statically-sized calldata array in the last component would corrupt 32 leading bytes of its first dynamically encoded component.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When ABI-encoding a statically-sized calldata array, the compiler always pads the data area to a multiple of 32-bytes and ensures that the padding bytes are zeroed. In some cases, this cleanup used to be performed by always writing exactly 32 bytes, regardless of how many needed to be zeroed. This was done with the assumption that the data that would eventually occupy the area past the end of the array had not yet been written, because the encoder processes tuple components in the order they were given. While this assumption is mostly true, there is an important corner case: dynamically encoded tuple components are stored separately from the statically-sized ones in an area called the *tail* of the encoding and the tail immediately follows the *head*, which is where the statically-sized components are placed. The aforementioned cleanup, if performed for the last component of the head would cross into the tail and overwrite up to 32 bytes of the first component stored there with zeros. The only array type for which the cleanup could actually result in an overwrite were arrays with ``uint256`` or ``bytes32`` as the base element type and in this case the size of the corrupted area was always exactly 32 bytes. The problem affected tuples at any nesting level. This included also structs, which are encoded as tuples in the ABI. Note also that lists of parameters and return values of functions, events and errors are encoded as tuples.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/08/08/calldata-tuple-reencoding-head-overflow-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DirtyBytesArrayToStorage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Copying ``bytes`` arrays from memory or calldata to storage may result in dirty storage values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Copying ``bytes`` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. These dirty bytes may then become observable after a ``.push()`` without arguments to the bytes array in storage, i.e. such a push will not result in a zero value at the end of the array as expected. This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;InlineAssemblyMemorySideEffects&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer may incorrectly remove memory writes from inline assembly blocks, that do not access solidity variables.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer considers all memory writes in the outermost Yul block that are never read from as unused and removes them. This is valid when that Yul block is the entire Yul program, which is always the case for the Yul code generated by the new via-IR pipeline. Inline assembly blocks are never optimized in isolation when using that pipeline. Instead they are optimized as a part of the whole Yul input. However, the legacy code generation pipeline (which is still the default) runs the Yul optimizer individually on an inline assembly block if the block does not refer to any local variables defined in the surrounding Solidity code. Consequently, memory writes in such inline assembly blocks are removed as well, if the written memory is never read from in the same assembly block, even if the written memory is accessed later, for example by a subsequent inline assembly block.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.13&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DataLocationChangeInInternalOverride&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;It was possible to change the data location of the parameters or return variables from ``calldata`` to ``memory`` and vice-versa while overriding internal and public functions. This caused invalid code to be generated when calling such a function internally through virtual function calls.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When calling external functions, it is irrelevant if the data location of the parameters is ``calldata`` or ``memory``, the encoding of the data does not change. Because of that, changing the data location when overriding external functions is allowed. The compiler incorrectly also allowed a change in the data location for overriding public and internal functions. Since public functions can be called internally as well as externally, this causes invalid code to be generated when such an incorrectly overridden function is called internally through the base contract. The caller provides a memory pointer, but the called function interprets it as a calldata pointer or vice-versa.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;NestedCallataArrayAbiReencodingSizeValidation&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABI-reencoding of nested dynamic calldata arrays did not always perform proper size checks against the size of calldata and could read beyond ``calldatasize()``.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calldata validation for nested dynamic types is deferred until the first access to the nested values. Such an access may for example be a copy to memory or an index or member access to the outer type. While in most such accesses calldata validation correctly checks that the data area of the nested array is completely contained in the passed calldata (i.e. in the range [0, calldatasize()]), this check may not be performed, when ABI encoding such nested types again directly from calldata. For instance, this can happen, if a value in calldata with a nested dynamic array is passed to an external call, used in ``abi.encode`` or emitted as event. In such cases, if the data area of the nested array extends beyond ``calldatasize()``, ABI encoding it did not revert, but continued reading values from beyond ``calldatasize()`` (i.e. zero values).&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;AbiEncodeCallLiteralAsFixedBytesBug&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Literals used for a fixed length bytes parameter in ``abi.encodeCall`` were encoded incorrectly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;For the encoding, the compiler only considered the types of the expressions in the second argument of ``abi.encodeCall`` itself, but not the parameter types of the function given as first argument. In almost all cases the abi encoding of the type of the expression matches the abi encoding of the parameter type of the given function. This is because the type checker ensures the expression is implicitly convertible to the respective parameter type. However this is not true for number literals used for fixed bytes types shorter than 32 bytes, nor for string literals used for any fixed bytes type. Number literals were encoded as numbers instead of being shifted to become left-aligned. String literals were encoded as dynamically sized memory strings instead of being converted to a left-aligned bytes value.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/03/16/encodecall-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.13&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>

<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UserDefinedValueTypesBug&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;User defined value types with underlying type shorter than 32 bytes used incorrect storage layout and wasted storage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The compiler did not correctly compute the storage layout of user defined value types based on types that are shorter than 32 bytes. It would always use a full storage slot for these types, even if the underlying type was shorter. This was wasteful and might have problems with tooling or contract upgrades.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/09/29/user-defined-value-types-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SignedImmutables&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Immutable variables of signed integer type shorter than 256 bits can lead to values with invalid higher order bits if inline assembly is used.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When immutable variables of signed integer type shorter than 256 bits are read, their higher order bits were unconditionally set to zero. The correct operation would be to sign-extend the value, i.e. set the higher order bits to one if the sign bit is one. This sign-extension is performed by Solidity just prior to when it matters, i.e. when a value is stored in memory, when it is compared or when a division is performed. Because of that, to our knowledge, the only way to access the value in its unclean state is by reading it through inline assembly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/09/29/signed-immutables-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIDecodeTwoDimensionalArrayMemory&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If used on memory byte arrays, result of the function ``abi.decode`` can depend on the contents of memory outside of the actual byte array that is decoded.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The ABI specification uses pointers to data areas for everything that is dynamically-sized. When decoding data from memory (instead of calldata), the ABI decoder did not properly validate some of these pointers. More specifically, it was possible to use large values for the pointers inside arrays such that computing the offset resulted in an undetected overflow. This could lead to these pointers targeting areas in memory outside of the actual area to be decoded. This way, it was possible for ``abi.decode`` to return different values for the same encoded byte array.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/04/21/decoding-from-memory-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;KeccakCaching&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The bytecode optimizer incorrectly re-used previously evaluated Keccak-256 hashes. You are unlikely to be affected if you do not compute Keccak-256 hashes in inline assembly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Solidity&#39;s bytecode optimizer has a step that can compute Keccak-256 hashes, if the contents of the memory are known during compilation time. This step also has a mechanism to determine that two Keccak-256 hashes are equal even if the values in memory are not known during compile time. This mechanism had a bug where Keccak-256 of the same memory content, but different sizes were considered equal. More specifically, ``keccak256(mpos1, length1)`` and ``keccak256(mpos2, length2)`` in some cases were considered equal if ``length1`` and ``length2``, when rounded up to nearest multiple of 32 were the same, and when the memory contents at ``mpos1`` and ``mpos2`` can be deduced to be equal. You maybe affected if you compute multiple Keccak-256 hashes of the same content, but with different lengths inside inline assembly. You are unaffected if your code uses ``keccak256`` with a length that is not a compile-time constant or if it is always a multiple of 32.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/03/23/keccak-optimizer-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;EmptyByteArrayCopy&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Copying an empty byte array (or string) from memory or calldata to storage can result in data corruption if the target array&#39;s length is increased subsequently without storing new data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The routine that copies byte arrays from memory or calldata to storage stores unrelated data from after the source array in the storage slot if the source array is empty. If the storage array&#39;s length is subsequently increased either by using ``.push()`` or by assigning to its ``.length`` attribute (only before 0.6.0), the newly created byte array elements will not be zero-initialized, but contain the unrelated data. You are not affected if you do not assign to ``.length`` and do not use ``.push()`` on byte arrays, or only use ``.push(&lt;arg&gt;)`` or manually initialize the new elements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2020/10/19/empty-byte-array-copy-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DynamicArrayCleanup&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When assigning a dynamically-sized array with types of size at most 16 bytes in storage causing the assigned array to shrink, some parts of deleted slots were not zeroed out.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Consider a dynamically-sized array in storage whose base-type is small enough such that multiple values can be packed into a single slot, such as `uint128[]`. Let us define its length to be `l`. When this array gets assigned from another array with a smaller length, say `m`, the slots between elements `m` and `l` have to be cleaned by zeroing them out. However, this cleaning was not performed properly. Specifically, after the slot corresponding to `m`, only the first packed value was cleaned up. If this array gets resized to a length larger than `m`, the indices corresponding to the unclean parts of the slot contained the original value, instead of 0. The resizing here is performed by assigning to the array `length`, by a `push()` or via inline assembly. You are not affected if you are only using `.push(&lt;arg&gt;)` or if you assign a value (even zero) to the new elements after increasing the length of the array.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2020/10/07/solidity-dynamic-array-cleanup-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;FreeFunctionRedefinition&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The compiler does not flag an error when two or more free functions with the same name and parameter types are defined in a source unit or when an imported free function alias shadows another free function with a different name but identical parameter types.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;In contrast to functions defined inside contracts, free functions with identical names and parameter types did not create an error. Both definition of free functions with identical name and parameter types and an imported free function with an alias that shadows another function with a different name but identical parameter types were permitted due to which a call to either the multiply defined free function or the imported free function alias within a contract led to the execution of that free function which was defined first within the source unit. Subsequently defined identical free function definitions were silently ignored and their code generation was skipped.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UsingForCalldata&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Function calls to internal library functions with calldata parameters called via ``using for`` can result in invalid data being read.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Function calls to internal library functions using the ``using for`` mechanism copied all calldata parameters to memory first and passed them on like that, regardless of whether it was an internal or an external call. Due to that, the called function would receive a memory pointer that is interpreted as a calldata pointer. Since dynamically sized arrays are passed using two stack slots for calldata, but only one for memory, this can lead to stack corruption. An affected library call will consider the JUMPDEST to which it is supposed to return as part of its arguments and will instead jump out to whatever was on the stack before the call.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MissingEscapingInFormatting&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;String literals containing double backslash characters passed directly to external or encoding function calls can lead to a different string being used when ABIEncoderV2 is enabled.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When ABIEncoderV2 is enabled, string literals passed directly to encoding functions or external function calls are stored as strings in the intemediate code. Characters outside the printable range are handled correctly, but backslashes are not escaped in this procedure. This leads to double backslashes being reduced to single backslashes and consequently re-interpreted as escapes potentially resulting in a different string being encoded.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ArraySliceDynamicallyEncodedBaseType&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Accessing array slices of arrays with dynamically encoded base types (e.g. multi-dimensional arrays) can result in invalid data being read.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;For arrays with dynamically sized base types, index range accesses that use a start expression that is non-zero will result in invalid array slices. Any index access to such array slices will result in data being read from incorrect calldata offsets. Array slices are only supported for dynamic calldata types and all problematic type require ABIEncoderV2 to be enabled.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ImplicitConstructorCallvalueCheck&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The creation code of a contract that does not define a constructor but has a base that does define a constructor did not revert for calls with non-zero value.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Starting from Solidity 0.4.5 the creation code of contracts without explicit payable constructor is supposed to contain a callvalue check that results in contract creation reverting, if non-zero value is passed. However, this check was missing in case no explicit constructor was defined in a contract at all, but the contract has a base that does define a constructor. In these cases it is possible to send value in a contract creation transaction or using inline assembly without revert, even though the creation code is supposed to be non-payable.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;TupleAssignmentMultiStackSlotComponents&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Tuple assignments with components that occupy several stack slots, i.e. nested tuples, pointers to external functions or references to dynamically sized calldata arrays, can result in invalid values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Tuple assignments did not correctly account for tuple components that occupy multiple stack slots in case the number of stack slots differs between left-hand-side and right-hand-side. This can either happen in the presence of nested tuples or if the right-hand-side contains external function pointers or references to dynamic calldata arrays, while the left-hand-side contains an omission.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.1.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MemoryArrayCreationOverflow&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The creation of very large memory arrays can result in overlapping memory regions and thus memory corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;No runtime overflow checks were performed for the length of memory arrays during creation. In cases for which the memory size of an array in bytes, i.e. the array length times 32, is larger than 2^256-1, the memory allocation will overflow, potentially resulting in overlapping memory areas. The length of the array is still stored correctly, so copying or iterating over such an array will result in out-of-gas.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2020/04/06/memory-creation-overflow-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.2.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;YulOptimizerRedundantAssignmentBreakContinue&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul&#39;s continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer has a stage that removes assignments to variables that are overwritten again or are not used in all following control-flow branches. This logic incorrectly removes such assignments to variables declared inside a for loop if they can be removed in a control-flow branch that ends with ``break`` or ``continue`` even though they cannot be removed in other control-flow branches. Variables declared outside of the respective for loop are not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;privateCanBeOverridden&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Private methods can be overridden by inheriting contracts.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;While private methods of base contracts are not visible and cannot be called directly from the derived contract, it is still possible to declare a function of the same name and type and thus change the behaviour of the base contract&#39;s function.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.17&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;YulOptimizerRedundantAssignmentBreakContinue0.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul&#39;s continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer has a stage that removes assignments to variables that are overwritten again or are not used in all following control-flow branches. This logic incorrectly removes such assignments to variables declared inside a for loop if they can be removed in a control-flow branch that ends with ``break`` or ``continue`` even though they cannot be removed in other control-flow branches. Variables declared outside of the respective for loop are not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2LoopYulOptimizer&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If both the experimental ABIEncoderV2 and the experimental Yul optimizer are activated, one component of the Yul optimizer may reuse data in memory that has been changed in the meantime.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer incorrectly replaces ``mload`` and ``sload`` calls with values that have been previously written to the load location (and potentially changed in the meantime) if all of the following conditions are met: (1) there is a matching ``mstore`` or ``sstore`` call before; (2) the contents of memory or storage is only changed in a function that is called (directly or indirectly) in between the first store and the load call; (3) called function contains a for loop where the same memory location is changed in the condition or the post or body block. When used in Solidity mode, this can only happen if the experimental ABIEncoderV2 is activated and the experimental Yul optimizer has been activated manually in addition to the regular optimizer in the compiler settings.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2CalldataStructsWithStaticallySizedAndDynamicallyEncodedMembers&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Reading from calldata structs that contain dynamically encoded, but statically-sized members can result in incorrect values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When a calldata struct contains a dynamically encoded, but statically-sized member, the offsets for all subsequent struct members are calculated incorrectly. All reads from such members will result in invalid values. Only calldata structs are affected, i.e. this occurs in external functions with such structs as argument. Using affected structs in storage or memory or as arguments to public functions on the other hand works correctly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SignedArrayStorageCopy&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Assigning an array of signed integers to a storage array of different type can lead to data corruption in that array.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;In two&#39;s complement, negative integers have their higher order bits set. In order to fit into a shared storage slot, these have to be set to zero. When a conversion is done at the same time, the bits to set to zero were incorrectly determined from the source and not the target type. This means that such copy operations can lead to incorrect values being stored.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low/medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2StorageArrayWithMultiSlotElement&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Storage arrays containing structs or other statically-sized arrays are not read properly when directly encoded in external function calls or in abi.encode*.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When storage arrays whose elements occupy more than a single storage slot are directly encoded in external function calls or using abi.encode*, their elements are read in an overlapping manner, i.e. the element pointer is not properly advanced between reads. This is not a problem when the storage data is first copied to a memory variable or if the storage array only contains value types or dynamically-sized arrays.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DynamicConstructorArgumentsClippedABIV2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;A contract&#39;s constructor that takes structs or arrays that contain dynamically-sized arrays reverts or decodes to invalid data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;During construction of a contract, constructor parameters are copied from the code section to memory for decoding. The amount of bytes to copy was calculated incorrectly in case all parameters are statically-sized but contain dynamically-sized arrays as struct members or inner arrays. Such types are only available if ABIEncoderV2 is activated.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UninitializedFunctionPointerInConstructor&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behaviour.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Uninitialized internal function pointers point to a special piece of code that causes a revert when called. Jump target positions are different during construction and after deployment, but the code for setting this special jump target only considered the situation after deployment.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UninitializedFunctionPointerInConstructor_0.4.x&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behaviour.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Uninitialized internal function pointers point to a special piece of code that causes a revert when called. Jump target positions are different during construction and after deployment, but the code for setting this special jump target only considered the situation after deployment.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.26&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IncorrectEventSignatureInLibraries&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Contract types used in events in libraries cause an incorrect event signature hash&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Instead of using the type `address` in the hashed signature, the actual contract name was used, leading to a wrong hash in the logs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IncorrectEventSignatureInLibraries_0.4.x&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Contract types used in events in libraries cause an incorrect event signature hash&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Instead of using the type `address` in the hashed signature, the actual contract name was used, leading to a wrong hash in the logs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.26&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2PackedStorage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Elements of structs and arrays that are shorter than 32 bytes are not properly decoded from storage when encoded directly (i.e. not via a memory type) using ABIEncoderV2. This can cause corruption in the values themselves but can also overwrite other parts of the encoded data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2PackedStorage_0.4.x&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Elements of structs and arrays that are shorter than 32 bytes are not properly decoded from storage when encoded directly (i.e. not via a memory type) using ABIEncoderV2. This can cause corruption in the values themselves but can also overwrite other parts of the encoded data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.19&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.26&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IncorrectByteInstructionOptimization&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer incorrectly handles byte opcodes whose second argument is 31 or a constant expression that evaluates to 31. This can result in unexpected values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer incorrectly handles byte opcodes that use the constant 31 as second argument. This can happen when performing index access on bytesNN types with a compile-time constant value (not index) of 31 or when using the byte opcode in inline assembly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DoubleShiftSizeOverflow&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Double bitwise shifts by large constants whose sum overflows 256 bits can result in unexpected values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Nested logical shift operations whose total shift size is 2**256 or more are incorrectly optimized. This only applies to shifts by numbers of bits that are compile-time constant expressions.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;evmVersion&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&gt;=constantinople&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ExpExponentCleanup&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Using the ** operator with an exponent of type shorter than 256 bits can result in unexpected values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Higher order bits in the exponent are not properly cleaned before the EXP opcode is applied if the type of the exponent expression is smaller than 256 bits and not smaller than the type of the base. In that case, the result might be larger than expected if the exponent is assumed to lie within the value range of the type. Literal numbers as exponents are unaffected as are exponents or bases of type uint256.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.25&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;check&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;regex-source&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;[^/]\\*\\* *[^/0-9 ]&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;EventStructWrongData&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Using structs in events logged wrong data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a struct is used in an event, the address of the struct is logged instead of the actual data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.17&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.25&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;check&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;ast-compact-json-path&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;$..[?(@.nodeType === &#39;EventDefinition&#39;)]..[?(@.nodeType === &#39;UserDefinedTypeName&#39; &amp;&amp; @.typeDescriptions.typeString.startsWith(&#39;struct&#39;))]&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;NestedArrayFunctionCallDecoder&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling functions that return multi-dimensional fixed-size arrays can result in memory corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If Solidity code calls a function that returns a multi-dimensional fixed-size array, array elements are incorrectly interpreted as memory pointers and thus can cause memory corruption if the return values are accessed. Calling functions with multi-dimensional fixed-size arrays is unaffected as is returning fixed-size arrays from function calls. The regular expression only checks if such functions are present, not if they are called, which is required for the contract to be affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.1.4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.22&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;check&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;regex-source&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;returns[^;{]*\\[\\s*[^\\] \\t\\r\\n\\v\\f][^\\]]*\\]\\s*\\[\\s*[^\\] \\t\\r\\n\\v\\f][^\\]]*\\][^{;]*[;{]&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OneOfTwoConstructorsSkipped&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored. There will be a compiler warning about the old-style constructor, so contracts only using new-style constructors are fine.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.22&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.23&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ZeroFunctionSelector&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;It is possible to craft the name of a function such that it is executed instead of the fallback function in very specific circumstances.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a function has a selector consisting only of zeros, is payable and part of a contract that does not have a fallback function and at most five external functions in total, this function is called instead of the fallback function if Ether is sent to the contract without data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.18&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DelegateCallReturnValue&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The low-level .delegatecall() does not return the execution outcome, but converts the value returned by the functioned called to a boolean instead.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The return value of the low-level .delegatecall() function is taken from a position in memory, where the call data or the return data resides. This value is interpreted as a boolean and put onto the stack. This means if the called function returns at least 32 zero bytes, .delegatecall() returns false even if the call was successful.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ECRecoverMalformedInput&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The ecrecover() builtin can return garbage for malformed input.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The ecrecover precompile does not properly signal failure for malformed input (especially in the &#39;v&#39; argument) and thus the Solidity function can return data that was previously present in the return area in memory.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SkipEmptyStringLiteral&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If \&quot;\&quot; is used in a function call, the following function arguments will not be correctly passed to the function.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If the empty string literal \&quot;\&quot; is used as an argument in a function call, it is skipped by the encoder. This has the effect that the encoding of all arguments following this is shifted left by 32 bytes and thus the function call data is corrupted.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.12&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ConstantOptimizerSubtraction&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;In some situations, the optimizer replaces certain numbers in the code with routines that compute different numbers.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer tries to represent any number in the bytecode by routines that compute them with less gas. For some special numbers, an incorrect routine is generated. This could allow an attacker to e.g. trick victims about a specific amount of ether, or function calls to call different functions (or none at all).&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2017/05/03/solidity-optimizer-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IdentityPrecompileReturnIgnored&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Failure of the identity precompile was ignored.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calls to the identity contract, which is used for copying memory, ignored its return value. On the public chain, calls to the identity precompile can be made in a way that they never fail, but this might be different on private chains.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.7&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OptimizerStateKnowledgeNotResetForJumpdest&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was simplified to just use the empty state, but this implementation was not done properly. This bug can cause data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;HighOrderByteCleanStorage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;For short types, the high order bytes were not cleaned properly and could overwrite existing data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Types shorter than 32 bytes are packed together into the same 32 byte storage slot, but storage writes always write 32 bytes. For some types, the higher order bytes were not cleaned properly, which made it sometimes possible to overwrite a variable in storage when writing to another one.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2016/11/01/security-alert-solidity-variables-can-overwritten-storage/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.1.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.4&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OptimizerStaleKnowledgeAboutSHA3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer did not properly reset its knowledge about SHA3 operations resulting in some hashes (also used for storage variable positions) not being calculated correctly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer performs symbolic execution in order to save re-evaluating expressions whose value is already known. This knowledge was not properly reset across control flow paths and thus the optimizer sometimes thought that the result of a SHA3 operation is already present on the stack. This could result in data corruption by accessing the wrong storage slot.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;LibrariesNotCallableFromPayableFunctions&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Library functions threw an exception when called from a call that received Ether.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Library functions are protected against sending them Ether through a call. Since the DELEGATECALL opcode forwards the information about how much Ether was sent with a call, the library function incorrectly assumed that Ether was sent to the library and threw an exception.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.2&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SendFailsForZeroEther&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The send function did not provide enough gas to the recipient if no Ether was sent with it.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The recipient of an Ether transfer automatically receives a certain amount of gas from the EVM to handle the transfer. In the case of a zero-transfer, this gas is not provided which causes the recipient to throw an exception.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.0&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DynamicAllocationInfiniteLoop&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Dynamic allocation of an empty memory array caused an infinite loop and thus an exception.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Memory arrays can be created provided a length. If this length is zero, code was generated that did not terminate and thus consumed all gas.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.6&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OptimizerClearStateOnCodePathJoin&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was not done correctly. This bug can cause data corruption, but it is probably quite hard to use for targeted attacks.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;CleanBytesHigherOrderBits&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The higher order bits of short bytesNN types were not cleaned before comparison.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Two variables of type bytesNN were considered different if their higher order bits, which are not part of the actual value, were different. An attacker might use this to reach seemingly unreachable code paths by providing incorrectly formatted input data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.3&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ArrayAccessCleanHigherOrderBits&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Access to array elements for arrays of types with less than 32 bytes did not correctly clean the higher order bits, causing corruption in other array elements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Multiple elements of an array of values that are shorter than 17 bytes are packed into the same storage slot. Writing to a single element of such an array did not properly clean the higher order bytes and thus could lead to data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.1&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;AncientCompiler&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;This compiler version is ancient and might contain several undocumented or undiscovered bugs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The list of bugs is only kept for compiler versions starting from 0.3.0, so older versions might contain undocumented bugs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</section>
<span id="document-contributing"></span><section id="id1">
<h2>贡献方式<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>对于大家的帮助，我们一如既往地欢迎。而且有很多选择可以为 Solidity 做出贡献。</p>
<p>特别是，我们感谢在以下领域的支持:</p>
<ul class="simple">
<li><p>报告问题。</p></li>
<li><p>修复和回应 <a class="reference external" href="https://github.com/ethereum/solidity/issues">Solidity的GitHub问题</a>，特别是那些被标记为
<a class="reference external" href="https://github.com/ethereum/solidity/labels/good%20first%20issue">&quot;很好的第一个问题&quot;</a>，这是
作为外部贡献者的介绍性问题。</p></li>
<li><p>完善文档。</p></li>
<li><p>将文档翻译成更多的语言。</p></li>
<li><p>在 <a class="reference external" href="https://ethereum.stackexchange.com">StackExchange</a> 和
<a class="reference external" href="https://gitter.im/ethereum/solidity">Solidity Gitter Chat</a> 上回答其他用户的问题。</p></li>
<li><p>通过在 <a class="reference external" href="https://forum.soliditylang.org/">Solidity论坛</a> 上提出语言修改或新功能并提供反馈，参与语言设计过程。</p></li>
</ul>
<p>为了开始参与，您可以尝试 <a class="reference internal" href="index.html#building-from-source"><span class="std std-ref">从源代码编译</span></a>，以熟悉 Solidity 的组件和构建过程。
此外，精通在 Solidity 中编写智能合约可能是有用的。</p>
<p>请注意，本项目发布时有一个 <a class="reference external" href="https://raw.githubusercontent.com/ethereum/solidity/develop/CODE_OF_CONDUCT.md">贡献者行为准则</a>。参与此项目 - 在 issues，pull requests 或 Gitter channels 中 - 即表示您同意遵守其条款。</p>
<section id="id4">
<h3>团队电话会议<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>如果您有问题或拉动请求要讨论，或有兴趣听听团队和贡献者正在做什么，您可以加入我们的公共团队电话会议：</p>
<ul class="simple">
<li><p>每周一和周三下午3点，欧洲中部/欧洲中部夏令时间。</p></li>
</ul>
<p>这两个会议都在 <a class="reference external" href="https://meet.ethereum.org/solidity">Jitsi</a> 举行。</p>
</section>
<section id="id5">
<h3>如何报告问题<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>要报告一个问题，请使用
<a class="reference external" href="https://github.com/ethereum/solidity/issues">GitHub问题跟踪器</a>。
当报告问题时，请提及以下细节：</p>
<ul class="simple">
<li><p>Solidity版本。</p></li>
<li><p>源代码（如果可以的话）。</p></li>
<li><p>操作系统。</p></li>
<li><p>重现该问题的步骤。</p></li>
<li><p>实际行为与预期行为。</p></li>
</ul>
<p>将导致问题的源代码减少到最低限度总是非常有帮助的，有时甚至可以澄清一个误解。</p>
</section>
<section id="pull-request">
<h3>Pull Request 的工作流<a class="headerlink" href="#pull-request" title="此标题的永久链接"></a></h3>
<p>为了进行贡献，请 fork 一个 <code class="docutils literal notranslate"><span class="pre">develop</span></code> 分支并在那里进行修改。
除了您 <em>做了什么</em> 之外，您还需要在提交信息中说明，
您 <em>为什么</em> 做这些修改（除非只是个微小的改动）。</p>
<p>在进行了 fork 之后，如果您还需要从 <code class="docutils literal notranslate"><span class="pre">develop</span></code> 分支 pull 任何变更的话
（例如，为了解决潜在的合并冲突），请避免使用 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">rebase</span></code> ，
而是用 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">rebase</span></code> 您的分支。</p>
<p>此外，如果您正在编写一个新的功能，请确保您在 <code class="docutils literal notranslate"><span class="pre">test/</span></code> 下添加适当的测试案例（见下文）。</p>
<p>但是，如果您在进行一个更大的变更，请先与
<a class="reference external" href="https://gitter.im/ethereum/solidity-dev">Solidity Development Gitter channel</a>
（与上文提到的不同 - 这个变更侧重于编译器和编程语言开发，而不是编程语言的使用）进行咨询。</p>
<p>新的特性和 bug 修复会被添加到 <code class="docutils literal notranslate"><span class="pre">Changelog.md</span></code> 文件中：使用的时候请遵循上述方式。</p>
<p>最后，请确保您遵守了这个项目的 <a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/CODING_STYLE.md">编码风格</a> 。
还有，虽然我们采用了持续集成测试，但是在提交 pull request 之前，请测试您的代码并确保它能在本地进行编译。</p>
<p>感谢您的帮助！</p>
</section>
<section id="id7">
<h3>运行编译器测试<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<section id="id8">
<h4>先决条件<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>为了运行所有的编译器测试，您可能想选择性地安装一些依赖项
（ <a class="reference external" href="https://github.com/ethereum/evmone/releases">evmone</a>，
<a class="reference external" href="https://github.com/Z3Prover/z3">libz3</a>， 和
<a class="reference external" href="https://github.com/ewasm/hera">libhera</a>）。</p>
<p>在 macOS 系统上，一些测试脚本需要安装 GNU 核心工具。
可以使用 Homebrew 很简单地完成安装： <code class="docutils literal notranslate"><span class="pre">brew</span> <span class="pre">install</span> <span class="pre">coreutils</span></code>。</p>
<p>在 Windows 系统上，确保您有创建符号链接的权限，否则一些测试可能会失败。
管理员应该有这个权限，但您也可以
<a class="reference external" href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/create-symbolic-links#policy-management">将其授予其他用户</a>
或 <a class="reference external" href="https://docs.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development">启用开发者模式</a>。</p>
</section>
<section id="id11">
<h4>运行测试<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>Solidity包括不同类型的测试，其中大部分捆绑在
<a class="reference external" href="https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html">Boost C++测试框架</a> 应用程序 <code class="docutils literal notranslate"><span class="pre">soltest</span></code>。
运行 <code class="docutils literal notranslate"><span class="pre">build/test/soltest</span></code> 或其包装器 <code class="docutils literal notranslate"><span class="pre">scripts/soltest.sh</span></code> 对大多数变化来说是足够的。</p>
<p><code class="docutils literal notranslate"><span class="pre">./scripts/tests.sh</span></code> 脚本自动执行大多数Solidity测试，
包括那些捆绑在 <a class="reference external" href="https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html">Boost C++测试框架</a> 应用程序 <code class="docutils literal notranslate"><span class="pre">soltest</span></code>
（或其包装器 <code class="docutils literal notranslate"><span class="pre">scripts/soltest.sh</span></code>）中的测试，以及命令行测试和编译测试。</p>
<p>测试系统会自动尝试发现 <a class="reference external" href="https://github.com/ethereum/evmone/releases">evmone</a> 的位置，以运行语义测试。</p>
<p><code class="docutils literal notranslate"><span class="pre">evmone</span></code> 库必须位于当前工作目录相对的 <code class="docutils literal notranslate"><span class="pre">deps</span></code> 或 <code class="docutils literal notranslate"><span class="pre">deps/lib</span></code> 目录，
其父级目录或其父级目录的父级目录中。另外，
可以通过 <code class="docutils literal notranslate"><span class="pre">ETH_EVMONE</span></code> 环境变量指定 <code class="docutils literal notranslate"><span class="pre">evmone</span></code> 共享对象的显式位置。</p>
<p><code class="docutils literal notranslate"><span class="pre">evmone</span></code> 主要用于运行语义和gas测试。
如果您没有安装它，您可以通过向 <code class="docutils literal notranslate"><span class="pre">scripts/soltest.sh</span></code> 传递 <code class="docutils literal notranslate"><span class="pre">--no-semantic-tests</span></code> 标志来跳过这些测试。</p>
<p>运行Ewasm测试默认是禁用的，可以通过 <code class="docutils literal notranslate"><span class="pre">./scripts/soltest.sh</span> <span class="pre">--ewasm</span></code> 明确启用，
要求 <a class="reference external" href="https://github.com/ewasm/hera">hera</a> 被 <code class="docutils literal notranslate"><span class="pre">soltest</span></code> 找到。
定位 <code class="docutils literal notranslate"><span class="pre">hera</span></code> 库的机制与 <code class="docutils literal notranslate"><span class="pre">evmone</span></code> 相同，只是用于指定明确位置的变量被称为 <code class="docutils literal notranslate"><span class="pre">ETH_HERA</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">evmone</span></code> 和 <code class="docutils literal notranslate"><span class="pre">hera</span></code> 库的文件名后缀都应该
是Linux上的 <code class="docutils literal notranslate"><span class="pre">.so</span></code>，Windows系统上的 <code class="docutils literal notranslate"><span class="pre">.dll</span></code>，MacOS上的 <code class="docutils literal notranslate"><span class="pre">.dylib</span></code>。</p>
<p>为了运行SMT测试， <code class="docutils literal notranslate"><span class="pre">libz3</span></code> 库必须被安装，并在编译器配置阶段被 <code class="docutils literal notranslate"><span class="pre">cmake</span></code> 可以找到。</p>
<p>如果您的系统没有安装 <code class="docutils literal notranslate"><span class="pre">libz3</span></code> 库，您应该在运行 <code class="docutils literal notranslate"><span class="pre">./scripts/tests.sh</span></code> 或 <code class="docutils literal notranslate"><span class="pre">./scripts/soltest.sh</span> <span class="pre">--no-smt</span></code> 之前，
通过导出 <code class="docutils literal notranslate"><span class="pre">SMT_FLAGS=--no-smt</span></code> 来禁用SMT测试。
这些测试是 <code class="docutils literal notranslate"><span class="pre">libsolidity/smtCheckerTests</span></code> 和 <code class="docutils literal notranslate"><span class="pre">libsolidity/smtCheckerTestsJSON</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>要获得Soltest运行的所有单元测试的列表，请运行 <code class="docutils literal notranslate"><span class="pre">./build/test/soltest</span> <span class="pre">--list_content=HRF</span></code>。</p>
</div>
<p>为了获得更快的结果，您可以运行一个子集，或特定的测试。</p>
<p>要运行测试的一个子集，可以使用过滤器：
<code class="docutils literal notranslate"><span class="pre">./scripts/soltest.sh</span> <span class="pre">-t</span> <span class="pre">TestSuite/TestName</span></code>,
其中 <code class="docutils literal notranslate"><span class="pre">TestName</span></code> 可以是通配符 <code class="docutils literal notranslate"><span class="pre">*</span></code>。</p>
<p>或者，举例来说，运行yul 消歧义器的所有测试：
<code class="docutils literal notranslate"><span class="pre">./scripts/soltest.sh</span> <span class="pre">-t</span> <span class="pre">&quot;yulOptimizerTests/disambiguator/*&quot;</span> <span class="pre">--no-smt</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">./build/test/soltest</span> <span class="pre">--help</span></code> 有关于所有可用选项的广泛帮助。</p>
<p>尤其是可以查看：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.boost.org/doc/libs/release/libs/test/doc/html/boost_test/utf_reference/rt_param_reference/show_progress.html">show_progress (-p)</a> 来显示测试完成。</p></li>
<li><p><a class="reference external" href="https://www.boost.org/doc/libs/release/libs/test/doc/html/boost_test/utf_reference/rt_param_reference/run_test.html">run_test (-t)</a> 来运行特定的测试案例，以及</p></li>
<li><p><a class="reference external" href="https://www.boost.org/doc/libs/release/libs/test/doc/html/boost_test/utf_reference/rt_param_reference/report_level.html">report-level (-r)</a> 给出一个更详细的报告。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>那些在Windows环境下使用的人，想在没有libz3的情况下运行上述基本集，可以使用Git Bash，
使用命令为： <code class="docutils literal notranslate"><span class="pre">./build/test/Release/soltest.exe</span> <span class="pre">--</span> <span class="pre">--no-smt</span></code>。
如果您在普通的命令提示符下运行，使用 <code class="docutils literal notranslate"><span class="pre">.\build\test\Release\soltest.exe</span> <span class="pre">--</span> <span class="pre">--no-smt</span></code>。</p>
</div>
<p>如果您想使用GDB进行调试，确保您的构建方式与 “通常” 不同。
例如，您可以在您的 <code class="docutils literal notranslate"><span class="pre">build</span></code> 文件夹中运行以下命令：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>-DCMAKE_BUILD_TYPE<span class="o">=</span>Debug<span class="w"> </span>..
make
</pre></div>
</div>
<p>这会创建了一些符号，所以当您使用 <code class="docutils literal notranslate"><span class="pre">--debug</span></code> 标志调试测试时，
您可以访问其中的函数和变量，您可以用它来中断或打印。</p>
<p>CI运行额外的测试（包括 <code class="docutils literal notranslate"><span class="pre">solc-js</span></code> 和测试第三方Solidity框架），需要编译 Emscripten 目标。</p>
</section>
<section id="id14">
<h4>编写和运行语法测试<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h4>
<p>语法测试检查编译器是否对无效的代码产生正确的错误信息，并正确接受有效的代码。
它们被保存在 <code class="docutils literal notranslate"><span class="pre">tests/libsolidity/syntaxTests</span></code> 文件夹下的单个文件中。
这些文件必须包含注释，说明各自测试的预期结果。
测试套件会根据给定的期望值进行编译和检查。</p>
<p>例如： <code class="docutils literal notranslate"><span class="pre">./test/libsolidity/syntaxTests/double_stateVariable_declaration.sol</span></code></p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Y29udHJhY3QgdGVzdCB7CiAgICB1aW50MjU2IHZhcmlhYmxlOwogICAgdWludDEyOCB2YXJpYWJsZTsKfQovLyAtLS0tCi8vIOWjsOaYjumUmeivr++8mu+8iDM2LTUy77yJ44CC5qCH6K+G56ym5bey6KKr5aOw5piO44CC"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">contract</span><span class="w"> </span><span class="ni">test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">variable</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint128</span><span class="w"> </span><span class="nv">variable</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ----</span>
<span class="c1">// 声明错误：（36-52）。标识符已被声明。</span>
</pre></div>
</div>
<p>语法测试必须至少包含被测合约本身，后面是分隔符 <code class="docutils literal notranslate"><span class="pre">//----</span></code>。
分隔符后面的注释是用来描述预期的编译器错误或警告的。
数字范围表示错误发生在源代码中的位置。
如果您希望合约在编译时没有任何错误或警告，您可以不使用分隔符和后面的注释。</p>
<p>在上面的例子中，状态变量 <code class="docutils literal notranslate"><span class="pre">variable</span></code> 被声明了两次，这是不允许的。这导致了一个 <code class="docutils literal notranslate"><span class="pre">声明错误</span></code>，说明标识符已经被声明。</p>
<p>用来进行那些测试的工具叫做 <code class="docutils literal notranslate"><span class="pre">isoltest</span></code>，可以在 <code class="docutils literal notranslate"><span class="pre">./build/test/tools/</span></code> 下找到。
它是一个交互工具，允许您使用您喜欢的文本编辑器编辑失败的合约。
让我们把第二个 <code class="docutils literal notranslate"><span class="pre">variable</span></code> 的声明去掉来使测试失败：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Y29udHJhY3QgdGVzdCB7CiAgICB1aW50MjU2IHZhcmlhYmxlOwp9Ci8vIC0tLS0KLy8g5aOw5piO6ZSZ6K+v77ya77yIMzYtNTLvvInjgILmoIfor4bnrKblt7Looqvlo7DmmI7jgII="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">contract</span><span class="w"> </span><span class="ni">test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">variable</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ----</span>
<span class="c1">// 声明错误：（36-52）。标识符已被声明。</span>
</pre></div>
</div>
<p>再次运行 <code class="docutils literal notranslate"><span class="pre">./build/test/tools/isoltest</span></code> 就会得到一个失败的测试：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>syntaxTests/double_stateVariable_declaration.sol: FAIL
    Contract:
        contract test {
            uint256 variable;
        }

    Expected result:
        DeclarationError: (36-52): Identifier already declared.
    Obtained result:
        Success
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">isoltest</span></code> 在获得的结果旁边打印出预期的结果，
还提供了一个编辑，更新，跳过当前合约文件或退出应用程序的办法。</p>
<p>它为失败的测试提供了几种选择：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edit</span></code>：  <code class="docutils literal notranslate"><span class="pre">isoltest</span></code> 试图在一个编辑器中打开合约，以便您可以调整它。它或者使用命令行上给出的编辑器（如 <code class="docutils literal notranslate"><span class="pre">isoltest</span> <span class="pre">--editor</span> <span class="pre">/path/to/editor</span></code>），或者在环境变量 <code class="docutils literal notranslate"><span class="pre">EDITOR</span></code> 中，或者只是 <code class="docutils literal notranslate"><span class="pre">/usr/bin/editor</span></code> （按这个顺序）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">update</span></code>： 更新测试中的合约。这将会移除包含了不匹配异常的注解，或者增加缺失的预想结果。然后测试会重新开始。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">skip</span></code>： 跳过这一特定测试的执行。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quit</span></code>： 退出 <code class="docutils literal notranslate"><span class="pre">isoltest</span></code>。</p></li>
</ul>
<p>所有这些选项都适用于当前的合约，除了 <code class="docutils literal notranslate"><span class="pre">quit</span></code>，它可以停止整个测试过程。</p>
<p>在上边的情况自动更新合约会把它变为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.17&amp;code=Y29udHJhY3QgdGVzdCB7CiAgICB1aW50MjU2IHZhcmlhYmxlOwp9Ci8vIC0tLS0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">contract</span><span class="w"> </span><span class="ni">test</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">variable</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ----</span>
</pre></div>
</div>
<p>并重新运行测试。它将会通过：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Re-running test case...
syntaxTests/double_stateVariable_declaration.sol: OK
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为合约文件选择一个能解释其测试内容的名字，例如： <code class="docutils literal notranslate"><span class="pre">double_variable_declaration.sol</span></code>。
不要把一个以上的合约放在一个文件中，除非您在测试继承或跨合约的调用。
每个文件应该测试您的新功能的一个方面。</p>
</div>
</section>
</section>
<section id="afl-fuzzer">
<h3>通过 AFL 运行 Fuzzer<a class="headerlink" href="#afl-fuzzer" title="此标题的永久链接"></a></h3>
<p>Fuzzing 是一种测试技术，它可以通过运行多少不等的随机输入来找出异常的执行状态（片段故障、异常等等）。
现代的 fuzzer 已经可以很聪明地在输入中进行直接的查询。
我们有一个专门的程序叫做 <code class="docutils literal notranslate"><span class="pre">solfuzzer</span></code>，它可以将源代码作为输入，
当发生一个内部编译错误，片段故障或者类似的错误时失败，但当代码包含错误的时候则不会失败。
通过这种方法，fuzzing 工具可以找到那些编译级别的内部错误。</p>
<p>我们主要使用 <a class="reference external" href="https://lcamtuf.coredump.cx/afl/">AFL</a> 来进行 fuzzing 测试。
您需要手工下载和构建 AFL。然后用 AFL 作为编译器来构建 Solidity（或只是 <code class="docutils literal notranslate"><span class="pre">solfuzzer</span></code> 二进制文件）：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>build
<span class="c1"># 如果需要的话</span>
make<span class="w"> </span>clean
cmake<span class="w"> </span>..<span class="w"> </span>-DCMAKE_C_COMPILER<span class="o">=</span>path/to/afl-gcc<span class="w"> </span>-DCMAKE_CXX_COMPILER<span class="o">=</span>path/to/afl-g++
make<span class="w"> </span>solfuzzer
</pre></div>
</div>
<p>在这个阶段，您应该能够看到类似以下的信息：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Scanning dependencies of target solfuzzer
[ 98%] Building CXX object test/tools/CMakeFiles/solfuzzer.dir/fuzzer.cpp.o
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
afl-as 2.52b by &lt;lcamtuf@google.com&gt;
[+] Instrumented 1949 locations (64-bit, non-hardened mode, ratio 100%).
[100%] Linking CXX executable solfuzzer
</pre></div>
</div>
<p>如果指示信息没有出现，尝试切换指向AFL的clang二进制文件的cmake标志：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 如果之前失败了</span>
make<span class="w"> </span>clean
cmake<span class="w"> </span>..<span class="w"> </span>-DCMAKE_C_COMPILER<span class="o">=</span>path/to/afl-clang<span class="w"> </span>-DCMAKE_CXX_COMPILER<span class="o">=</span>path/to/afl-clang++
make<span class="w"> </span>solfuzzer
</pre></div>
</div>
<p>否则，在执行时，fuzzer 就会停止，并出现错误，说二进制没有被检测到。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;
... (truncated messages)
[*] Validating target binary...

[-] Looks like the target binary is not instrumented! The fuzzer depends on
    compile-time instrumentation to isolate interesting test cases while
    mutating the input data. For more information, and for tips on how to
    instrument binaries, please see /usr/share/doc/afl-doc/docs/README.

    When source code is not available, you may be able to leverage QEMU
    mode support. Consult the README for tips on how to enable this.
    (It is also possible to use afl-fuzz as a traditional, &quot;dumb&quot; fuzzer.
    For that, you can use the -n option - but expect much worse results.)

[-] PROGRAM ABORT : No instrumentation detected
         Location : check_binary(), afl-fuzz.c:6920
</pre></div>
</div>
<p>接下来，您需要一些示例源文件。这使得 fuzzer 更容易发现错误。
您可以从语法测试中复制一些文件，或者从文档或其他测试中提取测试文件。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>/tmp/test_cases
<span class="nb">cd</span><span class="w"> </span>/tmp/test_cases
<span class="c1"># 从测试中提取：</span>
path/to/solidity/scripts/isolate_tests.py<span class="w"> </span>path/to/solidity/test/libsolidity/SolidityEndToEndTest.cpp
<span class="c1"># 从文件中摘录：</span>
path/to/solidity/scripts/isolate_tests.py<span class="w"> </span>path/to/solidity/docs
</pre></div>
</div>
<p>AFL 的文档指出，账册（初始的输入文件）不应该太大。
每个文件本身不应该超过 1 kB，并且每个功能最多只能有一个输入文件；
所以最好从少量的输入文件开始。
此外还有一个叫做 <code class="docutils literal notranslate"><span class="pre">afl-cmin</span></code> 的工具，
可以将输入文件整理为可以具有近似行为的二进制代码。</p>
<p>现在运行 fuzzer（ <code class="docutils literal notranslate"><span class="pre">-m</span></code> 参数将使用的内存大小扩展为 60 MB）：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>afl-fuzz<span class="w"> </span>-m<span class="w"> </span><span class="m">60</span><span class="w"> </span>-i<span class="w"> </span>/tmp/test_cases<span class="w"> </span>-o<span class="w"> </span>/tmp/fuzzer_reports<span class="w"> </span>--<span class="w"> </span>/path/to/solfuzzer
</pre></div>
</div>
<p>fuzzer 会将导致失败的源文件创建在 <code class="docutils literal notranslate"><span class="pre">/tmp/fuzzer_reports</span></code> 中。
通常它会找到产生相似错误的类似的源文件。
您可以使用 <code class="docutils literal notranslate"><span class="pre">scripts/uniqueErrors.sh</span></code> 工具来那些独特的错误。</p>
</section>
<section id="whiskers">
<h3>Whiskers 系统<a class="headerlink" href="#whiskers" title="此标题的永久链接"></a></h3>
<p><em>Whiskers</em> 是一个类似于 <a class="reference external" href="https://mustache.github.io">Mustache</a> 的字符串模板化系统。
它被编译器用在不同的地方，以帮助代码的可读性，从而帮助代码的可维护性和可验证性。</p>
<p>该语法与Mustache有很大区别。模板标记 <code class="docutils literal notranslate"><span class="pre">{{</span></code> 和 <code class="docutils literal notranslate"><span class="pre">}}</span></code> 被 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 取代，
以帮助解析并避免与 <a class="reference internal" href="index.html#yul"><span class="std std-ref">Yul</span></a> 的冲突
（符号 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 在内联汇编中是无效的，而 <code class="docutils literal notranslate"><span class="pre">{</span></code> 和 <code class="docutils literal notranslate"><span class="pre">}</span></code> 是用来限定块的）。
另一个限制是，列表只能解决一个深度的问题，而且它们不会递归。这在将来可能会改变。</p>
<p>下面是一个粗略的说明：</p>
<p>任何出现的 <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> 的地方都会被提供的变量 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的字符串值替换，没有任何转义，也没有迭代替换。
可以用 <code class="docutils literal notranslate"><span class="pre">&lt;#name&gt;...&lt;/name&gt;</span></code> 来划定一个区域。
该区域中的内容将进行多次拼接，每次拼接会使用相应变量集中的值替换区域中的 <code class="docutils literal notranslate"><span class="pre">&lt;inner&gt;</span></code> 项，
模板系统中提供了多少组变量集，就会进行多少次拼接。顶层变量也可以在这种区域内使用。</p>
<p>还有一些判断条件的表达式 <code class="docutils literal notranslate"><span class="pre">&lt;?name</span> <span class="pre">&lt;!name&gt;...&lt;/name&gt;</span></code>，
根据布尔参数 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的值，会在第一段或第二段继续递归地替换模板。
如果使用 <code class="docutils literal notranslate"><span class="pre">&lt;?+name&gt;...&lt;!+name&gt;...&lt;/+name&gt;</span></code> 这种表达式，那么检查的是字符串参数 <code class="docutils literal notranslate"><span class="pre">name</span></code> 是否为非空。</p>
</section>
<section id="documentation-style">
<span id="id15"></span><h3>文档风格指南<a class="headerlink" href="#documentation-style" title="此标题的永久链接"></a></h3>
<p>在下面的部分，您可以找到专门针对 Solidity 文档贡献的风格建议。</p>
<section id="id16">
<h4>英语<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>使用英语，除非使用项目或品牌名称，否则首选英式拼写。
尽量减少使用当地的俚语和参考资料，尽量使您的语言对所有的读者都尽可能清晰。以下是一些参考资料，希望对大家有所帮助：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Simplified_Technical_English">简化技术英语</a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/International_English">国际英语</a></p></li>
<li><p><a class="reference external" href="https://en.oxforddictionaries.com/spelling/british-and-spelling">英式英语拼写</a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>虽然官方的 Solidity 文档是用英语写的，但也有社区贡献的其他语言的 <a class="reference internal" href="index.html#translations"><span class="std std-ref">翻译</span></a> 可用。
请参考 <a class="reference external" href="https://github.com/solidity-docs/translation-guide">翻译指南</a> 以了解如何为社区翻译作出贡献。</p>
</div>
</section>
<section id="id21">
<h4>标题的大小写<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h4>
<p>在标题中使用 <a class="reference external" href="https://titlecase.com">标题大小写</a>。
这意味着标题中的所有主词都要大写，但不包括冠词，连接词和介词，除非它们是标题的开头。</p>
<p>例如，下列各项都是正确的：</p>
<ul class="simple">
<li><p>Title Case for Headings.</p></li>
<li><p>For Headings Use Title Case.</p></li>
<li><p>Local and State Variable Names.</p></li>
<li><p>Order of Layout.</p></li>
</ul>
</section>
<section id="id23">
<h4>扩写缩写<a class="headerlink" href="#id23" title="此标题的永久链接"></a></h4>
<p>使用扩展的缩略语来表达单词，例如：</p>
<ul class="simple">
<li><p>&quot;Do not&quot; 替代 &quot;Don't&quot;。</p></li>
<li><p>&quot;Can not&quot; 替代 &quot;Can't&quot;。</p></li>
</ul>
</section>
<section id="id24">
<h4>主动和被动语态<a class="headerlink" href="#id24" title="此标题的永久链接"></a></h4>
<p>主动语态通常被推荐用于教程风格的文档，因为它有助于读者理解谁或什么在执行一项任务。
然而，由于 Solidity 文档是教程和参考内容的混合物，被动语态有时更适用。</p>
<p>综上所述：</p>
<ul class="simple">
<li><p>在技术参考方面使用被动语态，例如语言定义和Ethereum虚拟机的内部情况。</p></li>
<li><p>在描述关于如何应用 Solidity 某方面的建议时，使用主动语态。</p></li>
</ul>
<p>例如，下面的内容是被动语态，因为它指定了 Solidity 的一个方面：</p>
<blockquote>
<div><p>函数可以被声明为 <code class="docutils literal notranslate"><span class="pre">pure</span></code>，在这种情况下，它们承诺不读取或修改状态。</p>
</div></blockquote>
<p>例如，下面是主动语态，因为它讨论了Solidity的一个应用：</p>
<blockquote>
<div><p>在调用编译器时，您可以指定如何发现一个路径的第一个元素，也可以指定路径前缀的重映射。</p>
</div></blockquote>
</section>
<section id="id25">
<h4>常用术语<a class="headerlink" href="#id25" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>“函数参数“ 和 “返回变量“，而不是输入和输出参数。</p></li>
</ul>
</section>
<section id="id26">
<h4>代码示例<a class="headerlink" href="#id26" title="此标题的永久链接"></a></h4>
<p>CI进程在您创建PR时，使用 <code class="docutils literal notranslate"><span class="pre">./test/cmdlineTests.sh</span></code> 脚本测试所有
以 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">solidity</span></code>， <code class="docutils literal notranslate"><span class="pre">contract</span></code>， <code class="docutils literal notranslate"><span class="pre">library</span></code> 或 <code class="docutils literal notranslate"><span class="pre">interface</span></code> 开头的代码块格式的示例代码。
如果您正在添加新的代码实例，在创建PR之前确保它们能够工作并通过测试。</p>
<p>确保所有的代码实例以 <code class="docutils literal notranslate"><span class="pre">pragma</span></code> 版本开始，跨越合约代码有效的最大范围。
例如 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">solidity</span> <span class="pre">&gt;=0.4.0</span> <span class="pre">&lt;0.9.0;</span></code>。</p>
</section>
<section id="id27">
<h4>运行文档测试<a class="headerlink" href="#id27" title="此标题的永久链接"></a></h4>
<p>通过运行 <code class="docutils literal notranslate"><span class="pre">./scripts/docs.sh</span></code> 来确保您的贡献通过我们的文档测试，
它安装了文档所需的依赖，并检查是否存在问题，如无效的链接或语法问题。</p>
</section>
</section>
<section id="id28">
<h3>Solidity语言设计<a class="headerlink" href="#id28" title="此标题的永久链接"></a></h3>
<p>为了积极参与语言设计过程，并分享您关于 Solidity 未来的想法，请加入 <a class="reference external" href="https://forum.soliditylang.org/">Solidity 论坛</a>。</p>
<p>Solidity论坛作为提出和讨论新的语言功能及其在早期构思阶段的实现或现有功能的修改的一个地方。</p>
<p>一旦提案变得更加具体，
它们的实施也将在 <a class="reference external" href="https://github.com/ethereum/solidity">Solidity GitHub仓库</a> 中以问题的形式讨论。</p>
<p>除了论坛和问题讨论之外，我们还定期举办语言设计讨论会议，对选定的主题，问题或功能实现进行详细的辩论。
这些会议的邀请函通过论坛共享。</p>
<p>我们也在论坛中分享反馈调查和其他与语言设计相关的内容。</p>
<p>如果您想知道团队在实施新功能方面的情况，
您可以在 <a class="reference external" href="https://github.com/ethereum/solidity/projects/43">Solidity Github项目</a> 中关注实施状况。
设计积压中的问题需要进一步规范，将在语言设计电话会议或常规团队电话会议中讨论。
您可以通过从默认分支（ <cite>develop</cite> ）到 <a class="reference external" href="https://github.com/ethereum/solidity/tree/breaking">breaking 分支</a>
来查看下一个突破性版本即将发生的变化。</p>
<p>对于特殊情况和问题，您可以通过 <a class="reference external" href="https://gitter.im/ethereum/solidity-dev">Solidity-dev Gitter 频道</a> 与我们联系，
- 这是一个专门用于围绕 Solidity 编译器和语言开发的聊天室。</p>
<p>我们很高兴听到你对我们如何改进语言设计过程，使之更加协作和透明的想法。</p>
</section>
</section>
<span id="document-brand-guide"></span><section id="solidity">
<h2>Solidity 品牌指南<a class="headerlink" href="#solidity" title="此标题的永久链接"></a></h2>
<p>该品牌指南的特点是关于Solidity的品牌政策和标志使用指南的信息。</p>
<section id="id1">
<h3>Solidity品牌<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h3>
<p>Solidity编程语言是一个开源的社区项目，由一个核心团队管理。
该核心团队由 <a class="reference external" href="https://ethereum.foundation/">以太坊基金会</a> 赞助。</p>
<p>本文件旨在提供有关如何最好地使用 Solidity 品牌名称和标识的信息。</p>
<p>我们鼓励您在使用该品牌名称或标志之前仔细阅读本文件。我们非常感谢您的合作!</p>
</section>
<section id="id3">
<h3>Solidity 品牌名称<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>“Solidity” 应该只用来指Solidity编程语言。</p>
<p>请不要按以下方式使用 “Solidity”：</p>
<ul class="simple">
<li><p>指的是任何其他编程语言。</p></li>
<li><p>以一种误导性的方式，或可能暗示不相关的模块，工具，文档
或其他资源与 Solidity 编程语言的关联。</p></li>
<li><p>在方式上，混淆了社区对Solidity编程语言是否开源和免费使用的看法。</p></li>
</ul>
</section>
<section id="id4">
<h3>Solidity标志许可<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<a class="reference internal image-reference" href="https://i.creativecommons.org/l/by/4.0/88x31.png"><img alt="Creative Commons License" src="https://i.creativecommons.org/l/by/4.0/88x31.png" style="width: 88px;" /></a>
<p>Solidity标志是在
<a class="reference external" href="https://creativecommons.org/licenses/by/4.0/">创意共享署名4.0国际许可协议</a> 下发布和许可的。</p>
<p>这是最宽松的知识共享协议，允许为任何目的进行再利用和修改。</p>
<p>您可以自由选择以下方式：</p>
<ul class="simple">
<li><p><strong>分享</strong> - 以任何媒介或形式复制和重新分发材料。</p></li>
<li><p><strong>修改</strong> - 为任何目的，甚至为商业目的，对材料进行混音，改造和构建。</p></li>
</ul>
<p>根据以下条款：</p>
<ul class="simple">
<li><p><strong>署名</strong> - 您必须给予适当的信用，提供到许可证的链接，并说明是否进行了修改。
您可以以任何合理的方式这样做，但不能以任何方式暗示 Solidity 核心团队认可您或您的使用。</p></li>
</ul>
<p>在使用Solidity标识时，请尊重Solidity标识指南。</p>
</section>
<section id="id6">
<h3>Solidity标志指南<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<a class="reference internal image-reference" href="_images/logo.svg"><img alt="_images/logo.svg" src="_images/logo.svg" width="256" /></a>
<p><em>（右键点击标识即可下载。）</em></p>
<p>请不要这样做：</p>
<ul class="simple">
<li><p>改变标志的比例（不要拉伸或切割）。</p></li>
<li><p>改变标志的颜色，除非是绝对必要。</p></li>
</ul>
</section>
<section id="id7">
<h3>信用<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<p>本文件部分内容来自于
<a class="reference external" href="https://www.python.org/psf/trademarks/">Python软件基金会商标使用政策</a>
和 <a class="reference external" href="https://www.rust-lang.org/policies/media-guide">Rust媒介指南</a> 。</p>
</section>
</section>
<span id="document-language-influences"></span><section id="id1">
<h2>语言的影响因素<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>Solidity是一种 <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages">花括号语言</a>，
受到几种著名编程语言的影响和启发。</p>
<p>Solidity受C++的影响最深，但也借用了Python，JavaScript等语言的概念。</p>
<p>从变量声明的语法，for循环，重载函数的概念，隐式和显式类型转换以及许多其他细节中可以看出C++的影响。</p>
<p>这是由于变量的函数级范围和关键字 <code class="docutils literal notranslate"><span class="pre">var</span></code> 的使用。
从0.4.0版本开始，JavaScript的影响已经减少。
现在，剩下的与JavaScript的主要相似之处是，使用关键字 <code class="docutils literal notranslate"><span class="pre">function</span></code> 来定义函数。
Solidity还支持导入语法和语义，这些都与JavaScript中的相似。
除了这些点，Solidity看起来和其他大多数花括号语言一样，不再有主要的JavaScript影响。</p>
<p>对Solidity的另一个影响是Python。
Solidity的修改器是为了模拟Python的装饰器而添加的，但其功能受到很大限制。
此外，多重继承，C3线性化和 <code class="docutils literal notranslate"><span class="pre">super</span></code> 关键字以及值和引用类型的一般赋值和复制语义都来自Python。</p>
</section>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2016-2021, Ethereum.
      <span class="commit">版本 <code>c529ed98</code>.
      </span></p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
  
    <p>
        <a href="#">Credits and attribution</a>.
    </p>


</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v: v0.8.17 <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>下载</dt> 
        </dl>
        <dl>
            <dt>版本</dt> 
            <dd><a href="/zh/latest/">latest</a></dd>
            
            <dd><a href="/zh/stable/">stable</a></dd>
            
            <dd><a href="/zh/v0.8.17/">v0.8.17</a></dd>
            
            <dd><a href="/zh/v0.8.16/">v0.8.16</a></dd>
            
        </dl>
        <dl>
            
            <dt>托管于 Read the Docs</dt>
            <dd>
                <a href="//readthedocs.org/projects/solidity-docs-chinese/?fromdocs=solidity-docs-chinese">项目主页</a>
            </dd>
            <dd>
                <a href="//readthedocs.org/builds/solidity-docs-chinese/?fromdocs=solidity-docs-chinese">构建</a>
            </dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>